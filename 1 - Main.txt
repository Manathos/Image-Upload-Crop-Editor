const canvasEl = document.getElementById('c');
    

    
    // Modal artboard management (boundary now handled by wrapper)
    let modalArtboardWidth = 0; // Full workspace width
    let modalArtboardHeight = 0; // Full workspace height
    let modalCanvasWidth = 0; // 77:29 output area width
    let modalCanvasHeight = 0; // 77:29 output area height
    
    // Check if Fabric.js is loaded
    if (typeof fabric === 'undefined') {
      console.error('Fabric.js is not loaded!');
      alert('Fabric.js library failed to load. Please check your internet connection.');
    } else {
      
      
      // Set global Fabric.js object defaults for better visibility
      fabric.Object.prototype.cornerColor = '#2c3e50'; // Dark blue-gray
      fabric.Object.prototype.cornerStrokeColor = '#ffffff'; // White border
      fabric.Object.prototype.transparentCorners = false;
      fabric.Object.prototype.cornerStyle = 'circle';
      fabric.Object.prototype.cornerSize = 20; // Sweet spot - not too big, not too small
      fabric.Object.prototype.cornerStrokeWidth = 2;
      fabric.Object.prototype.borderColor = '#2c3e50'; // Dark blue-gray selection border
      fabric.Object.prototype.borderScaleFactor = 2;
      fabric.Object.prototype.selectable = true;
      fabric.Object.prototype.evented = true;
      // --- GLOBAL: Remove all default object strokes ---
      fabric.Object.prototype.stroke = 'transparent';
      fabric.Object.prototype.strokeWidth = 0;
      
      // Fix textBaseline errors by setting correct defaults
      fabric.Text.prototype.textBaseline = 'alphabetic';
      fabric.IText.prototype.textBaseline = 'alphabetic';
      
      // Custom Text class with stroke positioning support
      fabric.StrokeText = fabric.util.createClass(fabric.IText, {
        type: 'i-text', // Keep the same type for compatibility
        
        initialize: function(text, options) {
          this.callSuper('initialize', text, options);
          this.strokePosition = options.strokePosition || 'outer';
        },
        
        _render: function(ctx) {
          if (!this.stroke || this.stroke === 'transparent' || this.strokeWidth <= 0) {
            return this.callSuper('_render', ctx);
          }
          
          const originalFill = this.fill;
          const originalStroke = this.stroke;
          const originalStrokeWidth = this.strokeWidth;
          
          if (this.strokePosition === 'outer') {
            // Draw stroke first (behind text) - make it thicker for outer effect
            this.fill = 'transparent';
            this.stroke = originalStroke;
            this.strokeWidth = originalStrokeWidth * 2; // Double the stroke width for outer effect
            
            // Save current transform
            ctx.save();
            // Slightly offset the stroke for more obvious outer effect
            ctx.translate(1, 1);
            this.callSuper('_render', ctx);
            ctx.restore();
            
            // Then draw fill text on top
            this.fill = originalFill;
            this.stroke = 'transparent';
            this.strokeWidth = 0;
            this.callSuper('_render', ctx);
          } else if (this.strokePosition === 'center') {
            // Center stroke - use original stroke width for contrast with outer
            this.strokeWidth = originalStrokeWidth;
            this.callSuper('_render', ctx);
          } else {
            // Default behavior
            this.callSuper('_render', ctx);
          }
          
          // Restore original properties
          this.fill = originalFill;
          this.stroke = originalStroke;
          this.strokeWidth = originalStrokeWidth;
        }
      });
      
      fabric.StrokeText.fromObject = function(object, callback) {
        return fabric.Object._fromObject('StrokeText', object, callback);
      };
    }
    
    // Main canvas removed - only using modal canvas now
    let fabricCanvas = null;
    
    // Background management
    let currentBackground = {
      type: 'transparent',
      color: '#ffffff'
    };
    let backgroundRect = null;

    function calculateDPI(imageWidth, imageHeight, displayWidth, displayHeight) {
      // Calculate effective DPI based on the image's original dimensions vs current display size
      // This shows the actual DPI quality of the image at its current scale
      const dpiX = (imageWidth / displayWidth) * currentDPI;
      const dpiY = (imageHeight / displayHeight) * currentDPI;
      return { dpiX: Math.round(dpiX), dpiY: Math.round(dpiY) };
    }



    function getDPIQualityInfo(dpi) {
      // Determine quality level and color based on DPI
      let quality, color;
      
      if (dpi < 72) {
        quality = 'Low Quality';
        color = '#ff4444'; // Red
      } else if (dpi >= 72 && dpi <= 100) {
        quality = 'Good';
        color = '#44ff44'; // Green
      } else {
        quality = 'Great Quality';
        color = '#ffaa00'; // Gold
      }
      
      return { quality, color };
    }



    function calculateOptimalCanvasSize(imageWidth, imageHeight) {
      // Calculate optimal canvas size to fit the image with minimal scaling
      // Maintain 77:29 aspect ratio while maximizing image size
      const aspectRatio = 77 / 29;
      
      // Calculate how the image would fit in the aspect ratio
      const imageAspectRatio = imageWidth / imageHeight;
      
      if (imageAspectRatio > aspectRatio) {
        // Image is wider than target ratio - fit by width
        const finalWidth = imageWidth;
        const finalHeight = Math.round(imageWidth / aspectRatio);
        return { width: finalWidth, height: finalHeight };
      } else {
        // Image is taller than target ratio - fit by height
        const finalHeight = imageHeight;
        const finalWidth = Math.round(imageHeight * aspectRatio);
        return { width: finalWidth, height: finalHeight };
      }
    }



    // Remove old in-canvas crop overlay code and listeners
    // Add modal HTML to the page
    const modalHtml = `
      <!-- Loading overlay - separate from modal -->
      <div id="loading-overlay" style="display:flex;position:fixed;z-index:20001;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.5);flex-direction:column;justify-content:center;align-items:center;">
        <div id="loading-spinner" style="width:60px;height:60px;border:4px solid #333;border-top:4px solid #f4a012;border-radius:50%;animation:spin 1s linear infinite;margin-bottom:20px;"></div>
        <div id="loading-text" style="font-size:18px;font-weight:bold;color:#f4a012;">Preparing image editor...</div>
      </div>
      
      <div id="crop-modal-overlay" style="display:none;position:fixed;z-index:20000;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.85);display:none;flex-direction:column;justify-content:center;align-items:center;">
        <div id="crop-modal-toolbar" style="width:100vw;display:flex;justify-content:space-between;align-items:center;padding:32px 48px 16px 48px;box-sizing:border-box;">
          <div>
            <button id="crop-modal-cancel" style="background:#333;color:#fff;border:none;padding:10px 24px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Cancel</button>
          </div>
          <div>
            <button id="crop-modal-rotate" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Rotate 90° clockwise">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 4v6h-6"/>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
              </svg>
            </button>
            <button id="crop-modal-flip-h" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Flip horizontally">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3"/>
                <path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/>
                <path d="M12 20v2"/>
                <path d="M12 14v2"/>
                <path d="M12 8v2"/>
                <path d="M12 2v2"/>
              </svg>
            </button>
            <button id="crop-modal-flip-v" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Flip vertically">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 7V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v2"/>
                <path d="M3 17v2a2 2 0 0 0 2 2h14a2 2 0 0 1 2-2v-2"/>
                <path d="M20 12v2"/>
                <path d="M14 12v2"/>
                <path d="M8 12v2"/>
                <path d="M2 12v2"/>
              </svg>
            </button>
            <button id="crop-modal-crop" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Crop image">✂️</button>
            <button id="crop-modal-revert" style="background:#666;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Revert to original">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L23 8"/>
                <path d="M21 3v5h-5"/>
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                <path d="M3 21v-5h5"/>
              </svg>
            </button>
            <button id="crop-modal-info" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Image Information">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M12 16v-4"/>
                <path d="M12 8h.01"/>
              </svg>
            </button>
            <button id="crop-modal-apply" style="background:#ffe066;color:#222;border:none;padding:10px 24px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">OK</button>
          </div>
        </div>
        <div id="crop-modal-croparea" style="flex:1;display:flex;justify-content:center;align-items:center;width:100vw;">
          <div id="crop-modal-img-container" style="position:relative;display:flex;justify-content:center;align-items:center;background:transparent;">
            <canvas id="crop-modal-canvas" style="display:block;user-select:none;width:90vw;height:90vh;max-width:90vw;max-height:90vh;box-shadow:none;margin:0;background:#222;"></canvas>
            <div id="crop-modal-cropbox" style="position:absolute;border:2px dashed #ffe066 !important;border-radius:8px;box-sizing:border-box;pointer-events:auto;display:none;background:rgba(255, 255, 0, 0.08) !important;z-index:1;"></div>
          </div>
        </div>
        <div id="crop-modal-bottom-buttons" style="display:none;width:100vw;justify-content:center;gap:32px;padding:32px;box-sizing:border-box;z-index:9999;">
          <button id="crop-modal-crop-apply" style="background:#ffe066;color:#222;border:none;padding:10px 32px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Apply Crop</button>
          <button id="crop-modal-crop-cancel" style="background:#333;color:#fff;border:none;padding:10px 32px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Cancel Crop</button>
        </div>
        <div id="crop-modal-transform-buttons" style="display:none;width:100vw;justify-content:center;gap:32px;padding:32px;box-sizing:border-box;">
          <button id="crop-modal-transform-apply" style="background:#ffe066;color:#222;border:none;padding:10px 32px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Apply Changes</button>
          <button id="crop-modal-transform-cancel" style="background:#333;color:#fff;border:none;padding:10px 32px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Cancel Changes</button>
        </div>
        
        <!-- Image Info Popup -->
        <div id="image-info-popup" style="display:none;position:absolute;z-index:20001;background:#333;border-radius:8px;padding:16px;box-shadow:0 4px 16px rgba(0,0,0,0.4);max-width:280px;width:auto;color:#fff;font-size:14px;line-height:1.4;border:1px solid #444;">
          <div style="margin-bottom:8px;font-weight:bold;color:#ffe066;font-size:13px;text-transform:uppercase;letter-spacing:0.5px;">Image Info</div>
          <div id="image-info-content" style="color:#ccc;">
            <div style="margin-bottom:6px;">
              <span style="color:#999;font-size:12px;">Original:</span><br>
              <span id="info-original-dimensions" style="color:#fff;">Loading...</span>
            </div>
            <div style="margin-bottom:6px;">
              <span style="color:#999;font-size:12px;">Current:</span><br>
              <span id="info-current-dimensions" style="color:#fff;">Loading...</span>
            </div>
            <div style="margin-bottom:6px;">
              <span style="color:#999;font-size:12px;">Print Size (300 DPI):</span><br>
              <span id="info-dpi" style="color:#fff;">Loading...</span>
            </div>
            <div style="margin-bottom:6px;">
              <span style="color:#999;font-size:12px;">File:</span><br>
              <span id="info-file-size" style="color:#fff;">Loading...</span> • <span id="info-format" style="color:#fff;">Loading...</span>
            </div>
            <div style="margin-bottom:0;">
              <span style="color:#999;font-size:12px;">Transformations:</span><br>
              <span id="info-transformations" style="color:#fff;">None</span>
            </div>
          </div>
          <div style="position:absolute;bottom:-6px;left:20px;width:12px;height:12px;background:#333;border-left:1px solid #444;border-top:1px solid #444;transform:rotate(45deg);"></div>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const loadingOverlay = document.getElementById('loading-overlay');
    const cropModalOverlay = document.getElementById('crop-modal-overlay');
    const cropModal = document.getElementById('crop-modal');
    const cropModalCanvas = document.getElementById('crop-modal-canvas');
    const cropModalImgContainer = document.getElementById('crop-modal-img-container');
    const cropModalApply = document.getElementById('crop-modal-apply');
    const cropModalCancel = document.getElementById('crop-modal-cancel');
    const cropModalRotate = document.getElementById('crop-modal-rotate');
    const cropModalFlipH = document.getElementById('crop-modal-flip-h');
    const cropModalFlipV = document.getElementById('crop-modal-flip-v');
    const cropModalCrop = document.getElementById('crop-modal-crop');
    const cropModalRevert = document.getElementById('crop-modal-revert');
    const cropModalInfo = document.getElementById('crop-modal-info');
    const cropModalCropApply = document.getElementById('crop-modal-crop-apply');
    const cropModalCropCancel = document.getElementById('crop-modal-crop-cancel');
    const cropModalTransformApply = document.getElementById('crop-modal-transform-apply');
    const cropModalTransformCancel = document.getElementById('crop-modal-transform-cancel');
    const cropModalCropbox = document.getElementById('crop-modal-cropbox');
    const cropModalBottomButtons = document.getElementById('crop-modal-bottom-buttons');
    const cropModalTransformButtons = document.getElementById('crop-modal-transform-buttons');
    const cropModalToolbar = document.getElementById('crop-modal-toolbar');
    
    // Image info popup elements
    const imageInfoPopup = document.getElementById('image-info-popup');

    let modalRotation = 0; // Track rotation in degrees
    let modalFlipH = false; // Track horizontal flip
    let modalFlipV = false; // Track vertical flip
    let workingRotation = 0; // Track the working rotation (persists between modal sessions)
    let workingFlipH = false; // Track the working horizontal flip (persists between modal sessions)
    let workingFlipV = false; // Track the working vertical flip (persists between modal sessions)

    let cropRotation = 0; // Track the rotation when crop button is clicked
    let cropFlipH = false; // Track the horizontal flip when crop button is clicked
    let cropFlipV = false; // Track the vertical flip when crop button is clicked
    let originalImageWidth = 0; // Track original image dimensions
    let originalImageHeight = 0;
    let origFabricImg = null; // Store reference to original image for replacement
    let originalFabricImg = null; // Store reference to the very original image (never changes)
    // Note: veryOriginalImageDataUrl is now stored on each image object as _originalDataUrl
    let modalImageElement = null;
    let cropMode = false; // Track if we're in crop mode
    let transformMode = false; // Track if we're in transform mode (rotate/flip)
    let originalImageDataUrl = null;
    let lastCropBoxState = null;
    let cropBoxAspect = null; // Always freeform aspect ratio




    // Modal open/close helpers
    function updateImageTransform() {
      // This function is no longer needed as transform is removed from modal image
      // cropModalImg.style.transform = transform;
      // Function kept for compatibility but no longer needed
    }

    // --- Update openCropModal to use separate loading overlay ---
    function openCropModal(imgUrl, origImg) {
      
      // Loading overlay is already shown from double-click handler
      // Process everything in background
      setTimeout(() => {
        // Store reference to original image
        origFabricImg = origImg;
        // Store reference to the very original image (update for each new image)
        originalFabricImg = origImg;
        

        
        // Store the original data URL on the image object if not already stored
        if (!origImg._originalDataUrl) {
          origImg._originalDataUrl = imgUrl;
        }
        
        // Reset working transforms for new image (rotation/flip handled in modal only)
        workingRotation = 0;
        workingFlipH = false;
        workingFlipV = false;
        
        // Set modal transforms to match working orientation
        modalRotation = workingRotation;
        modalFlipH = workingFlipH;
        modalFlipV = workingFlipV;

        // Check if we already have a cached lower resolution image for this image
        if (origImg._cachedModalImage && origImg._cachedModalImage.complete) {
          // Use cached lower resolution image
          modalImageElement = origImg._cachedModalImage;
          // Process the image
          setupModalCanvas();
        } else {
          // Create a lower resolution version for the modal
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          
          // Calculate optimal modal size (max 2000px on longest side for performance)
          const maxModalSize = 2000;
          const imgWidth = origImg.width;
          const imgHeight = origImg.height;
          const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
          
          const modalWidth = Math.round(imgWidth * scale);
          const modalHeight = Math.round(imgHeight * scale);
          
          
          
          // Set canvas size to modal size
          tempCanvas.width = modalWidth;
          tempCanvas.height = modalHeight;
          
          // Draw the resized image normally
          tempCtx.drawImage(origImg._element, 0, 0, modalWidth, modalHeight);
          
          // Create image from the resized canvas
          modalImageElement = new window.Image();
          modalImageElement.onload = function() {

            // Cache this lower resolution image for future use
            origImg._cachedModalImage = modalImageElement;
            origImg._modalScale = scale; // Store the scale factor for later use
            // Process the image
            setupModalCanvas();
          };
          modalImageElement.src = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size
        }
      }, 100); // Small delay to ensure loading overlay is visible
    }
    
    function showModalLoadingState() {
      // Show a simple loading state
      cropModalCanvas.width = 400;
      cropModalCanvas.height = 300;
      cropModalCanvas.style.width = '400px';
      cropModalCanvas.style.height = '300px';
      cropModalImgContainer.style.width = '400px';
      cropModalImgContainer.style.height = '300px';
      
      const ctx = cropModalCanvas.getContext('2d');
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, 400, 300);
      ctx.fillStyle = '#666';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Loading image...', 200, 150);
    }
    
    function setupModalCanvas() {
      
      // Set up canvas and container dimensions to match the image (no stretching)
      const imgWidth = modalImageElement.width;
      const imgHeight = modalImageElement.height;
      const maxW = window.innerWidth * 0.9;
      const maxH = window.innerHeight * 0.9;
      let scale = Math.min(maxW / imgWidth, maxH / imgHeight, 1);
      let displayWidth = imgWidth * scale;
      let displayHeight = imgHeight * scale;

      

      // Since we're now using a lower resolution version, we can process it more efficiently
      setTimeout(() => {
        // Set canvas dimensions to match the modal image
        cropModalCanvas.width = imgWidth;
        cropModalCanvas.height = imgHeight;
        cropModalCanvas.style.width = displayWidth + 'px';
        cropModalCanvas.style.height = displayHeight + 'px';
        cropModalImgContainer.style.width = displayWidth + 'px';
        cropModalImgContainer.style.height = displayHeight + 'px';

        // Store the modal image dimensions (these are the lower resolution dimensions)
        originalImageWidth = imgWidth;
        originalImageHeight = imgHeight;

        cropModalCanvas.style.marginLeft = '0px';
        cropModalCanvas.style.marginTop = '0px';
        cropModalCanvas.style.transform = '';

        // Draw the image with transforms
        setTimeout(() => {
          drawModalCanvasWithTransforms();
          
          // Show modal after drawing is complete
          setTimeout(() => {
            loadingOverlay.classList.remove('show');
            cropModalOverlay.style.display = 'flex';
          }, 50);
        }, 25);
        

      }, 10);
    }
    
    function preCacheImageForModal(fabricImg) {
      // Pre-cache a lower resolution version for the modal
      if (!fabricImg._cachedModalImage) {

        
        // Create a temporary canvas to resize the image
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        // Calculate optimal modal size (max 2000px on longest side for performance)
        const maxModalSize = 2000;
        const imgWidth = fabricImg.width;
        const imgHeight = fabricImg.height;
        const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
        
        const modalWidth = Math.round(imgWidth * scale);
        const modalHeight = Math.round(imgHeight * scale);
        
        
        
        // Set canvas size to modal size
        tempCanvas.width = modalWidth;
        tempCanvas.height = modalHeight;
        
        // Draw the resized image
        tempCtx.drawImage(fabricImg._element, 0, 0, modalWidth, modalHeight);
        
        // Create image from the resized canvas
        const cachedImg = new window.Image();
        cachedImg.onload = function() {
          fabricImg._cachedModalImage = cachedImg;
          fabricImg._modalScale = scale; // Store the scale factor for later use

        };
        cachedImg.src = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size
              } else {
          // Lower resolution image already pre-cached
        }
    }
      cropModalApply.onclick = function() {
        // Apply rotation and flips to the entire image
        if (modalRotation === 0 && !modalFlipH && !modalFlipV) {
          // No changes - just close modal
          closeCropModal();
          return;
        }
        
        // Call the applyRotation function which handles both rotation and flips
        applyRotation();
      };
      
      // Crop button click handler
      cropModalCrop.onclick = function() {
        enterCropMode();
      };
      
      // Revert button click handler
      cropModalRevert.onclick = function() {
        revertToOriginal();
      };
      
      // Crop apply button click handler
      cropModalCropApply.onclick = function() {
        applyCrop();
      };
      
      // Crop cancel button click handler
      cropModalCropCancel.onclick = function() {
        exitCropMode();
      };
      
      // Transform apply button click handler
      cropModalTransformApply.onclick = function() {
        applyTransform();
      };
      
      // Transform cancel button click handler
      cropModalTransformCancel.onclick = function() {
        cancelTransform();
      };
      let isRotating = false;
      let rotationAnimationFrame = null;
      let isFlipping = false;
      let flipAnimationFrame = null;

      function animateRotation(targetAngle) {
        if (isRotating) return;
        isRotating = true;
        const startAngle = modalRotation;
        const endAngle = targetAngle;
        const duration = 300; // ms
        const startTime = performance.now();

        function step(now) {
          const elapsed = now - startTime;
          let t = Math.min(elapsed / duration, 1);
          // Ease-in-out
          t = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          const currentAngle = startAngle + (endAngle - startAngle) * t;
          modalRotation = currentAngle;
          drawModalCanvasWithTransforms();
          if (t < 1) {
            rotationAnimationFrame = requestAnimationFrame(step);
          } else {
            modalRotation = endAngle % 360;
            drawModalCanvasWithTransforms();
            isRotating = false;
            rotationAnimationFrame = null;
            updateImageTransform();
            if (cropMode) exitCropMode();
            cropModalBottomButtons.style.display = 'none';
          }
        }
        if (rotationAnimationFrame) cancelAnimationFrame(rotationAnimationFrame);
        rotationAnimationFrame = requestAnimationFrame(step);
      }

      function animateFlip(direction, targetFlip) {
        if (isFlipping) return;
        isFlipping = true;
        
        const startFlip = direction === 'horizontal' ? modalFlipH : modalFlipV;
        const endFlip = targetFlip;
        const duration = 300; // ms - quick and smooth
        const startTime = performance.now();

        function step(now) {
          const elapsed = now - startTime;
          let t = Math.min(elapsed / duration, 1);
          
          // Simple ease-in-out
          t = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          
          // Simple fade transition with slight scale
          if (t < 0.5) {
            // First half: fade out original
            const opacity = 1 - (t * 2);
            const scale = 1 - (t * 0.1); // Slight scale down
            cropModalCanvas.style.opacity = opacity;
            cropModalCanvas.style.transform = `scale(${scale})`;
            cropModalCanvas.classList.add('flipping');
          } else {
            // Second half: switch flip state and fade in
            const opacity = (t - 0.5) * 2;
            const scale = 0.9 + (t - 0.5) * 0.2; // Scale back up
            
            // Update flip state at the midpoint
            if (direction === 'horizontal') {
              modalFlipH = endFlip;
            } else {
              modalFlipV = endFlip;
            }
            
            drawModalCanvasWithTransforms();
            cropModalCanvas.style.opacity = opacity;
            cropModalCanvas.style.transform = `scale(${scale})`;
          }
          
          if (t < 1) {
            flipAnimationFrame = requestAnimationFrame(step);
          } else {
            // Reset and finalize
            cropModalCanvas.style.opacity = '';
            cropModalCanvas.style.transform = '';
            cropModalCanvas.classList.remove('flipping');
            isFlipping = false;
            flipAnimationFrame = null;
            
            // Exit crop mode if active
            if (cropMode) exitCropMode();
            cropModalBottomButtons.style.display = 'none';
          }
        }
        
        if (flipAnimationFrame) cancelAnimationFrame(flipAnimationFrame);
        flipAnimationFrame = requestAnimationFrame(step);
      }

      function drawModalCanvasAtAngle(angle) {
        if (!modalImageElement) return;
        const imgWidth = originalImageWidth;
        const imgHeight = originalImageHeight;
        const radians = (angle * Math.PI) / 180;
        // Calculate rotated bounding box
        const cos = Math.abs(Math.cos(radians));
        const sin = Math.abs(Math.sin(radians));
        const rotatedWidth = Math.round(imgWidth * cos + imgHeight * sin);
        const rotatedHeight = Math.round(imgWidth * sin + imgHeight * cos);
        // Fit rotated bounding box in modal, keeping aspect ratio
        const maxW = window.innerWidth * 0.9;
        const maxH = window.innerHeight * 0.9;
        let scale = Math.min(maxW / rotatedWidth, maxH / rotatedHeight, 1);
        // Set canvas and container to rotated bounding box size (not stretched)
        cropModalCanvas.width = rotatedWidth;
        cropModalCanvas.height = rotatedHeight;
        cropModalCanvas.style.width = (rotatedWidth * scale) + 'px';
        cropModalCanvas.style.height = (rotatedHeight * scale) + 'px';
        cropModalImgContainer.style.width = (rotatedWidth * scale) + 'px';
        cropModalImgContainer.style.height = (rotatedHeight * scale) + 'px';
        // Draw image centered and rotated
        const ctx = cropModalCanvas.getContext('2d');
        ctx.clearRect(0, 0, cropModalCanvas.width, cropModalCanvas.height);
        ctx.save();
        ctx.translate(rotatedWidth / 2, rotatedHeight / 2);
        ctx.rotate(radians);
        ctx.drawImage(modalImageElement, -imgWidth / 2, -imgHeight / 2);
        ctx.restore();
      }

      function drawModalCanvasWithTransforms() {
        if (!modalImageElement) return;
        const imgWidth = originalImageWidth;
        const imgHeight = originalImageHeight;
        const radians = (modalRotation * Math.PI) / 180;
        
        // Calculate rotated bounding box
        const cos = Math.abs(Math.cos(radians));
        const sin = Math.abs(Math.sin(radians));
        const rotatedWidth = Math.round(imgWidth * cos + imgHeight * sin);
        const rotatedHeight = Math.round(imgWidth * sin + imgHeight * cos);
        
        // Fit rotated bounding box in modal, keeping aspect ratio
        const maxW = window.innerWidth * 0.9;
        const maxH = window.innerHeight * 0.9;
        let scale = Math.min(maxW / rotatedWidth, maxH / rotatedHeight, 1);
        
        // Set canvas and container to rotated bounding box size (not stretched)
        cropModalCanvas.width = rotatedWidth;
        cropModalCanvas.height = rotatedHeight;
        cropModalCanvas.style.width = (rotatedWidth * scale) + 'px';
        cropModalCanvas.style.height = (rotatedHeight * scale) + 'px';
        cropModalImgContainer.style.width = (rotatedWidth * scale) + 'px';
        cropModalImgContainer.style.height = (rotatedHeight * scale) + 'px';
        
        // Draw image with all transforms
        const ctx = cropModalCanvas.getContext('2d');
        ctx.clearRect(0, 0, cropModalCanvas.width, cropModalCanvas.height);
        ctx.save();
        ctx.translate(rotatedWidth / 2, rotatedHeight / 2);
        ctx.rotate(radians);
        
        // Apply flips
        if (modalFlipH) {
          ctx.scale(-1, 1);
        }
        if (modalFlipV) {
          ctx.scale(1, -1);
        }
        
        ctx.drawImage(modalImageElement, -imgWidth / 2, -imgHeight / 2);
        ctx.restore();
      }

      cropModalRotate.onclick = function() {
        if (isRotating) return;
        const newAngle = (modalRotation + 90) % 360;
        animateRotation(newAngle);
        enterTransformMode();
      };
      
      cropModalFlipH.onclick = function() {
        if (isFlipping) return;
        const newFlipH = !modalFlipH;
        animateFlip('horizontal', newFlipH);
        enterTransformMode();
      };
      
      cropModalFlipV.onclick = function() {
        if (isFlipping) return;
        const newFlipV = !modalFlipV;
        animateFlip('vertical', newFlipV);
        enterTransformMode();
      };
      
      cropModalInfo.onclick = function() {
        showImageInfoPopup();
      };
      
      // Close info popup when clicking outside
      document.addEventListener('click', function(e) {
        const popup = imageInfoPopup;
        const infoButton = document.getElementById('crop-modal-info');
        
        // If popup is visible and click is not on popup or info button, close it
        if (popup.style.display === 'block' && 
            !popup.contains(e.target) && 
            !infoButton.contains(e.target)) {
          popup.style.display = 'none';
        }
      });
      cropModalCancel.onclick = closeCropModal;
      cropModalOverlay.onclick = function(e) { 
        // Only close if clicking the background AND not in crop mode
        // Also check if clicking on any crop handle anywhere on the screen
        const isClickingCropHandle = e.target.classList.contains('resize-handle') || 
                                   e.target.closest('#crop-modal-cropbox');
        if (e.target === cropModalOverlay && !isClickingCropHandle && !cropMode) {
          closeCropModal(); 
        }
      };
      document.onkeydown = function(e) { 
        // Only allow escape to close if not in crop mode
        if (e.key === 'Escape' && !cropMode) {
          closeCropModal(); 
        }
      };
      
      // Global click handler to prevent modal closing when clicking crop handles
      document.addEventListener('click', function(e) {
        if (cropMode) {
          const isClickingCropHandle = e.target.classList.contains('resize-handle') || 
                                     e.target.closest('#crop-modal-cropbox');
          if (isClickingCropHandle) {
            e.stopPropagation(); // Prevent modal from closing
          }
        }
      });
    
    function applyRotation() {
      // Store the image reference before any operations
      const currentOrigFabricImg = origFabricImg;
      const originalImgWidth = currentOrigFabricImg.width;
      const originalImgHeight = currentOrigFabricImg.height;
      const isHighRes = originalImgWidth * originalImgHeight > 10000000; // 10MP threshold
      const loadingText = document.getElementById('loading-text');
      
      // Determine which canvas we're working with
      const targetCanvas = (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex') ? deskPadModalCanvas : fabricCanvas;
      

      function actuallyApplyRotation() {


        const radians = (modalRotation * Math.PI) / 180;
        const cos = Math.abs(Math.cos(radians));
        const sin = Math.abs(Math.sin(radians));
        const rotatedWidth = Math.round(originalImgWidth * cos + originalImgHeight * sin);
        const rotatedHeight = Math.round(originalImgWidth * sin + originalImgHeight * cos);


        // Create temporary canvas for applying transforms
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = rotatedWidth;
        tempCanvas.height = rotatedHeight;
        tempCtx.save();
        tempCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
        tempCtx.rotate(radians);
        if (modalFlipH) tempCtx.scale(-1, 1);
        if (modalFlipV) tempCtx.scale(1, -1);
        
        // Use the stored image reference to ensure it's valid
        if (currentOrigFabricImg._element && currentOrigFabricImg._element.complete) {
          tempCtx.drawImage(currentOrigFabricImg._element, -originalImgWidth / 2, -originalImgHeight / 2);
          tempCtx.restore();
          
          targetCanvas.remove(currentOrigFabricImg);
          fabric.Image.fromURL(tempCanvas.toDataURL(), newImg => {
    
            const originalScaleX = currentOrigFabricImg.scaleX;
            const originalScaleY = currentOrigFabricImg.scaleY;
            const newImgWidth = newImg.width;
            const newImgHeight = newImg.height;
            const newScaleX = originalScaleX;
            const newScaleY = originalScaleY;

            newImg.set({
              left: currentOrigFabricImg.left,
              top: currentOrigFabricImg.top,
              originX: currentOrigFabricImg.originX,
              originY: currentOrigFabricImg.originY,
              scaleX: newScaleX,
              scaleY: newScaleY,
              angle: 0,
              flipX: false,
              flipY: false,
              selectable: true,
              hasControls: true,
              hasBorders: true,
              stroke: 'transparent',
              strokeWidth: 0
            });
            targetCanvas.add(newImg);
            targetCanvas.requestRenderAll();
            newImg._originalDataUrl = currentOrigFabricImg._originalDataUrl;
            
            // Update layer object reference
            updateLayerObjectReference(currentOrigFabricImg, newImg);
            
            // Update references immediately
            origFabricImg = newImg;
            // Don't update originalFabricImg - it should always remain the very first image
            
            // Pre-cache the new image for modal use
            const maxModalSize = 2000;
            const imgWidth = newImg.width;
            const imgHeight = newImg.height;
            const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
            const modalWidth = Math.round(imgWidth * scale);
            const modalHeight = Math.round(imgHeight * scale);
            
            // Create a temporary canvas for the modal version
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = modalWidth;
            tempCanvas.height = modalHeight;
            
            // Wait for the new image to be fully loaded before creating modal version
            if (newImg._element && newImg._element.complete) {
              tempCtx.drawImage(newImg._element, 0, 0, modalWidth, modalHeight);
              
              // Create and cache the modal image
              const cachedModalImg = new window.Image();
              cachedModalImg.onload = function() {
                newImg._cachedModalImage = cachedModalImg;
                newImg._modalScale = scale;
                
                // Update modal to show the new transformed image
                modalImageElement = cachedModalImg;
                originalImageWidth = modalImageElement.width;
                originalImageHeight = modalImageElement.height;
                modalRotation = 0;
                modalFlipH = false;
                modalFlipV = false;
                drawModalCanvasWithTransforms();
              };
              cachedModalImg.src = tempCanvas.toDataURL('image/jpeg', 0.9);
            } else {
              // If image not ready, wait for it
              newImg._element.onload = function() {
                tempCtx.drawImage(newImg._element, 0, 0, modalWidth, modalHeight);
                
                const cachedModalImg = new window.Image();
                cachedModalImg.onload = function() {
                  newImg._cachedModalImage = cachedModalImg;
                  newImg._modalScale = scale;
                  
                  modalImageElement = cachedModalImg;
                  originalImageWidth = modalImageElement.width;
                  originalImageHeight = modalImageElement.height;
                  modalRotation = 0;
                  modalFlipH = false;
                  modalFlipV = false;
                  drawModalCanvasWithTransforms();
                };
                cachedModalImg.src = tempCanvas.toDataURL('image/jpeg', 0.9);
              };
            }
            
            if (isHighRes) {
              setTimeout(() => {
                loadingOverlay.classList.remove('show');
              }, 500); // Minimum 500ms display time
            }
          });
        } else {
          console.error('Image element is not valid for rotation');
          if (isHighRes) {
                      setTimeout(() => {
            loadingOverlay.classList.remove('show');
          }, 500); // Minimum 500ms display time
            cropModalOverlay.style.display = 'flex';
          }
        }
      }

      if (isHighRes) {
        // Show semi-transparent loading overlay (keep modal visible)
        loadingOverlay.classList.add('show');
        loadingText.textContent = 'Applying transformations to high-resolution image...';
        
        // Allow browser to paint the spinner before heavy work
        requestAnimationFrame(() => {
          setTimeout(() => {
            actuallyApplyRotation();
          }, 0);
        });
      } else {
        actuallyApplyRotation();
      }
    }
    
    function closeCropModal() {
      cropModalOverlay.style.display = 'none';
      imageInfoPopup.style.display = 'none'; // Close info popup
      loadingOverlay.classList.remove('show'); // Also hide loading overlay
      modalRotation = 0;
      modalFlipH = false;
      modalFlipV = false;
      originalImageWidth = 0;
      originalImageHeight = 0;
      // Don't reset originalFabricImg - keep it for future crops
      cropModalCanvas.src = ''; // Clear canvas source
      cropModalCanvas.style.transform = ''; // Reset any transform effects
      document.onkeydown = null;
      
      // Cancel any ongoing animations
      if (rotationAnimationFrame) {
        cancelAnimationFrame(rotationAnimationFrame);
        rotationAnimationFrame = null;
      }
      if (flipAnimationFrame) {
        cancelAnimationFrame(flipAnimationFrame);
        flipAnimationFrame = null;
      }
      isRotating = false;
      isFlipping = false;
      
      // Reset container and image styles
      // cropModalImgContainer.style.width = ''; // This line is removed
      // cropModalImgContainer.style.height = ''; // This line is removed
      cropModalCanvas.style.transform = '';
      
      // Exit crop mode if active
      if (cropMode) {
        exitCropMode();
      }
      
      // Exit transform mode if active
      if (transformMode) {
        cancelTransform();
      }
      
      // Ensure bottom buttons are hidden
      cropModalBottomButtons.style.display = 'none';
      cropModalTransformButtons.style.display = 'none';
    }
    
    function showImageInfoPopup() {
      if (!origFabricImg) {
        console.error('No image available for info popup');
        return;
      }
      
      // Get original image dimensions from the very original image
      let originalWidth, originalHeight;
      if (originalFabricImg) {
        originalWidth = originalFabricImg.width;
        originalHeight = originalFabricImg.height;
      } else {
        // Fallback to current image if original not available
        originalWidth = origFabricImg.width;
        originalHeight = origFabricImg.height;
      }
      
      // Get current dimensions (after any transformations and scaling)
      const currentWidth = Math.round(origFabricImg.getScaledWidth());
      const currentHeight = Math.round(origFabricImg.getScaledHeight());
      
      // Calculate DPI at 300 DPI print size
      const printWidthInches = currentWidth / 300;
      const printHeightInches = currentHeight / 300;
      const printWidthCm = printWidthInches * 2.54;
      const printHeightCm = printHeightInches * 2.54;
      
      // Get file size from original data URL
      let fileSize = 'Unknown';
      let format = 'Unknown';
      if (origFabricImg._originalDataUrl) {
        const dataUrl = origFabricImg._originalDataUrl;
        const base64Length = dataUrl.length - dataUrl.indexOf(',') - 1;
        const fileSizeBytes = Math.ceil((base64Length * 3) / 4);
        
        if (fileSizeBytes < 1024) {
          fileSize = fileSizeBytes + ' bytes';
        } else if (fileSizeBytes < 1024 * 1024) {
          fileSize = (fileSizeBytes / 1024).toFixed(1) + ' KB';
        } else {
          fileSize = (fileSizeBytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        // Determine format from data URL
        if (dataUrl.includes('data:image/jpeg')) {
          format = 'JPEG';
        } else if (dataUrl.includes('data:image/png')) {
          format = 'PNG';
        } else if (dataUrl.includes('data:image/gif')) {
          format = 'GIF';
        } else if (dataUrl.includes('data:image/webp')) {
          format = 'WebP';
        } else {
          format = 'Unknown';
        }
      }
      
      // Get transformations
      const transformations = [];
      if (workingRotation !== 0) {
        transformations.push(`Rotated ${workingRotation}°`);
      }
      if (workingFlipH) {
        transformations.push('Flipped horizontally');
      }
      if (workingFlipV) {
        transformations.push('Flipped vertically');
      }
      
      const transformationsText = transformations.length > 0 ? transformations.join(', ') : 'None';
      
      // Update popup content
      document.getElementById('info-original-dimensions').textContent = `${originalWidth} × ${originalHeight} pixels`;
      document.getElementById('info-current-dimensions').textContent = `${currentWidth} × ${currentHeight} pixels`;
      document.getElementById('info-dpi').textContent = `${printWidthInches.toFixed(1)}" × ${printHeightInches.toFixed(1)}" (${printWidthCm.toFixed(1)} × ${printHeightCm.toFixed(1)} cm)`;
      document.getElementById('info-file-size').textContent = fileSize;
      document.getElementById('info-format').textContent = format;
      document.getElementById('info-transformations').textContent = transformationsText;
      
      // Position popup near the info button
      const infoButton = document.getElementById('crop-modal-info');
      const buttonRect = infoButton.getBoundingClientRect();
      const popup = imageInfoPopup;
      
      // Check if popup is already visible - if so, hide it
      if (popup.style.display === 'block') {
        popup.style.display = 'none';
        return;
      }
      
      // Position popup below the button, centered horizontally
      popup.style.left = (buttonRect.left - 120) + 'px'; // Center under button
      popup.style.top = (buttonRect.bottom + 10) + 'px';
      
      // Show popup
      popup.style.display = 'block';
    }
    
    // --- Crop Mode Functions ---
    
    function enterCropMode() {
      // Don't allow crop mode if we're in transform mode
      if (transformMode) {

        return;
      }
      
      
      cropMode = true;
      cropBoxAspect = null; // Always freeform aspect ratio
      
      // Capture the current modal state when crop button is clicked
      cropRotation = modalRotation;
      cropFlipH = modalFlipH;
      cropFlipV = modalFlipV;
      

      
      // Show the current working image in the modal for crop mode
      if (origFabricImg) {
        // Use the working orientation (which persists between modal sessions)

        
        // Set modal transforms to match working orientation
        modalRotation = workingRotation;
        modalFlipH = workingFlipH;
        modalFlipV = workingFlipV;
        
        // Use the cached lower resolution image for crop mode
        if (origFabricImg._cachedModalImage && origFabricImg._cachedModalImage.complete) {

          modalImageElement = origFabricImg._cachedModalImage;
          originalImageWidth = modalImageElement.width;
          originalImageHeight = modalImageElement.height;
          
                      // Show the image with its current orientation
            drawModalCanvasWithTransforms();
            
            // Use a small delay to ensure the modal canvas is rendered before calculating crop box size
            setTimeout(() => {
              // Set crop box to 60% of displayed image, centered
              const containerRect = cropModalImgContainer.getBoundingClientRect();
              const imgDisplayWidth = containerRect.width;
              const imgDisplayHeight = containerRect.height;
              let cropBoxWidth = imgDisplayWidth * 0.6;
              let cropBoxHeight = imgDisplayHeight * 0.6;
              

              
              // If crop box is zero or too small, set to a default minimum
              if (!imgDisplayWidth || !imgDisplayHeight || cropBoxWidth < 10 || cropBoxHeight < 10) {
                cropBoxWidth = Math.max(100, imgDisplayWidth || 400);
                cropBoxHeight = Math.max(100, imgDisplayHeight || 300);

              }
              
              // Ensure crop box stays within bounds with handle padding and toolbar gaps
              const handlePadding = 7;
              const toolbarGap = 32 + handlePadding; // Toolbar height + handle padding
              const maxLeft = imgDisplayWidth - cropBoxWidth - handlePadding;
              const maxTop = imgDisplayHeight - cropBoxHeight - toolbarGap;
              const cropBoxLeft = Math.max(handlePadding, Math.min(maxLeft, (imgDisplayWidth - cropBoxWidth) / 2));
              const cropBoxTop = Math.max(toolbarGap, Math.min(maxTop, (imgDisplayHeight - cropBoxHeight) / 2));
              cropModalCropbox.style.left = cropBoxLeft + 'px';
              cropModalCropbox.style.top = cropBoxTop + 'px';
              cropModalCropbox.style.width = cropBoxWidth + 'px';
              cropModalCropbox.style.height = cropBoxHeight + 'px';
              cropModalCropbox.style.transform = 'none';
              

            }, 10);
        } else {

          // Create a lower resolution version for crop mode
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          
          // Calculate optimal modal size (max 2000px on longest side for performance)
          const maxModalSize = 2000;
          const imgWidth = origFabricImg.width;
          const imgHeight = origFabricImg.height;
          const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
          
          const modalWidth = Math.round(imgWidth * scale);
          const modalHeight = Math.round(imgHeight * scale);
          

          
          // Set canvas size to modal size
          tempCanvas.width = modalWidth;
          tempCanvas.height = modalHeight;
          
          // Draw the resized image
          tempCtx.drawImage(origFabricImg._element, 0, 0, modalWidth, modalHeight);
          
          // Create image from the resized canvas
          modalImageElement = new window.Image();
          modalImageElement.onload = function() {
  
            // Cache this lower resolution image for future use
            origFabricImg._cachedModalImage = modalImageElement;
            origFabricImg._modalScale = scale; // Store the scale factor for later use
            
            originalImageWidth = modalImageElement.width;
            originalImageHeight = modalImageElement.height;
            
            // Show the image with its current orientation
            drawModalCanvasWithTransforms();
            
            // Use a small delay to ensure the modal canvas is rendered before calculating crop box size
            setTimeout(() => {
              // Set crop box to 60% of displayed image, centered
              const containerRect = cropModalImgContainer.getBoundingClientRect();
              const imgDisplayWidth = containerRect.width;
              const imgDisplayHeight = containerRect.height;
              cropBoxWidth = imgDisplayWidth * 0.6;
              cropBoxHeight = imgDisplayHeight * 0.6;
              

              
              // If crop box is zero or too small, set to a default minimum
              if (!imgDisplayWidth || !imgDisplayHeight || cropBoxWidth < 10 || cropBoxHeight < 10) {
                cropBoxWidth = Math.max(100, imgDisplayWidth || 400);
                cropBoxHeight = Math.max(100, imgDisplayHeight || 300);

              }
              
              // Ensure crop box stays within bounds with handle padding and toolbar gaps
              const handlePadding = 7;
              const toolbarGap = 32 + handlePadding; // Toolbar height + handle padding
              const maxLeft = imgDisplayWidth - cropBoxWidth - handlePadding;
              const maxTop = imgDisplayHeight - cropBoxHeight - toolbarGap;
              const cropBoxLeft = Math.max(handlePadding, Math.min(maxLeft, (imgDisplayWidth - cropBoxWidth) / 2));
              const cropBoxTop = Math.max(toolbarGap, Math.min(maxTop, (imgDisplayHeight - cropBoxHeight) / 2));
              cropModalCropbox.style.left = cropBoxLeft + 'px';
              cropModalCropbox.style.top = cropBoxTop + 'px';
              cropModalCropbox.style.width = cropBoxWidth + 'px';
              cropModalCropbox.style.height = cropBoxHeight + 'px';
              cropModalCropbox.style.transform = 'none';
              

            }, 10);
          };
          modalImageElement.src = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size
        }
      }

      // Hide top toolbar buttons
      cropModalRotate.style.display = 'none';
      cropModalFlipH.style.display = 'none';
      cropModalFlipV.style.display = 'none';
      cropModalCrop.style.display = 'none';
      cropModalApply.style.display = 'none';
      cropModalCancel.style.display = 'none';
      
      // Show crop box and position it properly (if not restored above)
      cropModalCropbox.style.display = 'block';
      cropModalCropbox.style.pointerEvents = 'auto';
      
      // Show bottom buttons
      cropModalBottomButtons.style.display = 'flex';
      
      // Make crop box draggable and resizable
      makeCropBoxInteractive();
      
      // Ensure crop box is properly initialized after a short delay
      setTimeout(() => {
        const cropRect = cropModalCropbox.getBoundingClientRect();
        if (cropRect.width === 0 || cropRect.height === 0) {

          
          const containerRect = cropModalImgContainer.getBoundingClientRect();
          const imgDisplayWidth = containerRect.width;
          const imgDisplayHeight = containerRect.height;
          let cropBoxWidth = Math.max(100, imgDisplayWidth * 0.6);
          let cropBoxHeight = Math.max(100, imgDisplayHeight * 0.6);
          
          if (!imgDisplayWidth || !imgDisplayHeight) {
            cropBoxWidth = 400;
            cropBoxHeight = 300;
          }
          
          const cropBoxLeft = (imgDisplayWidth - cropBoxWidth) / 2;
          const cropBoxTop = (imgDisplayHeight - cropBoxHeight) / 2;
          
          cropModalCropbox.style.left = cropBoxLeft + 'px';
          cropModalCropbox.style.top = cropBoxTop + 'px';
          cropModalCropbox.style.width = cropBoxWidth + 'px';
          cropModalCropbox.style.height = cropBoxHeight + 'px';
          cropModalCropbox.style.display = 'block';
          cropModalCropbox.style.transform = 'none';
          

        }
      }, 100);
    }
    
    function enterTransformMode() {
      
      transformMode = true;
      
      // Hide most top toolbar buttons, but keep rotate/flip buttons visible
      cropModalCrop.style.display = 'none';
      cropModalApply.style.display = 'none';
      cropModalCancel.style.display = 'none';
      
      // Keep rotate and flip buttons visible so user can continue transforming
      cropModalRotate.style.display = 'inline-flex';
      cropModalFlipH.style.display = 'inline-flex';
      cropModalFlipV.style.display = 'inline-flex';
      
      // Show transform buttons
      cropModalTransformButtons.style.display = 'flex';
    }
    
    function applyTransform() {
      
      transformMode = false;
      
      // Apply the current modal transforms to the canvas image
      applyRotation();
      
      // Show all top toolbar buttons
      cropModalRotate.style.display = 'inline-flex';
      cropModalFlipH.style.display = 'inline-flex';
      cropModalFlipV.style.display = 'inline-flex';
      cropModalCrop.style.display = 'inline-flex';
      cropModalApply.style.display = 'inline-block';
      cropModalCancel.style.display = 'inline-block';
      
      // Hide transform buttons
      cropModalTransformButtons.style.display = 'none';
    }
    
    function cancelTransform() {
      
      transformMode = false;
      
      // Revert to the original image orientation
      if (origFabricImg) {
        modalRotation = origFabricImg.angle || 0;
        modalFlipH = origFabricImg.flipX || false;
        modalFlipV = origFabricImg.flipY || false;
        drawModalCanvasWithTransforms();
      }
      
      // Show top toolbar buttons
      cropModalRotate.style.display = 'inline-flex';
      cropModalFlipH.style.display = 'inline-flex';
      cropModalFlipV.style.display = 'inline-flex';
      cropModalCrop.style.display = 'inline-flex';
      cropModalApply.style.display = 'inline-block';
      cropModalCancel.style.display = 'inline-block';
      
      // Hide transform buttons
      cropModalTransformButtons.style.display = 'none';
    }
    
    function exitCropMode() {
      
      cropMode = false;
      
      // Show the current image in the modal (with any applied transforms)
      if (origFabricImg) {
        // Use the cached lower resolution image
        if (origFabricImg._cachedModalImage && origFabricImg._cachedModalImage.complete) {
  
          modalImageElement = origFabricImg._cachedModalImage;
          originalImageWidth = modalImageElement.width;
          originalImageHeight = modalImageElement.height;
          
          // Reset to current image's orientation (not upright)
          modalRotation = origFabricImg.angle || 0;
          modalFlipH = origFabricImg.flipX || false;
          modalFlipV = origFabricImg.flipY || false;
          
          drawModalCanvasWithTransforms();
        } else {
  
          // Create a lower resolution version
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          
          // Calculate optimal modal size (max 2000px on longest side for performance)
          const maxModalSize = 2000;
          const imgWidth = origFabricImg.width;
          const imgHeight = origFabricImg.height;
          const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
          
          const modalWidth = Math.round(imgWidth * scale);
          const modalHeight = Math.round(imgHeight * scale);
          
          // Set canvas size to modal size
          tempCanvas.width = modalWidth;
          tempCanvas.height = modalHeight;
          
          // Draw the resized image
          tempCtx.drawImage(origFabricImg._element, 0, 0, modalWidth, modalHeight);
          
          // Create image from the resized canvas
          modalImageElement = new window.Image();
          modalImageElement.onload = function() {
    
            // Cache this lower resolution image for future use
            origFabricImg._cachedModalImage = modalImageElement;
            origFabricImg._modalScale = scale; // Store the scale factor for later use
            
            originalImageWidth = modalImageElement.width;
            originalImageHeight = modalImageElement.height;
            
            // Reset to current image's orientation (not upright)
            modalRotation = origFabricImg.angle || 0;
            modalFlipH = origFabricImg.flipX || false;
            modalFlipV = origFabricImg.flipY || false;
            
            drawModalCanvasWithTransforms();
          };
          modalImageElement.src = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size
        }
      }

      // Show top toolbar buttons
      cropModalRotate.style.display = 'inline-flex';
      cropModalFlipH.style.display = 'inline-flex';
      cropModalFlipV.style.display = 'inline-flex';
      cropModalCrop.style.display = 'inline-flex';
      cropModalApply.style.display = 'inline-block';
      cropModalCancel.style.display = 'inline-block';
      
      // Hide crop box
      cropModalCropbox.style.display = 'none';
      cropModalCropbox.style.pointerEvents = 'none';
      
      // Hide bottom buttons
      cropModalBottomButtons.style.display = 'none';
      
      // Remove crop box event listeners
      removeCropBoxListeners();
    }
    
    function makeCropBoxInteractive() {
      // Add resize handles to crop box
      addResizeHandles();
      // Attach event listeners to handles
      addResizeHandlers();
      // Make crop box draggable
      makeCropBoxDraggable();
    }
    
    function addResizeHandles() {
      // Remove existing handles first
      const existingHandles = cropModalCropbox.querySelectorAll('.resize-handle');
      existingHandles.forEach(handle => handle.remove());
      
      // Add resize handles
      const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'];
      handles.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        handle.style.cssText = `
          position: absolute;
          width: 12px;
          height: 12px;
          background: #ffe066;
          border: 2px solid #fff;
          border-radius: 50%;
          z-index: 102;
          box-sizing: border-box;
        `;
        
        // Position handles
        switch(pos) {
          case 'nw': handle.style.top = '-7px'; handle.style.left = '-7px'; handle.style.cursor = 'nwse-resize'; break;
          case 'ne': handle.style.top = '-7px'; handle.style.right = '-7px'; handle.style.cursor = 'nesw-resize'; break;
          case 'sw': handle.style.bottom = '-7px'; handle.style.left = '-7px'; handle.style.cursor = 'nesw-resize'; break;
          case 'se': handle.style.bottom = '-7px'; handle.style.right = '-7px'; handle.style.cursor = 'nwse-resize'; break;
          case 'n': handle.style.top = '-7px'; handle.style.left = '50%'; handle.style.transform = 'translateX(-50%)'; handle.style.cursor = 'ns-resize'; break;
          case 's': handle.style.bottom = '-7px'; handle.style.left = '50%'; handle.style.transform = 'translateX(-50%)'; handle.style.cursor = 'ns-resize'; break;
          case 'e': handle.style.right = '-7px'; handle.style.top = '50%'; handle.style.transform = 'translateY(-50%)'; handle.style.cursor = 'ew-resize'; break;
          case 'w': handle.style.left = '-7px'; handle.style.top = '50%'; handle.style.transform = 'translateY(-50%)'; handle.style.cursor = 'ew-resize'; break;
        }
        
        cropModalCropbox.appendChild(handle);
      });
    }
    
    function makeCropBoxDraggable() {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      cropModalCropbox.addEventListener('mousedown', function(e) {
        if (e.target.classList.contains('resize-handle')) return;
        isDragging = true;
        const containerRect = cropModalCanvas.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        const rect = cropModalCropbox.getBoundingClientRect();
        startLeft = rect.left - containerRect.left;
        startTop = rect.top - containerRect.top;
        document.body.style.cursor = 'move';
        e.preventDefault();
        
        // Prevent text selection during drag
        document.body.style.userSelect = 'none';
        document.body.style.webkitUserSelect = 'none';
        document.body.style.mozUserSelect = 'none';
        document.body.style.msUserSelect = 'none';

        function onDragMove(e) {
          if (!isDragging) return;
          const containerRect = cropModalCanvas.getBoundingClientRect();
          const mouseX = e.clientX - containerRect.left;
          const mouseY = e.clientY - containerRect.top;
          let newLeft = startLeft + (mouseX - (startX - containerRect.left));
          let newTop = startTop + (mouseY - (startY - containerRect.top));
          
          // Constrain to image boundaries (canvas dimensions)
          newLeft = Math.max(0, Math.min(newLeft, cropModalCanvas.offsetWidth - cropModalCropbox.offsetWidth));
          newTop = Math.max(0, Math.min(newTop, cropModalCanvas.offsetHeight - cropModalCropbox.offsetHeight));
          
          cropModalCropbox.style.left = newLeft + 'px';
          cropModalCropbox.style.top = newTop + 'px';
          cropModalCropbox.style.transform = 'none';
        }

        function onDragUp() {
          if (isDragging) {
            isDragging = false;
            document.body.style.cursor = '';
            
            // Restore text selection
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';
            document.body.style.mozUserSelect = '';
            document.body.style.msUserSelect = '';
            
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragUp);
          }
        }

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragUp);
      });
    }
    
    function addResizeHandlers() {
      const handles = cropModalCropbox.querySelectorAll('.resize-handle');
      
      handles.forEach(handle => {
        handle.addEventListener('mousedown', function(e) {
          
          e.stopPropagation();
          const direction = handle.className.split(' ')[1]; // Get direction (nw, ne, etc.)
          
          startCropResize(e, direction);
        });
      });
    }
    
    function startCropResize(e, direction) {
      
      let isResizing = true;
      let startX = e.clientX;
      let startY = e.clientY;
      const containerRect = cropModalCanvas.getBoundingClientRect();
      const rect = cropModalCropbox.getBoundingClientRect();
      const imgDisplayWidth = cropModalCanvas.offsetWidth;
      const imgDisplayHeight = cropModalCanvas.offsetHeight;
      let startLeft = rect.left - containerRect.left;
      let startTop = rect.top - containerRect.top;
      let startWidth = rect.width;
      let startHeight = rect.height;
      
      // Check if Alt key is held for center-based resizing
      let resizeFromCenter = e.altKey;
      

      
      // Prevent text selection during resize
      document.body.style.userSelect = 'none';
      document.body.style.webkitUserSelect = 'none';
      document.body.style.mozUserSelect = 'none';
      document.body.style.msUserSelect = 'none';

      function onResizeMove(e) {
        if (!isResizing) return;

        const containerRect = cropModalCanvas.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const mouseY = e.clientY - containerRect.top;
        let newLeft = startLeft;
        let newTop = startTop;
        let newWidth = startWidth;
        let newHeight = startHeight;
        
        // Update resize from center based on current Alt key state
        resizeFromCenter = e.altKey;
        
        // Apply resize based on direction
        if (direction.includes('e')) {
          if (resizeFromCenter) {
            // Center-based resize: expand/contract from center
            const deltaX = mouseX - (startX - containerRect.left);
            const halfDelta = deltaX / 2;
            newLeft = startLeft - halfDelta;
            newWidth = Math.max(50, startWidth + deltaX);
          } else {
            // Normal resize: expand from right edge
            newWidth = Math.max(50, startWidth + (mouseX - (startX - containerRect.left)));
          }
        }
        if (direction.includes('w')) {
          if (resizeFromCenter) {
            // Center-based resize: expand/contract from center
            const deltaX = mouseX - (startX - containerRect.left);
            const halfDelta = deltaX / 2;
            newLeft = startLeft + halfDelta;
            newWidth = Math.max(50, startWidth - deltaX);
          } else {
            // Normal resize: contract from left edge
            const maxDelta = startWidth - 50;
            const delta = Math.min(mouseX - (startX - containerRect.left), maxDelta);
            newLeft = startLeft + delta;
            newWidth = startWidth - delta;
          }
        }
        if (direction.includes('s')) {
          if (resizeFromCenter) {
            // Center-based resize: expand/contract from center
            const deltaY = mouseY - (startY - containerRect.top);
            const halfDelta = deltaY / 2;
            newTop = startTop - halfDelta;
            newHeight = Math.max(50, startHeight + deltaY);
          } else {
            // Normal resize: expand from bottom edge
            newHeight = Math.max(50, startHeight + (mouseY - (startY - containerRect.top)));
          }
        }
        if (direction.includes('n')) {
          if (resizeFromCenter) {
            // Center-based resize: expand/contract from center
            const deltaY = mouseY - (startY - containerRect.top);
            const halfDelta = deltaY / 2;
            newTop = startTop + halfDelta;
            newHeight = Math.max(50, startHeight - deltaY);
          } else {
            // Normal resize: contract from top edge
            const maxDelta = startHeight - 50;
            const delta = Math.min(mouseY - (startY - containerRect.top), maxDelta);
            newTop = startTop + delta;
            newHeight = startHeight - delta;
          }
        }
        // Constrain to image boundaries with smooth edge clamping
        const handlePadding = 7; // Half the handle size (12px / 2)
        
        if (resizeFromCenter) {
          // For center-based resizing, ensure the entire box stays within boundaries
          if (newLeft < 0) {
            newWidth += newLeft; // Reduce width by the amount we went outside
            newLeft = 0;
          }
          if (newTop < 0) {
            newHeight += newTop; // Reduce height by the amount we went outside
            newTop = 0;
          }
          if (newLeft + newWidth > imgDisplayWidth) {
            newWidth = imgDisplayWidth - newLeft;
          }
          if (newTop + newHeight > imgDisplayHeight) {
            newHeight = imgDisplayHeight - newTop;
          }
        } else {
          // Only clamp the edge being dragged, not the entire box
          if (direction.includes('w')) {
            // Dragging left edge - clamp to image left boundary
            newLeft = Math.max(0, newLeft);
            // Ensure right edge doesn't go beyond image boundary
            if (newLeft + newWidth > imgDisplayWidth) {
              newWidth = imgDisplayWidth - newLeft;
            }
          }
          if (direction.includes('e')) {
            // Dragging right edge - clamp to image right boundary
            if (newLeft + newWidth > imgDisplayWidth) {
              newWidth = imgDisplayWidth - newLeft;
            }
          }
          if (direction.includes('n')) {
            // Dragging top edge - clamp to image top boundary
            newTop = Math.max(0, newTop);
            // Ensure bottom edge doesn't go beyond image boundary
            if (newTop + newHeight > imgDisplayHeight) {
              newHeight = imgDisplayHeight - newTop;
            }
          }
          if (direction.includes('s')) {
            // Dragging bottom edge - clamp to image bottom boundary
            if (newTop + newHeight > imgDisplayHeight) {
              newHeight = imgDisplayHeight - newTop;
            }
          }
        }
        // Enforce minimum size
        newWidth = Math.max(50, newWidth);
        newHeight = Math.max(50, newHeight);
        cropModalCropbox.style.left = newLeft + 'px';
        cropModalCropbox.style.top = newTop + 'px';
        cropModalCropbox.style.width = newWidth + 'px';
        cropModalCropbox.style.height = newHeight + 'px';
        cropModalCropbox.style.transform = 'none';
      }

      function onResizeUp() {
        if (isResizing) {
          isResizing = false;
          
          // Restore text selection
          document.body.style.userSelect = '';
          document.body.style.webkitUserSelect = '';
          document.body.style.mozUserSelect = '';
          document.body.style.msUserSelect = '';
          
          document.removeEventListener('mousemove', onResizeMove);
          document.removeEventListener('mouseup', onResizeUp);
        }
      }

      document.addEventListener('mousemove', onResizeMove);
      document.addEventListener('mouseup', onResizeUp);
    }
    
    function removeCropBoxListeners() {
      // Remove all resize handles
      const cropBox = document.getElementById('crop-modal-cropbox');
      if (cropBox) {
        const handles = cropBox.querySelectorAll('.resize-handle');
        handles.forEach(handle => handle.remove());
      }
    }
    
    function revertToOriginal() {
      if (!origFabricImg || !origFabricImg._originalDataUrl) return;
      
      
      
      // Load the very original image for this specific image
              fabric.Image.fromURL(origFabricImg._originalDataUrl, newImg => {
  
          // Place at same center as current image
          newImg.set({
          left: origFabricImg.left,
          top: origFabricImg.top,
          originX: origFabricImg.originX,
          originY: origFabricImg.originY,
          scaleX: origFabricImg.scaleX,
          scaleY: origFabricImg.scaleY,
          angle: 0, // Reset to upright
          flipX: false, // Reset flips
          flipY: false,
          selectable: true,
          hasControls: true,
          hasBorders: true,
          stroke: 'transparent',
          strokeWidth: 0
        });
        
        // Replace the current image
        fabricCanvas.remove(origFabricImg);
        fabricCanvas.add(newImg);
        fabricCanvas.requestRenderAll();
        
        // Copy the original data URL to the new image (it's the same as the original)
        newImg._originalDataUrl = origFabricImg._originalDataUrl;
        
        // Update references
        origFabricImg = newImg;
        // Don't update originalFabricImg - it should always remain the very first image
        
        // Reset working orientation to upright
        workingRotation = 0;
        workingFlipH = false;
        workingFlipV = false;
        
        // Update modal to show the reverted image
        modalImageElement = new window.Image();
        modalImageElement.onload = function() {
          originalImageWidth = modalImageElement.width;
          originalImageHeight = modalImageElement.height;
          
          // Reset modal transforms to upright
          modalRotation = 0;
          modalFlipH = false;
          modalFlipV = false;
          
          drawModalCanvasWithTransforms();
        };
        modalImageElement.src = origFabricImg._originalDataUrl;
      });
    }
    
        function applyCrop() {
      if (!origFabricImg) return;
      
      const imgWidth = origFabricImg.width;
      const imgHeight = origFabricImg.height;
      const isHighRes = imgWidth * imgHeight > 10000000; // 10MP threshold
      const loadingText = document.getElementById('loading-text');

      // 1) Read the crop box + canvas size while they're still in the DOM
      const containerRect = cropModalImgContainer.getBoundingClientRect();
      const canvasRect = cropModalCanvas.getBoundingClientRect();
      const cropRect = cropModalCropbox.getBoundingClientRect();
      


      // 2) Show semi-transparent loading overlay (keep modal visible)
      loadingOverlay.classList.add('show');
      
      if (isHighRes) {
        loadingText.textContent = 'Cropping high-resolution image...';
      } else {
        loadingText.textContent = 'Cropping image...';
      }

      // 3) Allow browser to paint the spinner before heavy work
      requestAnimationFrame(() => {
        // Even another rAF can help ensure paint
        requestAnimationFrame(() => {
          actuallyApplyCrop(containerRect, canvasRect, cropRect)
            .catch(err => {
              console.error('Crop failed:', err);
              alert('Crop failed: ' + err.message);
            })
            .finally(() => {
              // 4) Hide spinner only (leave modal visible) - with minimum display time
              setTimeout(() => {
                loadingOverlay.classList.remove('show');
              }, 500); // Minimum 500ms display time
            });
        });
      });
    }

    function actuallyApplyCrop(containerRect, canvasRect, cropRect) {
      // Check if crop box is valid using the pre-computed rects
      const cropWidth = cropRect.width;
      const cropHeight = cropRect.height;
      

      
      if (cropWidth === 0 || cropHeight === 0) {
        throw new Error('Crop area is zero-sized. Please resize the crop box before applying.');
      }

      // Calculate crop coordinates for the high-resolution original image
      // The modal canvas shows a scaled version, so we need to convert back to original coordinates
      const modalScale = origFabricImg._modalScale || 1;
      const originalImgWidth = origFabricImg.width;
      const originalImgHeight = origFabricImg.height;
      
      // Calculate the scale from modal canvas to original image
      const modalToOriginalScaleX = originalImgWidth / cropModalCanvas.width;
      const modalToOriginalScaleY = originalImgHeight / cropModalCanvas.height;
      
      // Convert crop coordinates from modal canvas to original image
      const scaleX = cropModalCanvas.width / canvasRect.width;
      const scaleY = cropModalCanvas.height / canvasRect.height;
      const modalSx = (cropRect.left - canvasRect.left) * scaleX;
      const modalSy = (cropRect.top - canvasRect.top) * scaleY;
      const modalSw = cropRect.width * scaleX;
      const modalSh = cropRect.height * scaleY;
      
      // Convert to original image coordinates
      const originalSx = modalSx * modalToOriginalScaleX;
      const originalSy = modalSy * modalToOriginalScaleY;
      const originalSw = modalSw * modalToOriginalScaleX;
      const originalSh = modalSh * modalToOriginalScaleY;



      // Create a temporary canvas for the high-resolution crop
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = originalSw;
      tempCanvas.height = originalSh;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Draw from the high-resolution original image
      if (origFabricImg._element && origFabricImg._element.complete) {
        tempCtx.drawImage(origFabricImg._element, originalSx, originalSy, originalSw, originalSh, 0, 0, originalSw, originalSh);
      } else {
        throw new Error('Original image element is not ready for cropping');
      }

      // Convert to Fabric.Image
      return new Promise((resolve, reject) => {
        fabric.Image.fromURL(tempCanvas.toDataURL(), newImg => {
  
          try {
            // Preserve original transform, then replace
            newImg.set({
              left: origFabricImg.left,
              top: origFabricImg.top,
              originX: origFabricImg.originX,
              originY: origFabricImg.originY,
              scaleX: origFabricImg.scaleX,
              scaleY: origFabricImg.scaleY,
              angle: origFabricImg.angle || 0, // Preserve current rotation
              flipX: origFabricImg.flipX || false, // Preserve current flip states
              flipY: origFabricImg.flipY || false,
              selectable: true,
              hasControls: true,
              hasBorders: true,
              stroke: 'transparent',
              strokeWidth: 0
            });

            // Copy original data URL
            newImg._originalDataUrl = origFabricImg._originalDataUrl;

            // Determine which canvas we're working with
            const targetCanvas = (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex') ? deskPadModalCanvas : fabricCanvas;
    
            
            // Replace the image
            targetCanvas.remove(origFabricImg);
            targetCanvas.add(newImg);
            targetCanvas.requestRenderAll();

            // Update layer object reference
            updateLayerObjectReference(origFabricImg, newImg);

            // Update references
            origFabricImg = newImg;
            // Don't update originalFabricImg - it should always remain the very first image
            

            // Reset working transforms since the cropped image is now in natural orientation
            workingRotation = 0;
            workingFlipH = false;
            workingFlipV = false;


            // Pre-cache the new image for modal use
            const maxModalSize = 2000;
            const imgWidth = newImg.width;
            const imgHeight = newImg.height;
            const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
            const modalWidth = Math.round(imgWidth * scale);
            const modalHeight = Math.round(imgHeight * scale);

            // Create a temporary canvas for the modal version
            const modalCanvas = document.createElement('canvas');
            const modalCtx = modalCanvas.getContext('2d');
            modalCanvas.width = modalWidth;
            modalCanvas.height = modalHeight;

            // Wait for the new image to be fully loaded before creating modal version
            if (newImg._element && newImg._element.complete) {
              modalCtx.drawImage(newImg._element, 0, 0, modalWidth, modalHeight);
              
              // Create and cache the modal image
              const cachedModalImg = new window.Image();
              cachedModalImg.onload = function() {
                newImg._cachedModalImage = cachedModalImg;
                newImg._modalScale = scale;
                
                // Update modal to show the new cropped image
                modalImageElement = cachedModalImg;
                originalImageWidth = modalImageElement.width;
                originalImageHeight = modalImageElement.height;
                
                exitCropMode();
                modalRotation = 0;
                modalFlipH = false;
                modalFlipV = false;
                drawModalCanvasWithTransforms();
                
                resolve();
              };
              cachedModalImg.src = modalCanvas.toDataURL('image/jpeg', 0.9);
            } else {
              // If image not ready, wait for it
              newImg._element.onload = function() {
                modalCtx.drawImage(newImg._element, 0, 0, modalWidth, modalHeight);
                
                const cachedModalImg = new window.Image();
                cachedModalImg.onload = function() {
                  newImg._cachedModalImage = cachedModalImg;
                  newImg._modalScale = scale;
                  
                  modalImageElement = cachedModalImg;
                  originalImageWidth = modalImageElement.width;
                  originalImageHeight = modalImageElement.height;
                  
                  exitCropMode();
                  modalRotation = 0;
                  modalFlipH = false;
                  modalFlipV = false;
                  drawModalCanvasWithTransforms();
                  
                  resolve();
                };
                cachedModalImg.src = modalCanvas.toDataURL('image/jpeg', 0.9);
              };
            }
          } catch (error) {
            reject(error);
          }
        }, { crossOrigin: 'anonymous' });
      });
    }

    // Double-click to open modal cropper
    if (fabricCanvas) {
      fabricCanvas.on('mouse:dblclick', function(opt) {
        const target = opt.target;
        if (target && target.type === 'image') {
                  // Check image size before showing loading overlay
        const isHighRes = target.width * target.height > 10000000; // 10MP threshold
        
        // Show loading overlay immediately with appropriate message
        loadingOverlay.classList.add('show');
        const loadingText = document.getElementById('loading-text');
        
        if (isHighRes) {
          loadingText.textContent = 'High-resolution image detected - this may take a moment...';
        } else {
          loadingText.textContent = 'Preparing image editor...';
        }
          
          // Use requestAnimationFrame to ensure UI is responsive, then get data URL
          requestAnimationFrame(() => {
            // Use a worker or setTimeout to make toDataURL truly non-blocking
            setTimeout(() => {
              const imgUrl = target.toDataURL();
              openCropModal(imgUrl, target);
            }, 50); // Small delay to ensure UI responsiveness
          });
        }
      });
    }



    function addImageToFabric(url, index = 0) {
      if (!fabricCanvas) {
        console.error('Fabric canvas is not available');
        return;
      }
      
      fabric.Image.fromURL(url, img => {
        
        
        // Auto-detect optimal canvas size on first upload
        if (!autoDetectionPerformed) {
          const optimalSize = calculateOptimalCanvasSize(img.width, img.height);
          targetCanvasWidth = optimalSize.width;
          targetCanvasHeight = optimalSize.height;
          resizeCanvas(optimalSize.width, optimalSize.height);
          
          targetDpiDisplay.innerHTML = `
            <strong>Canvas Auto-Adjusted:</strong><br>
            New size: ${optimalSize.width} — ${optimalSize.height}px<br>
            Dynamic sizing based on image<br>
            Aspect ratio: 77:29 maintained
          `;
          
          autoDetectionPerformed = true;
          
          // Wait for canvas resize to complete, then add image
          setTimeout(() => {
            addImageToCanvas(img, index);
          }, 200);
          return;
        }
        
        // If not first image, add directly
        addImageToCanvas(img, index);
      }, { crossOrigin: 'anonymous' });
    }

    function addImageToCanvas(img, index = 0) {
      // Use target canvas dimensions (the actual canvas size we want)
      const canvasW = targetCanvasWidth;
      const canvasH = targetCanvasHeight;
      const scale = Math.min(
        canvasW / img.width,
        canvasH / img.height,
        1  // Don't scale up - only scale down to fit
      );
      
      // Calculate position for multiple images (center within artboard area)
      const extendedCanvasWidth = fabricCanvas.getWidth();
      const extendedCanvasHeight = fabricCanvas.getHeight();
      const artboardLeft = (extendedCanvasWidth - artboardWidth) / 2;
      const artboardTop = (extendedCanvasHeight - artboardHeight) / 2;
      
      let left, top;
      if (index === 0) {
        // First image goes to center of artboard
        left = artboardLeft + (artboardWidth / 2);
        top = artboardTop + (artboardHeight / 2);
      } else {
        // Subsequent images get offset positions within artboard
        const offset = 50; // pixels between images
        const imagesPerRow = 3; // max images per row
        const row = Math.floor(index / imagesPerRow);
        const col = index % imagesPerRow;
        
        left = artboardLeft + (artboardWidth / 4) + (col * offset);
        top = artboardTop + (artboardHeight / 4) + (row * offset);
      }
      
      img.set({
        left: left,
        top: top,
        originX: 'center',
        originY: 'center',
        scaleX: scale,
        scaleY: scale,
        selectable: true,
        hasControls: true,
        hasBorders: true,
        stroke: 'transparent',
        strokeWidth: 0
      });
      

      
      // Update DPI display (use current canvas dimensions)
      updateDPIDisplay(img.width, img.height, canvasW, canvasH, scale);
      
      // Only clear canvas for first image (auto-detection)
      if (index === 0 && !autoDetectionPerformed) {
        fabricCanvas.clear();
      }
      
      fabricCanvas.add(img);
      fabricCanvas.requestRenderAll();
      

      
      // Pre-cache the image for modal use
      preCacheImageForModal(img);
      
      // Add to session images for recent images feature
      const imageDataUrl = img.toDataURL();
      if (!sessionImages.includes(imageDataUrl)) {
        sessionImages.push(imageDataUrl);

      }
      
      // Add double-click event for cropping
      img.on('mousedblclick', function() {

        // Check image size before showing loading overlay
        const isHighRes = img.width * img.height > 10000000; // 10MP threshold
        
        // Show loading overlay immediately with appropriate message
        loadingOverlay.classList.add('show');
        const loadingText = document.getElementById('loading-text');
        
        if (isHighRes) {
          loadingText.textContent = 'High-resolution image detected - this may take a moment...';
        } else {
          loadingText.textContent = 'Preparing image editor...';
        }
        
        // Use requestAnimationFrame to ensure UI is responsive, then get data URL
        requestAnimationFrame(() => {
          // Use a worker or setTimeout to make toDataURL truly non-blocking
          setTimeout(() => {
            const imgUrl = img.toDataURL();
            openCropModal(imgUrl, img);
          }, 50); // Small delay to ensure UI responsiveness
        });
      });
      
      // Alternative: Add to canvas level
      fabricCanvas.on('mouse:dblclick', function(options) {
        if (options.target === img) {
  
          // Check image size before showing loading overlay
          const isHighRes = img.width * img.height > 10000000; // 10MP threshold
          
          // Show loading overlay immediately with appropriate message
          loadingOverlay.classList.add('show');
          const loadingText = document.getElementById('loading-text');
          
          if (isHighRes) {
            loadingText.textContent = 'High-resolution image detected - this may take a moment...';
          } else {
            loadingText.textContent = 'Preparing image editor...';
          }
          
          // Use requestAnimationFrame to ensure UI is responsive, then get data URL
          requestAnimationFrame(() => {
            // Use a worker or setTimeout to make toDataURL truly non-blocking
            setTimeout(() => {
              const imgUrl = img.toDataURL();
              openCropModal(imgUrl, img);
            }, 50); // Small delay to ensure UI responsiveness
          });
        }
      });
      

    }



    // Desk Pad Editor functionality
    let deskPadModalCanvas = null;
    let deskPadButton = document.getElementById('desk-pad-button');
    let deskPadModalOverlay = document.getElementById('desk-pad-modal-overlay');
    let deskPadModalCanvasEl = document.getElementById('desk-pad-modal-canvas');
    let deskPadFinishedBtn = document.getElementById('desk-pad-finished-btn');
    let deskPadMenuBtn = document.getElementById('desk-pad-menu-btn');
    let buttonPreview = document.getElementById('button-preview');
    
    // Add Image Modal elements (now universal menu)
    let addImageModal = document.getElementById('add-image-modal');
    let addImageClose = document.getElementById('add-image-close');

    let recentImagesGrid = document.getElementById('recent-images-grid');
    let deskPadModalCanvasContainer = document.getElementById('desk-pad-modal-canvas-container');
    let menuAddImage = document.getElementById('menu-add-image');
    let menuRecentImages = document.getElementById('menu-recent-images');
    
    // Track recent images
    let recentImages = [];
    
    // Track all images used in this session
    let sessionImages = [];
    
    // Modal drag and drop elements
    let modalDropOverlay = document.getElementById('modal-drop-overlay');
    
    // Track if modal auto-detection has been performed
    let modalAutoDetectionPerformed = false;
    let modalTargetCanvasWidth = 4305;
    let modalTargetCanvasHeight = 1620;
    
    // Modal DPI display element
    let modalDpiDisplay = document.getElementById('modal-dpi-display');
    
    // DPI selection variables
    let currentDPI = 100; // Default to 100 DPI for better performance
    let currentCanvasWidth = 2900; // Default 100 DPI width (77:29 aspect ratio)
    let currentCanvasHeight = 1093; // Default 100 DPI height (77:29 aspect ratio)
    let dpiLocked = false; // Track if DPI is locked after auto-detection
    
    // --- Aspect Ratio Presets (Base dimensions at 150 DPI for editing) ---
    const aspectPresets = {
      extended:    { w: 4725, h: 1785, aspect: 77/29, name: '77:29 €" EXTENDED', proof: 'proof_extended.png' },    // 31.5" x 11.9" @150dpi
      immersive:   { w: 5310, h: 2220, aspect: 43/18, name: '43:18 €" IMMERSIVE', proof: 'proof_immersive.png' },   // 35.4" x 14" @150dpi
      laptop:      { w: 3815, h: 2250, aspect: 61/36, name: '61:36 €" LAPTOP / PLAYMAT', proof: 'proof_laptop.png' },      // 27" x 16" @150dpi
      fullsize:    { w: 5400, h: 2306, aspect: 96/41, name: '96:41 €" FULL SIZE', proof: 'proof_fullsize.png' },    // 36" x 15.37" @150dpi
      supersize:   { w: 7200, h: 3636, aspect: 101/51, name: '101:51 €" SUPER SIZE', proof: 'proof_supersize.png' }   // 48" x 24.24" @150dpi
    };
    
    // Smart DPI management - edit at screen resolution, export at print resolution
    const EDIT_DPI = 150;  // DPI for editing (smooth UX)
    
    let currentPreset = 'extended';
    
    // Initialize handle sizes for current DPI after variables are defined
    updateHandleSizes(currentDPI);
    
    // Function to load image asynchronously
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }
    
    // Function to generate preview with pad overlay
    async function generatePreview() {
      
      if (!deskPadModalCanvas || deskPadModalCanvas.getObjects().length === 0) {
        alert('No content to preview. Please add some images or text first.');
        return;
      }

      const preset = aspectPresets[currentPreset];
      if (!preset) {
        alert('No preset found for current aspect ratio.');
        return;
      }

      // Get and load the proof PNG
      let proofImg;
      try {
        proofImg = await loadImage(preset.proof);
      } catch (err) {
        console.error('Could not load proof overlay image:', err);
        alert('Could not load preview overlay. Please check if the proof image files are available.');
        return;
      }

      // Hide selection handles for clean preview
      const prevActive = deskPadModalCanvas.getActiveObject();
      deskPadModalCanvas.discardActiveObject();
      deskPadModalCanvas.renderAll();

      // Generate user image PNG
      const w = proofImg.width, h = proofImg.height;
      const temp = document.createElement('canvas');
      temp.width = w; temp.height = h;
      const tctx = temp.getContext('2d');

      const userAR = deskPadModalCanvas.getWidth() / deskPadModalCanvas.getHeight();
      const proofAR = w / h;
      let drawW, drawH, drawX, drawY;
      if (userAR > proofAR) {
        drawH = h;
        drawW = h * userAR;
        drawX = (w - drawW) / 2;
        drawY = 0;
      } else {
        drawW = w;
        drawH = w / userAR;
        drawX = 0;
        drawY = (h - drawH) / 2;
      }
      tctx.drawImage(deskPadModalCanvas.lowerCanvasEl, drawX, drawY, drawW, drawH);

      const userImgURL = temp.toDataURL('image/png');
      let userImg;
      try {
        userImg = await loadImage(userImgURL);
      } catch (err) {
        console.error('Could not generate user image for preview:', err);
        alert('Could not generate preview image.');
        return;
      }

      // Create the composite preview
      const workCanvas = document.createElement('canvas');
      workCanvas.width = w; workCanvas.height = h;
      const ctx = workCanvas.getContext('2d');
      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(userImg, 0, 0, w, h);

      // Use composite operations instead of getImageData to avoid tainted canvas issues
      // First, draw the proof image as a mask
      ctx.save();
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(proofImg, 0, 0, w, h);
      ctx.restore();

      // Overlay proof PNG multiple times with different blend/opacity
      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = "overlay";
      ctx.drawImage(proofImg, 0, 0, w, h);
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = "overlay";
      ctx.drawImage(proofImg, 0, 0, w, h);
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = "overlay";
      ctx.drawImage(proofImg, 0, 0, w, h);
      ctx.restore();

      // Update the preview canvas and show modal
      const previewCanvas = document.getElementById('previewCanvas');
      if (previewCanvas) {
        previewCanvas.width = w;
        previewCanvas.height = h;
        const pctx = previewCanvas.getContext('2d');
        pctx.drawImage(workCanvas, 0, 0, w, h);
        
        // Show the preview modal
        const previewModal = document.getElementById('previewModal');
        previewModal.style.display = 'flex';
      }

      // Restore active object
      if (prevActive) {
        deskPadModalCanvas.setActiveObject(prevActive);
        deskPadModalCanvas.renderAll();
      }
    }
    
    // Save preview functionality
    document.getElementById('btn-save-preview').addEventListener('click', function() {
      const previewCanvas = document.getElementById('previewCanvas');
      if (previewCanvas) {
        const link = document.createElement('a');
        link.download = `preview_${currentPreset}_${Date.now()}.png`;
        link.href = previewCanvas.toDataURL('image/png');
        link.click();
      }
    });
    
    // Function to auto-detect appropriate DPI based on image resolution
    function autoDetectDPI(imageWidth, imageHeight) {
      const imagePixels = imageWidth * imageHeight;
      
      
      // Calculate what DPI this image would be at the current canvas size
      const preset = aspectPresets[currentPreset];
      const canvasWidth = preset.w;
      const canvasHeight = preset.h;
      
      // Calculate DPI if this image filled the canvas
      const dpiIfFilled = Math.min(
        imageWidth / (canvasWidth / 150), // Width-based DPI
        imageHeight / (canvasHeight / 150) // Height-based DPI
      );
      
      
      
      // Smart DPI selection based on image quality
      if (dpiIfFilled >= 300) {
        return 300;
      } else if (dpiIfFilled >= 200) {
        return 200;
      } else if (dpiIfFilled >= 150) {
        return 150;
      } else {
        return 100;
      }
    }
    
    // Function to lock DPI options (gray out non-selected options)
    function lockDPIOptions(selectedDPI) {

      dpiLocked = true;
      
      const dpiOptions = document.querySelectorAll('.dpi-option');
      dpiOptions.forEach(option => {
        const optionDPI = parseInt(option.dataset.dpi);
        if (optionDPI !== selectedDPI) {
          option.classList.add('locked');
        } else {
          option.classList.remove('locked');
        }
      });
      
      // Show lock indicator
      const lockIndicator = document.getElementById('dpi-lock-indicator');
      if (lockIndicator) {
        lockIndicator.style.display = 'inline';
      }
    }
    
    // Function to unlock DPI options
    function unlockDPIOptions() {
      dpiLocked = false;
      
      const dpiOptions = document.querySelectorAll('.dpi-option');
      dpiOptions.forEach(option => {
        option.classList.remove('locked');
      });
      
      // Hide lock indicator
      const lockIndicator = document.getElementById('dpi-lock-indicator');
      if (lockIndicator) {
        lockIndicator.style.display = 'none';
      }
    }
    
    // Function to show DPI change warning
    function showDPIChangeWarning(callback) {
      const warningMessage = `š ï¸ Warning: Changing DPI will clear the canvas.\n\n` +
                           `All existing images will be removed to ensure proper functionality with the new DPI settings.\n\n` +
                           `You can re-add your images after the DPI change.\n\n` +
                           `Are you sure you want to continue?`;
      
      if (confirm(warningMessage)) {
        callback();
      }
    }
    
    // Function to update transform handle sizes based on DPI
    function updateHandleSizes(dpi) {
      
      // Calculate handle size based on DPI
      let handleSize, strokeWidth, borderScale;
      
      switch(dpi) {
        case 100:
          handleSize = 30;
          strokeWidth = 2;
          borderScale = 2;
          break;
        case 200:
          handleSize = 55; // Double the size for 200 DPI
          strokeWidth = 3;
          borderScale = 3;
          break;
        case 300:
          handleSize = 80; // Double again for 300 DPI
          strokeWidth = 4;
          borderScale = 4;
          break;
        default:
          handleSize = 20;
          strokeWidth = 2;
          borderScale = 2;
      }
      
      // Update global Fabric.js settings
      fabric.Object.prototype.cornerSize = handleSize;
      fabric.Object.prototype.cornerStrokeWidth = strokeWidth;
      fabric.Object.prototype.borderScaleFactor = borderScale;
      
      // Update existing objects on the canvas
      if (deskPadModalCanvas) {
        const objects = deskPadModalCanvas.getObjects();
        objects.forEach(obj => {
          obj.set({
            cornerSize: handleSize,
            cornerStrokeWidth: strokeWidth,
            borderScaleFactor: borderScale
          });
        });
        deskPadModalCanvas.requestRenderAll();
      }
      
    }
    
    // Function to force update all existing objects with current handle sizes
    function forceUpdateAllHandles() {
      if (deskPadModalCanvas) {
        const objects = deskPadModalCanvas.getObjects();
        const handleSize = fabric.Object.prototype.cornerSize;
        const strokeWidth = fabric.Object.prototype.cornerStrokeWidth;
        const borderScale = fabric.Object.prototype.borderScaleFactor;
        
        objects.forEach(obj => {
          obj.set({
            cornerSize: handleSize,
            cornerStrokeWidth: strokeWidth,
            borderScaleFactor: borderScale
          });
        });
        deskPadModalCanvas.requestRenderAll();
      }
    }
    
    // --- Aspect Ratio Preset Functions ---
    function applyAspectPreset(presetKey) {
      const preset = aspectPresets[presetKey];
      if (!preset) return;
      
      currentPreset = presetKey;
      
      // Calculate canvas dimensions based on current DPI
      // Base dimensions are at 150 DPI, so scale relative to 150 DPI
      const dpiScale = currentDPI / 150;
      const canvasWidth = Math.round(preset.w * dpiScale);
      const canvasHeight = Math.round(preset.h * dpiScale);
      
      // Performance warning for very large canvases
      const totalPixels = canvasWidth * canvasHeight;
      if (totalPixels > 10000000) { // 10 million pixels
        console.warn(`š ï¸ Large canvas detected: ${canvasWidth} — ${canvasHeight} = ${(totalPixels/1000000).toFixed(1)}M pixels`);
        console.warn(`ðŸ'¡ Consider using a smaller aspect ratio or lower DPI for better performance`);
      }
      
      // Update global variables
      currentCanvasWidth = canvasWidth;
      currentCanvasHeight = canvasHeight;
      
      // Update the current canvas size display
      const currentCanvasSizeDisplay = document.getElementById('current-canvas-size-display');
      if (currentCanvasSizeDisplay) {
        currentCanvasSizeDisplay.textContent = preset.name;
      }
      
      // Update the current DPI display in the menu to show new canvas dimensions
      const currentDpiDisplay = document.getElementById('current-dpi-display');
      if (currentDpiDisplay) {
              currentDpiDisplay.textContent = `${currentDPI} DPI • ${canvasWidth} × ${canvasHeight}px`;
      }
      
      // Update canvas size info display
      const canvasSizeInfo = document.getElementById('canvas-size-info');
      if (canvasSizeInfo) {
        const aspectRatio = (canvasWidth / canvasHeight).toFixed(3);
        const printWidth = (canvasWidth / currentDPI * 25.4).toFixed(1);
        const printHeight = (canvasHeight / currentDPI * 25.4).toFixed(1);
        
        canvasSizeInfo.innerHTML = `
          <strong>Canvas Size:</strong> ${canvasWidth} — ${canvasHeight}px<br>
          <strong>Aspect Ratio:</strong> ${aspectRatio} (${preset.aspect.toFixed(2)}:1)<br>
          <strong>Print Quality:</strong> ${currentDPI} DPI<br>
          <strong>Print Size:</strong> ${printWidth}cm — ${printHeight}cm<br>
          <small>Images will scale to fit but won't upscale if too small</small>
        `;
      }
      
      // If canvas exists, resize it
      if (deskPadModalCanvas) {
        // Store existing objects before resize
        const existingObjects = deskPadModalCanvas.getObjects().filter(obj => obj.type !== 'rect'); // Exclude test rectangles
        const oldWidth = deskPadModalCanvas.getWidth();
        const oldHeight = deskPadModalCanvas.getHeight();
        
        
        // Resize canvas
        deskPadModalCanvas.setWidth(canvasWidth);
        deskPadModalCanvas.setHeight(canvasHeight);
        
        // Ensure snapping settings are preserved after resize with DPI scaling
        const scaledSnapThreshold = Math.round(30 * dpiScale);
        const scaledSnapAngle = Math.round(30 * dpiScale);
        
        deskPadModalCanvas.set({
          snapAngle: scaledSnapAngle,
          snapThreshold: scaledSnapThreshold
        });
        
        // Reposition existing objects to fit new canvas (preserve pixel dimensions)
        existingObjects.forEach(obj => {
          if (obj.type === 'image') {
            // Calculate position scaling (but don't change image pixel dimensions)
            const scaleX = canvasWidth / oldWidth;
            const scaleY = canvasHeight / oldHeight;
            
            // Update object position only (preserve scaleX and scaleY)
            obj.set({
              left: obj.left * scaleX,
              top: obj.top * scaleY
            });
            
            // Ensure object stays within canvas bounds
            const objWidth = obj.getScaledWidth();
            const objHeight = obj.getScaledHeight();
            
            if (obj.left < 0) obj.left = 0;
            if (obj.top < 0) obj.top = 0;
            if (obj.left + objWidth > canvasWidth) obj.left = canvasWidth - objWidth;
            if (obj.top + objHeight > canvasHeight) obj.top = canvasHeight - objHeight;
            
            obj.setCoords();
          }
        });
        
        // Auto-center all objects after aspect ratio change (especially important at higher DPI)
        if (existingObjects.length > 0) {
          setTimeout(() => {
            centerAllObjectsInCanvas();
          }, 100);
        }
        
        // Force recalculation of transform controls
        deskPadModalCanvas.calcOffset();
        deskPadModalCanvas.requestRenderAll();
        
        // Update background to match new canvas size
        updateCanvasBackground();
        
        // Update properties panel to refresh DPI calculations
        setTimeout(() => {
          const selectedLayer = layers.find(l => l.object === deskPadModalCanvas.getActiveObject());
          if (selectedLayer) {
            updatePropertiesPanel(selectedLayer);
          }
        }, 100);
      }
      
      // Reset zoom to fit the new canvas size
      setTimeout(() => {
        canvasZoomFit();
      }, 200);
    }
    
    // Function to update canvas resolution based on DPI selection
    function updateCanvasResolution(dpi, width, height) {
      
      // Update global variables
      currentDPI = dpi;
      currentCanvasWidth = width;
      currentCanvasHeight = height;
      
      // Update the current DPI display in the menu
      const currentDpiDisplay = document.getElementById('current-dpi-display');
      if (currentDpiDisplay) {
        currentDpiDisplay.textContent = `${dpi} DPI • ${width} × ${height}px`;
      }
      
      // Update transform handle sizes based on DPI
      updateHandleSizes(dpi);
      
      // If canvas exists, resize it
      if (deskPadModalCanvas) {
        // Clear canvas properly using our dedicated function
        clearCanvas();
        
        // Resize canvas
        deskPadModalCanvas.setWidth(width);
        deskPadModalCanvas.setHeight(height);
        
        // Ensure snapping settings are preserved after resize with DPI scaling
        const dpiScale = currentDPI / 100;
        const scaledSnapThreshold = Math.round(30 * dpiScale); // Increased from 15 to 30
        const scaledSnapAngle = Math.round(30 * dpiScale); // Increased from 15 to 30
        
        deskPadModalCanvas.set({
          snapAngle: scaledSnapAngle,
          snapThreshold: scaledSnapThreshold,
          snapAngleThreshold: scaledSnapAngle
        });
        
        // Update stored dimensions
        modalCanvasWidth = width;
        modalCanvasHeight = height;
        
        // Force Fabric.js to recalculate offsets after resize
        deskPadModalCanvas.calcOffset();
        
        // Update background to match new canvas size
        updateCanvasBackground();
        
        // Reset zoom to fit the new canvas size
        setTimeout(() => {
          canvasZoomFit();
        }, 200);
      }
      
      // Update canvas size info display
      const canvasSizeInfo = document.getElementById('canvas-size-info');
      if (canvasSizeInfo) {
        canvasSizeInfo.innerHTML = `
          <strong>Canvas Size:</strong> ${width} — ${height}px<br>
          <strong>Aspect Ratio:</strong> ${(width/height).toFixed(3)} (77:29)<br>
          <strong>Print Quality:</strong> ${dpi} DPI<br>
          <strong>Print Size:</strong> 11" — 29"<br>
          <small>Images will scale to fit but won't upscale if too small</small>
        `;
      }
    }
    
    function updateModalDPIDisplay(imageWidth, imageHeight, canvasWidth, canvasHeight, scale) {
      const dpi = calculateDPI(imageWidth, imageHeight, canvasWidth, canvasHeight);
      const scaledWidth = Math.round(imageWidth * scale);
      const scaledHeight = Math.round(imageHeight * scale);
      
      modalDpiDisplay.innerHTML = `
        <strong>Modal Image DPI Info:</strong><br>
        Original: ${imageWidth} — ${imageHeight}px<br>
        Scaled: ${scaledWidth} — ${scaledHeight}px<br>
        DPI: ${dpi.dpiX} — ${dpi.dpiY}<br>
        Scale: ${(scale * 100).toFixed(1)}%
      `;
    }
    

    

    


    // Initialize simple desk pad modal canvas
    // Global function to fix textBaseline errors
    function fixTextBaselineErrors() {
      if (!deskPadModalCanvas) return;
      
      const objects = deskPadModalCanvas.getObjects();
      let fixedCount = 0;
      objects.forEach(obj => {
        // Fix both 'alphabetical' and any other invalid values
        if ((obj.type === 'i-text' || obj.type === 'text') && (obj.textBaseline === 'alphabetical' || !['alphabetic', 'top', 'hanging', 'middle', 'ideographic', 'bottom'].includes(obj.textBaseline))) {
          obj.set('textBaseline', 'alphabetic');
          fixedCount++;
        }
      });
      if (fixedCount > 0) {
        deskPadModalCanvas.requestRenderAll();
        console.log(`Fixed ${fixedCount} textBaseline errors`);
      }
    }

    function initResizableDeskPadModalCanvas() {
      
      
      if (!deskPadModalCanvas) {
        try {
          // Initialize with the current aspect ratio preset
          applyAspectPreset(currentPreset);
          
          // Use current DPI-based dimensions from the preset
          let canvasWidth = currentCanvasWidth;
          let canvasHeight = currentCanvasHeight;
          

          
          // Create canvas with CSS background and snapping
          const dpiScale = currentDPI / 100;
          const scaledSnapThreshold = Math.round(30 * dpiScale); // Increased from 15 to 30
          const scaledSnapAngle = Math.round(30 * dpiScale); // Increased from 15 to 30
          
          deskPadModalCanvas = new fabric.Canvas('desk-pad-modal-canvas', {
            width: canvasWidth,
            height: canvasHeight,
            selection: true,
            snapAngle: scaledSnapAngle,
            snapThreshold: scaledSnapThreshold,
            snapAngleThreshold: scaledSnapAngle,
            // Performance optimizations for large canvases
            enableRetinaScaling: false, // Disable retina scaling for better performance
            renderOnAddRemove: false, // Don't render on every add/remove
            skipTargetFind: false, // Keep target finding for interactions
            preserveObjectStacking: true, // Maintain object order
            // Reduce rendering frequency for better performance
            skipOffscreen: true, // Skip rendering objects outside viewport
            // Optimize for large canvases
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'high',
            // Enable text editing
            textEditing: true
          });
          
                // Fix any existing textBaseline errors
      fixTextBaselineErrors();
          
          // Set custom control colors for better visibility on white background
          deskPadModalCanvas.set({
            transparentCorners: false,
            cornerColor: '#2c3e50', // Dark blue-gray
            cornerStrokeColor: '#ffffff', // White border
            cornerSize: 12,
            cornerStyle: 'circle',
            borderColor: '#2c3e50', // Dark blue-gray border
            borderScaleFactor: 2
          });
          
  
          
          // Canvas is working - no need for raw click logging
          
          // Test if Fabric.js is properly initialized
          
          
          // Store dimensions
          modalArtboardWidth = canvasWidth;
          modalArtboardHeight = canvasHeight;
          modalCanvasWidth = canvasWidth;
          modalCanvasHeight = canvasHeight;
          
          // Update size display with initial values
          updateCanvasSizeDisplay(canvasWidth, canvasHeight);
          
          // Add basic event listeners
          deskPadModalCanvas.on('mouse:down', function(opt) {
            if (opt.target) {
              // Mouse down event - not the same as object:selected
            }
          });
          
          // Selection events - using Fabric.js built-in selection border system
          deskPadModalCanvas.on('selection:created', function(opt) {
    
            // Handle multiple selections
            if (opt.selected && opt.selected.length > 0) {
              if (opt.selected.length === 1) {
                // Single selection - set active layer
                const selectedObject = opt.selected[0];
                const layer = layers.find(l => l.object === selectedObject);
        
                
                if (layer) {
                  activeLayerId = layer.id;
                  updatePropertiesPanel(layer);
                  updateLayersList();
                }
              } else {
                // Multiple selection - highlight all corresponding layers
                const selectedLayerIds = [];
                
                opt.selected.forEach((obj, index) => {
                  const layer = layers.find(l => l.object === obj);
                  if (layer) {
                    selectedLayerIds.push(layer.id);
                  }
                });
                
                // Set the first selected layer as active, but mark all as selected
                if (selectedLayerIds.length > 0) {
                  activeLayerId = selectedLayerIds[0];
                  
                  // Don't show properties for multiple selections
                  updatePropertiesPanel(null);
                  
                  updateLayersList();
                }
              }
            }
            
            // Close canvas and background toolbars when object is selected
            const canvasToolbar = document.getElementById('canvas-toolbar');
            const canvasToggleBtn = document.getElementById('canvas-toggle-btn');
            const backgroundToolbar = document.getElementById('background-toolbar');
            const backgroundToggleBtn = document.getElementById('background-toggle-btn');
            
            if (canvasToolbar && canvasToolbar.classList.contains('show')) {
              canvasToolbar.classList.remove('show');
              canvasToggleBtn.classList.remove('active');
            }
            
            if (backgroundToolbar && backgroundToolbar.classList.contains('show')) {
              backgroundToolbar.classList.remove('show');
              backgroundToggleBtn.classList.remove('active');
            }
            
            // Automatically open Transform menu when object is selected
            const alignmentToolbar = document.getElementById('alignment-toolbar');
            const alignmentToggleBtn = document.getElementById('alignment-toggle-btn');
            const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
            
            if (alignmentToolbar && !alignmentToolbar.classList.contains('show')) {
              alignmentToolbar.classList.add('show');
              alignmentToggleBtn.classList.add('active');
              canvasContainer.classList.add('with-alignment-toolbar');
            }
            
            updateAlignmentToolbar();
          });
          
          deskPadModalCanvas.on('selection:updated', function(opt) {
            // Handle multiple selections
            if (opt.selected && opt.selected.length > 0) {
              if (opt.selected.length === 1) {
                // Single selection - set active layer
                const selectedObject = opt.selected[0];
                const layer = layers.find(l => l.object === selectedObject);
                
                if (layer) {
                  activeLayerId = layer.id;
                  
                  // Ensure layers menu is open so properties panel elements are available
                  const layersMenu = document.getElementById('layers-menu');
                  if (layersMenu && !layersMenu.classList.contains('active')) {
                    layersMenu.classList.add('active');
                  }
                  
                  // Update properties panel after ensuring menu is open
                  setTimeout(() => {
                    updatePropertiesPanel(layer);
                  }, 100);
                  
                  updateLayersList();
                }
              } else {
                // Multiple selection - highlight all corresponding layers
                const selectedLayerIds = [];
                
                opt.selected.forEach((obj, index) => {
                  const layer = layers.find(l => l.object === obj);
                  if (layer) {
                    selectedLayerIds.push(layer.id);
                  }
                });
                
                // Set the first selected layer as active, but mark all as selected
                if (selectedLayerIds.length > 0) {
                  activeLayerId = selectedLayerIds[0];
                  
                  // Don't show properties for multiple selections
                  updatePropertiesPanel(null);
                  
                  updateLayersList();
                }
              }
            }
            
            // Close canvas and background toolbars when object is selected
            const canvasToolbar = document.getElementById('canvas-toolbar');
            const canvasToggleBtn = document.getElementById('canvas-toggle-btn');
            const backgroundToolbar = document.getElementById('background-toolbar');
            const backgroundToggleBtn = document.getElementById('background-toggle-btn');
            
            if (canvasToolbar && canvasToolbar.classList.contains('show')) {
              canvasToolbar.classList.remove('show');
              canvasToggleBtn.classList.remove('active');
            }
            
            if (backgroundToolbar && backgroundToolbar.classList.contains('show')) {
              backgroundToolbar.classList.remove('show');
              backgroundToggleBtn.classList.remove('active');
            }
            
            // Automatically open Transform menu when object is selected
            const alignmentToolbar = document.getElementById('alignment-toolbar');
            const alignmentToggleBtn = document.getElementById('alignment-toggle-btn');
            const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
            
            if (alignmentToolbar && !alignmentToolbar.classList.contains('show')) {
              alignmentToolbar.classList.add('show');
              alignmentToggleBtn.classList.add('active');
              canvasContainer.classList.add('with-alignment-toolbar');
            }
            
            updateAlignmentToolbar();
          });
          
          deskPadModalCanvas.on('selection:cleared', function(opt) {
            // Close Transform menu when no objects are selected
            const alignmentToolbar = document.getElementById('alignment-toolbar');
            const alignmentToggleBtn = document.getElementById('alignment-toggle-btn');
            const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
            
            if (alignmentToolbar && alignmentToolbar.classList.contains('show')) {
              alignmentToolbar.classList.remove('show');
              alignmentToggleBtn.classList.remove('active');
              canvasContainer.classList.remove('with-alignment-toolbar');
            }
            
            updateAlignmentToolbar();
          });
          
          deskPadModalCanvas.on('object:moving', function(opt) {
            // Simple border snapping (reduced logging for performance)
            if (opt.target) {
              applySimpleSnapping(opt.target);
            }
          });
          
          // Real-time DPI updates during scaling
          deskPadModalCanvas.on('object:scaling', function(opt) {
            // Update properties panel in real-time during scaling
            if (opt.target && activeLayerId) {
              const activeLayer = layers.find(l => l.id === activeLayerId);
              if (activeLayer && activeLayer.object === opt.target) {
                updatePropertiesPanel(activeLayer);
              }
            }
          });
          
          // Object selection handler
          deskPadModalCanvas.off('object:selected'); // Remove any existing handlers
          deskPadModalCanvas.on('object:selected', function(opt) {
            // Find the layer that contains this object and select it
            const layer = layers.find(l => l.object === opt.target);
            
            if (layer) {
              selectLayer(layer.id);
            }
            

          });
          

          
          deskPadModalCanvas.on('selection:cleared', function(opt) {
            // Clear the properties panel when no object is selected
            updatePropertiesPanel(null);
            activeLayerId = null;
            updateLayersList();
          });
          
          deskPadModalCanvas.on('object:modified', function(opt) {
            // Update properties panel if this object is part of the active layer
            if (activeLayerId) {
              const activeLayer = layers.find(l => l.id === activeLayerId);
              if (activeLayer && activeLayer.object === opt.target) {
                updatePropertiesPanel(activeLayer);
              }
            }
          });
          
          // Add text editing event listeners
          deskPadModalCanvas.on('text:editing:entered', function(opt) {

          });
          
          deskPadModalCanvas.on('text:editing:exited', function(opt) {

          });
          
          // Border rectangle removed - canvas is now clean without internal border
          
          // Canvas is ready for images

  
          
          // Force update any existing objects with current handle sizes
          setTimeout(() => {
            forceUpdateAllHandles();
          }, 100);
          

          
          // Add zoom functionality
          setupCanvasZoomAndPan(deskPadModalCanvas);
          
          // Initialize zoom display and fit canvas to view
          const zoomDisplay = document.getElementById('zoom-level');
          if (zoomDisplay) {
            zoomDisplay.textContent = '100%';
          }
          
          // Automatically fit canvas to viewport on initialization
          setTimeout(() => {
            canvasZoomFit();
          }, 100);
          
          // Setup simple snapping
          setupCanvasSnapping();
          
          // Ensure all objects have current DPI-based snapping settings
          updateAllObjectsSnappingSettings();
          
          // Add keyboard shortcuts for canvas viewport zooming and deletion
          document.addEventListener('keydown', function(e) {
            if (e.ctrlKey) {
              if (e.key === '+' || e.key === '=') {
                e.preventDefault();
                canvasZoomIn();
              } else if (e.key === '-') {
                e.preventDefault();
                canvasZoomOut();
              }
            }
            
            // Handle delete key for selected objects
            if (e.key === 'Delete' || e.key === 'Backspace') {
              const activeObjects = deskPadModalCanvas.getActiveObjects();
              if (activeObjects && activeObjects.length > 0) {
                e.preventDefault();
                
                if (activeObjects.length === 1) {
                  // Single object deletion
                  const activeObject = activeObjects[0];
                  const layer = layers.find(l => l.object === activeObject);
                  if (layer) {
                    deleteLayer(layer.id);
                  } else {
                    deskPadModalCanvas.remove(activeObject);
                    deskPadModalCanvas.renderAll();
                  }
                  
                  // Clear the selection to remove any remaining outlines
                  deskPadModalCanvas.discardActiveObject();
                  deskPadModalCanvas.renderAll();
                } else {
                  // Multiple objects deletion
                  const layersToDelete = [];
                  
                  // Find all corresponding layers
                  activeObjects.forEach((obj, index) => {
                    const layer = layers.find(l => l.object === obj);
                    if (layer) {
                      layersToDelete.push(layer);
                    }
                  });
                  
                  // Delete all layers (this will also remove objects from canvas)
                  layersToDelete.forEach(layer => {
                    deleteLayer(layer.id);
                  });
                  
                  // Remove any objects that don't have layers
                  activeObjects.forEach(obj => {
                    const hasLayer = layers.find(l => l.object === obj);
                    if (!hasLayer) {
                      deskPadModalCanvas.remove(obj);
                    }
                  });
                  
                  deskPadModalCanvas.renderAll();
                  
                  // Clear the selection to remove any remaining outlines
                  deskPadModalCanvas.discardActiveObject();
                  deskPadModalCanvas.renderAll();
                }
              }
            }
          });
          
          // Fix any existing textBaseline errors on canvas initialization
          fixTextBaselineErrors();
          
          // Initialize opacity slider after canvas is ready
          setupOpacitySlider();
          
          // Add double-click event listener
          deskPadModalCanvas.on('mouse:dblclick', function(opt) {
            const target = opt.target;

            if (target && target.type === 'image') {
              const isHighRes = target.width * target.height > 10000000;
              
              loadingOverlay.classList.add('show');
              const loadingText = document.getElementById('loading-text');
              
              if (isHighRes) {
                loadingText.textContent = 'High-resolution image detected - this may take a moment...';
              } else {
                loadingText.textContent = 'Preparing image editor...';
              }
              
              requestAnimationFrame(() => {
                setTimeout(() => {
                  const imgUrl = target.toDataURL();
                  openCropModal(imgUrl, target);
                }, 50);
              });
            } else if (target && target.type === 'i-text') {
              // Handle text editing via modal
      
              showTextEditorModal(target);
            }
          });
          
  
          
        } catch (err) {
          console.error('Failed to initialize resizable desk pad modal canvas:', err);
          alert('Failed to initialize the full-screen editor. Please try again.');
        }
      } else {

      }
    }

    // Text Editor Modal Functions
    let editingTextObj = null;

    // Global variables to remember modal state
    let lastModalState = {
      strokeEnabled: false,
      strokeColor: '#000000',
      strokeWidth: 2,
      strokePosition: 'center',
      shadowEnabled: false,
      shadowColor: '#000000',
      shadowDistance: 2,
      shadowDirectionAngle: 45,
      shadowBlur: 4,
      backgroundColor: '#000000',
      fontSizeMode: 'dropdown', // 'dropdown' or 'input'
      fontSizeValue: 45
    };
    
    // Global variable for shadow direction angle
    let shadowDirectionAngle = 45; // Default to bottom-right (45 degrees)

          // Helper functions for shadow direction
      function drawShadowDirectionCanvas() {
        const ctx = shadowDirectionCanvas.getContext('2d');
        const centerX = shadowDirectionCanvas.width / 2;
        const centerY = shadowDirectionCanvas.height / 2;
        const radius = 20;
        
        // Clear canvas
        ctx.clearRect(0, 0, shadowDirectionCanvas.width, shadowDirectionCanvas.height);
        
        // Draw outer circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius + 2, 0, 2 * Math.PI);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw main circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw degree markers (every 45 degrees)
        for (let i = 0; i < 8; i++) {
          const markerAngle = i * 45 * Math.PI / 180;
          const markerX = centerX + Math.cos(markerAngle) * (radius + 4);
          const markerY = centerY + Math.sin(markerAngle) * (radius + 4);
          
          ctx.beginPath();
          ctx.arc(markerX, markerY, 1, 0, 2 * Math.PI);
          ctx.fillStyle = '#666';
          ctx.fill();
        }
        
        // Draw center dot
        ctx.beginPath();
        ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI);
        ctx.fillStyle = '#f4a012';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw direction line and dot
        const angle = shadowDirectionAngle * Math.PI / 180;
        const dotX = centerX + Math.cos(angle) * radius;
        const dotY = centerY + Math.sin(angle) * radius;
        
        // Draw line from center to edge
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(dotX, dotY);
        ctx.strokeStyle = '#f4a012';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw draggable dot with glow effect
        ctx.beginPath();
        ctx.arc(dotX, dotY, 5, 0, 2 * Math.PI);
        ctx.fillStyle = 'rgba(244, 160, 18, 0.3)';
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(dotX, dotY, 4, 0, 2 * Math.PI);
        ctx.fillStyle = '#f4a012';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw angle arc
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius - 8, 0, angle);
        ctx.strokeStyle = 'rgba(244, 160, 18, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      function updateShadowDirectionLabel() {
        const directions = [
          { angle: 0, name: 'Right' },
          { angle: 45, name: 'Bottom Right' },
          { angle: 90, name: 'Bottom' },
          { angle: 135, name: 'Bottom Left' },
          { angle: 180, name: 'Left' },
          { angle: 225, name: 'Top Left' },
          { angle: 270, name: 'Top' },
          { angle: 315, name: 'Top Right' }
        ];
        
        // Find closest direction
        let closest = directions[0];
        let minDiff = Math.abs(shadowDirectionAngle - directions[0].angle);
        
        for (let dir of directions) {
          const diff = Math.abs(shadowDirectionAngle - dir.angle);
          if (diff < minDiff) {
            minDiff = diff;
            closest = dir;
          }
        }
        
        shadowDirectionLabel.textContent = closest.name;
        shadowDirectionDegrees.textContent = Math.round(shadowDirectionAngle) + '°';
      }
      
            function getShadowOffsetX(angle, distance) {
        return Math.cos(angle * Math.PI / 180) * distance;
      }
      
      function getShadowOffsetY(angle, distance) {
        return Math.sin(angle * Math.PI / 180) * distance;
      }

    function showTextEditorModal(obj) {
      // Create modal if not exists
      let modal = document.getElementById('textEditorModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'textEditorModal';
        modal.className = 'editor-overlay';
        modal.style.cssText = 'position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:999999; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center;';
        modal.innerHTML = `
          <div style="background:#333; color:#fff; border-radius:8px; padding:1.5rem; width:760px; max-width:90vw; max-height:80vh; overflow-y:auto; border:2px solid #f4a012; box-shadow:0 8px 25px rgba(0,0,0,0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <h3 style="margin: 0; color: #f4a012; font-size: 18px;">Edit Text</h3>
              <button id="textModalClose" style="background: none; border: none; color: #f4a012; cursor: pointer; font-size: 20px; padding: 0;">—</button>
            </div>
            <div id="textPreview" style="min-height: 30px; max-height: 120px; padding: 8px; border: 1px solid #555; border-radius: 4px; background: #444; text-align: center; font-size: 12px; color: #ccc; margin-bottom: 1rem; overflow-y: auto; word-wrap: break-word;">
              <span style="color: #888;">Preview...</span>
            </div>
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; color: #f4a012; font-weight: bold; font-size: 14px;">Text:</label>
              <textarea id="textInput" placeholder="Enter text..." style="resize: none; overflow: hidden; min-height: 35px; max-height: 30vh; width: 100%; border: 1px solid #555; padding: 8px; border-radius: 4px; background: #444; color: #fff; font-size: 14px;"></textarea>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem; margin-bottom: 1rem;">
              <div>
                <label style="display: block; margin-bottom: 0.25rem; color: #f4a012; font-weight: bold; font-size: 12px;">Color:</label>
                <input type="color" id="modalFontColor" value="#ffffff" title="Text Color" style="width: 60px; height: 24px; border: 1px solid #555; border-radius: 4px;">
              </div>
              <div>
                <label style="display: block; margin-bottom: 0.25rem; color: #f4a012; font-weight: bold; font-size: 12px;">Font:</label>
                <select id="modalFont" style="width: 100%; padding: 6px; border: 1px solid #555; border-radius: 4px; background: #444; color: #fff; font-size: 12px;">
                  <option value="Arial">Arial</option>
                  <option value="Helvetica">Helvetica</option>
                  <option value="Times New Roman">Times New Roman</option>
                  <option value="Georgia">Georgia</option>
                  <option value="Verdana">Verdana</option>
                  <option value="Impact">Impact</option>
                  <option value="Comic Sans MS">Comic Sans MS</option>
                  <option value="Courier New">Courier New</option>
                  <option value="Lucida Console">Lucida Console</option>
                  <option value="Tahoma">Tahoma</option>
                  <option value="Trebuchet MS">Trebuchet MS</option>
                  <option value="Arial Black">Arial Black</option>
                  <option value="Bookman Old Style">Bookman Old Style</option>
                  <option value="Garamond">Garamond</option>
                  <option value="Palatino">Palatino</option>
                  <option value="Century Gothic">Century Gothic</option>
                  <option value="Avant Garde">Avant Garde</option>
                  <option value="Brush Script MT">Brush Script MT</option>
                  <option value="Lucida Handwriting">Lucida Handwriting</option>
                </select>
              </div>
              <div>
                <label style="display: block; margin-bottom: 0.25rem; color: #f4a012; font-weight: bold; font-size: 12px;">Size:</label>
                <div style="display: flex; gap: 0.25rem;">
                  <select id="modalFontSizeDropdown" style="flex: 1; padding: 6px; border: 1px solid #555; border-radius: 4px; background: #444; color: #fff; font-size: 12px;">
                    <option value="8">8px</option>
                    <option value="10">10px</option>
                    <option value="12">12px</option>
                    <option value="14">14px</option>
                    <option value="16">16px</option>
                    <option value="18">18px</option>
                    <option value="20">20px</option>
                    <option value="24">24px</option>
                    <option value="28">28px</option>
                    <option value="32">32px</option>
                    <option value="36">36px</option>
                    <option value="40">40px</option>
                    <option value="45" selected>45px</option>
                    <option value="48">48px</option>
                    <option value="54">54px</option>
                    <option value="60">60px</option>
                    <option value="72">72px</option>
                    <option value="84">84px</option>
                    <option value="96">96px</option>
                    <option value="108">108px</option>
                    <option value="120">120px</option>
                    <option value="144">144px</option>
                    <option value="168">168px</option>
                    <option value="192">192px</option>
                    <option value="216">216px</option>
                    <option value="240">240px</option>
                    <option value="288">288px</option>
                    <option value="336">336px</option>
                    <option value="384">384px</option>
                    <option value="432">432px</option>
                    <option value="480">480px</option>
                  </select>
                  <input type="number" id="modalFontSizeInput" min="8" max="500" value="45" placeholder="Custom" style="flex: 1; padding: 6px; border: 1px solid #555; border-radius: 4px; background: #444; color: #fff; font-size: 12px;">
                </div>
              </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 1rem;">
              <div>
                <label style="display: block; margin-bottom: 0.25rem; color: #f4a012; font-weight: bold; font-size: 12px;">Style:</label>
                <div style="display: flex; gap: 0.25rem;">
                  <button id="modalBold" style="flex: 1; padding: 4px 8px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 3px; cursor: pointer; font-size: 11px;">Bold</button>
                  <button id="modalItalic" style="flex: 1; padding: 4px 8px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 3px; cursor: pointer; font-size: 11px;">Italic</button>
                  <button id="modalUnderline" style="flex: 1; padding: 4px 8px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 3px; cursor: pointer; font-size: 11px;">Underline</button>
                </div>
              </div>
              <div>
                <label style="display: block; margin-bottom: 0.25rem; color: #f4a012; font-weight: bold; font-size: 12px;">Alignment:</label>
                <div style="display: flex; gap: 0.25rem;">
                  <button id="modalAlignLeft" style="flex: 1; padding: 4px 8px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 3px; cursor: pointer; font-size: 11px;">Left</button>
                  <button id="modalAlignCenter" style="flex: 1; padding: 4px 8px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 3px; cursor: pointer; font-size: 11px;">Center</button>
                  <button id="modalAlignRight" style="flex: 1; padding: 4px 8px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 3px; cursor: pointer; font-size: 11px;">Right</button>
                </div>
              </div>
            </div>
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.25rem; color: #f4a012; font-weight: bold; font-size: 12px;">Background:</label>
              <div style="display: flex; gap: 0.25rem; align-items: center;">
                <input type="color" id="modalBackgroundColor" value="#000000" title="Background Color" style="width: 60px; height: 24px; border: 1px solid #555; border-radius: 4px;">
                <button id="modalBackgroundTransparent" style="padding: 4px 8px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 4px; cursor: pointer; font-size: 10px;">None</button>
              </div>
            </div>
            <div style="margin-bottom: 1rem;">
              <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                <input type="checkbox" id="modalStrokeEnabled" style="width: 16px; height: 16px; accent-color: #f4a012;">
                <label for="modalStrokeEnabled" style="color: #f4a012; font-weight: bold; font-size: 12px; cursor: pointer;">Stroke:</label>
              </div>
              <div id="strokeControls" style="display: none;">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; color: #ccc; font-size: 11px;">Color:</label>
                    <input type="color" id="modalStrokeColor" value="#000000" title="Stroke Color" style="width: 60px; height: 24px; border: 1px solid #555; border-radius: 4px;">
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; color: #ccc; font-size: 11px;">Width:</label>
                    <input type="range" id="modalStrokeWidth" min="0" max="20" value="2" step="0.5" style="width: 100%; height: 6px; border-radius: 3px; background: #444; outline: none; cursor: pointer;">
                    <div style="display: flex; justify-content: space-between; margin-top: 2px;">
                      <span style="font-size: 9px; color: #999;">0px</span>
                      <span id="strokeWidthValue" style="font-size: 9px; color: #f4a012; font-weight: bold;">2px</span>
                      <span style="font-size: 9px; color: #999;">20px</span>
                    </div>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; color: #ccc; font-size: 11px;">Position:</label>
                    <div style="display: flex; gap: 0.25rem;">
                      <button id="strokeOuter" class="stroke-position-btn" data-position="outer" style="flex: 1; padding: 3px 6px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 3px; cursor: pointer; font-size: 10px;">Outer</button>
                      <button id="strokeCenter" class="stroke-position-btn active" data-position="center" style="flex: 1; padding: 3px 6px; border: 1px solid #555; background: #f4a012; color: #fff; border-radius: 3px; cursor: pointer; font-size: 10px;">Center</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div style="margin-bottom: 1rem;">
              <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                <input type="checkbox" id="modalShadowEnabled" style="width: 16px; height: 16px; accent-color: #f4a012;">
                <label for="modalShadowEnabled" style="color: #f4a012; font-weight: bold; font-size: 12px; cursor: pointer;">Shadow:</label>
              </div>
              <div id="shadowControls" style="display: none;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; color: #ccc; font-size: 11px;">Color:</label>
                    <input type="color" id="modalShadowColor" value="#000000" title="Shadow Color" style="width: 60px; height: 24px; border: 1px solid #555; border-radius: 4px;">
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; color: #ccc; font-size: 11px;">Distance:</label>
                    <input type="range" id="modalShadowDistance" min="0" max="20" value="2" step="1" style="width: 100%; height: 6px; border-radius: 3px; background: #444; outline: none; cursor: pointer;">
                    <div style="display: flex; justify-content: space-between; margin-top: 2px;">
                      <span style="font-size: 9px; color: #999;">0px</span>
                      <span id="shadowDistanceValue" style="font-size: 9px; color: #f4a012; font-weight: bold;">2px</span>
                      <span style="font-size: 9px; color: #999;">20px</span>
                    </div>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; color: #ccc; font-size: 11px;">Direction:</label>
                    <div style="position: relative; width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; flex-direction: column;">
                      <canvas id="shadowDirectionCanvas" width="60" height="60" style="border: 1px solid #555; border-radius: 50%; background: #333; cursor: pointer;"></canvas>
                      <div id="shadowDirectionLabel" style="position: absolute; top: -20px; left: 50%; transform: translateX(-50%); font-size: 9px; color: #f4a012; font-weight: bold; white-space: nowrap;">Bottom Right</div>
                      <div id="shadowDirectionDegrees" style="margin-top: 5px; font-size: 10px; color: #ccc; font-weight: bold;">45°</div>
                    </div>
                  </div>
                  <div>
                    <label style="display: block; margin-bottom: 0.25rem; color: #ccc; font-size: 11px;">Blur:</label>
                    <input type="range" id="modalShadowBlur" min="0" max="20" value="4" step="1" style="width: 100%; height: 6px; border-radius: 3px; background: #444; outline: none; cursor: pointer;">
                    <div style="display: flex; justify-content: space-between; margin-top: 2px;">
                      <span style="font-size: 9px; color: #999;">0px</span>
                      <span id="shadowBlurValue" style="font-size: 9px; color: #f4a012; font-weight: bold;">4px</span>
                      <span style="font-size: 9px; color: #999;">20px</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div style="text-align: center; margin-top: 1.5rem;">
              <button id="modalApply" style="padding: 8px 16px; margin-right: 0.75rem; border: none; background: #f4a012; color: white; border-radius: 4px; cursor: pointer; font-size: 14px;">Apply</button>
              <button id="modalCancel" style="padding: 8px 16px; border: 1px solid #555; background: #444; color: #fff; border-radius: 4px; cursor: pointer; font-size: 14px;">Cancel</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        
        // Prevent keyboard events from bubbling up to the canvas when modal is open
        modal.addEventListener('keydown', (e) => {
          e.stopPropagation();
        });
        
        modal.addEventListener('keyup', (e) => {
          e.stopPropagation();
        });
      }
      
      // Set values
      const textInput = modal.querySelector('#textInput');
      const fontSel = modal.querySelector('#modalFont');
      const fontSizeDropdown = modal.querySelector('#modalFontSizeDropdown');
      const fontSizeInput = modal.querySelector('#modalFontSizeInput');
      const fontColor = modal.querySelector('#modalFontColor');
      
      const backgroundColor = modal.querySelector('#modalBackgroundColor');
      const backgroundTransparent = modal.querySelector('#modalBackgroundTransparent');
      const shadowColor = modal.querySelector('#modalShadowColor');
      const shadowTransparent = modal.querySelector('#modalShadowTransparent');
      const shadowDistance = modal.querySelector('#modalShadowDistance');
      const shadowDistanceValue = modal.querySelector('#shadowDistanceValue');
      const shadowBlur = modal.querySelector('#modalShadowBlur');
      const shadowBlurValue = modal.querySelector('#shadowBlurValue');
      const shadowDirectionCanvas = modal.querySelector('#shadowDirectionCanvas');
      const shadowDirectionLabel = modal.querySelector('#shadowDirectionLabel');
      const shadowDirectionDegrees = modal.querySelector('#shadowDirectionDegrees');
      const shadowEnabled = modal.querySelector('#modalShadowEnabled');
      const shadowControls = modal.querySelector('#shadowControls');
      const strokeEnabled = modal.querySelector('#modalStrokeEnabled');
      const strokeColor = modal.querySelector('#modalStrokeColor');
      const strokeWidth = modal.querySelector('#modalStrokeWidth');
      const strokeControls = modal.querySelector('#strokeControls');
      const strokeWidthValue = modal.querySelector('#strokeWidthValue');
      const strokePositionBtns = modal.querySelectorAll('.stroke-position-btn');
      let bold = false, italic = false, underline = false, align = 'center';
      let strokePosition = 'center';
      
      if (obj) {
        // Handle empty text objects - restore them if they have placeholder text
        let textContent = obj.text;
        if (textContent === ' ' || textContent === '') {
          textContent = '';
          // Ensure the object is visible and selectable
          obj.set('selectable', true);
          obj.set('evented', true);
          obj.set('visible', true);
        }
        
        textInput.value = textContent;
        fontSel.value = obj.fontFamily;
        
        // Get the current font size from the object (respects manual resizing)
        // When text is manually resized, Fabric.js scales the object rather than changing fontSize
        const scaleX = obj.scaleX || 1;
        const scaleY = obj.scaleY || 1;
        const baseFontSize = obj.fontSize || 45;
        const currentFontSize = Math.round(baseFontSize * Math.max(scaleX, scaleY));
        
        // Handle dual font size controls based on remembered state
        if (lastModalState.fontSizeMode === 'dropdown') {
          fontSizeDropdown.value = currentFontSize;
          fontSizeInput.value = currentFontSize;
        } else {
          fontSizeInput.value = currentFontSize;
          fontSizeDropdown.value = currentFontSize;
        }
        
        fontColor.value = obj.fill;
        bold = obj.fontWeight === 'bold';
        italic = obj.fontStyle === 'italic';
        underline = !!obj.underline;
        align = obj.textAlign || 'center';
        
        // Use remembered state for stroke properties
        strokeEnabled.checked = lastModalState.strokeEnabled;
        strokeControls.style.display = lastModalState.strokeEnabled ? 'block' : 'none';
        strokeColor.value = lastModalState.strokeColor;
        strokeWidth.value = lastModalState.strokeWidth;
        strokeWidthValue.textContent = lastModalState.strokeWidth + 'px';
        
        // Use remembered state for shadow properties
        shadowEnabled.checked = lastModalState.shadowEnabled;
        shadowControls.style.display = lastModalState.shadowEnabled ? 'block' : 'none';
        
        // Use remembered stroke position
        strokePosition = lastModalState.strokePosition;
        
        // Handle new text properties
        backgroundColor.value = lastModalState.backgroundColor;
        shadowColor.value = lastModalState.shadowColor;
        shadowDistance.value = lastModalState.shadowDistance;
        shadowDistanceValue.textContent = lastModalState.shadowDistance + 'px';
        shadowBlur.value = lastModalState.shadowBlur;
        shadowBlurValue.textContent = lastModalState.shadowBlur + 'px';
        
        // Preserve shadow direction angle
        shadowDirectionAngle = lastModalState.shadowDirectionAngle || 45;
        
        editingTextObj = obj;
        
        // Initialize shadow direction canvas
        drawShadowDirectionCanvas();
        updateShadowDirectionLabel();
        
        // Update stroke position buttons to reflect current state
        updateStrokePositionButtons();
      } else {
        textInput.value = '';
        fontSel.value = 'Arial';
        
        // Handle dual font size controls for new text
        const defaultSize = lastModalState.fontSizeValue || 45;
        if (lastModalState.fontSizeMode === 'dropdown') {
          fontSizeDropdown.value = defaultSize;
          fontSizeInput.value = defaultSize;
        } else {
          fontSizeInput.value = defaultSize;
          fontSizeDropdown.value = defaultSize;
        }
        
        fontColor.value = '#ffffff';
        bold = italic = underline = false;
        align = 'center';
        
        // Reset stroke properties to defaults for new text
        strokeEnabled.checked = false;
        strokeControls.style.display = 'none';
        strokeColor.value = '#000000';
        strokeWidth.value = 2;
        strokeWidthValue.textContent = '2px';
        strokePosition = 'center';
        
        // Reset shadow properties to defaults for new text
        shadowEnabled.checked = false;
        shadowControls.style.display = 'none';
        
        // Reset other properties to defaults for new text
        backgroundColor.value = '#000000';
        shadowColor.value = '#000000';
        shadowDistance.value = 2;
        shadowDistanceValue.textContent = '2px';
        shadowDirectionAngle = 45;
        shadowBlur.value = 4;
        shadowBlurValue.textContent = '4px';
        
        editingTextObj = null;
        
        // Initialize shadow direction canvas
        drawShadowDirectionCanvas();
        updateShadowDirectionLabel();
        
        // Update stroke position buttons to reflect default state
        updateStrokePositionButtons();
      }
      
      // Button states
      function updateBtnStates() {
        const boldBtn = modal.querySelector('#modalBold');
        const italicBtn = modal.querySelector('#modalItalic');
        const underlineBtn = modal.querySelector('#modalUnderline');
        const leftBtn = modal.querySelector('#modalAlignLeft');
        const centerBtn = modal.querySelector('#modalAlignCenter');
        const rightBtn = modal.querySelector('#modalAlignRight');
        
        // Update bold button
        boldBtn.style.background = bold ? '#f4a012' : '#444';
        boldBtn.style.color = bold ? '#fff' : '#ccc';
        boldBtn.style.borderColor = bold ? '#f4a012' : '#555';
        
        // Update italic button
        italicBtn.style.background = italic ? '#f4a012' : '#444';
        italicBtn.style.color = italic ? '#fff' : '#ccc';
        italicBtn.style.borderColor = italic ? '#f4a012' : '#555';
        
        // Update underline button
        underlineBtn.style.background = underline ? '#f4a012' : '#444';
        underlineBtn.style.color = underline ? '#fff' : '#ccc';
        underlineBtn.style.borderColor = underline ? '#f4a012' : '#555';
        
        // Update alignment buttons
        leftBtn.style.background = align === 'left' ? '#f4a012' : '#444';
        leftBtn.style.color = align === 'left' ? '#fff' : '#ccc';
        leftBtn.style.borderColor = align === 'left' ? '#f4a012' : '#555';
        
        centerBtn.style.background = align === 'center' ? '#f4a012' : '#444';
        centerBtn.style.color = align === 'center' ? '#fff' : '#ccc';
        centerBtn.style.borderColor = align === 'center' ? '#f4a012' : '#555';
        
        rightBtn.style.background = align === 'right' ? '#f4a012' : '#444';
        rightBtn.style.color = align === 'right' ? '#fff' : '#ccc';
        rightBtn.style.borderColor = align === 'right' ? '#f4a012' : '#555';
      }
      updateBtnStates();
      
      // Button events
      modal.querySelector('#modalBold').onclick = () => { bold = !bold; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalItalic').onclick = () => { italic = !italic; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalUnderline').onclick = () => { underline = !underline; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalAlignLeft').onclick = () => { align = 'left'; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalAlignCenter').onclick = () => { align = 'center'; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalAlignRight').onclick = () => { align = 'right'; updateBtnStates(); updateTextPreview(); };
      
      // Stroke control events
      strokeEnabled.onchange = () => {
        strokeControls.style.display = strokeEnabled.checked ? 'block' : 'none';
        updateTextPreview();
      };
      
      // Shadow control events
      shadowEnabled.onchange = () => {
        shadowControls.style.display = shadowEnabled.checked ? 'block' : 'none';
        updateTextPreview();
      };
      
      strokeColor.oninput = updateTextPreview;
      strokeWidth.oninput = () => {
        strokeWidthValue.textContent = strokeWidth.value + 'px';
        updateTextPreview();
      };
      
      // Dual font size control events
      fontSizeDropdown.onchange = () => {
        const size = parseInt(fontSizeDropdown.value);
        fontSizeInput.value = size;
        lastModalState.fontSizeMode = 'dropdown';
        lastModalState.fontSizeValue = size;
        updateTextPreview();
      };
      
      fontSizeInput.oninput = () => {
        const size = parseInt(fontSizeInput.value);
        if (size >= 8 && size <= 500) {
          fontSizeDropdown.value = size;
          lastModalState.fontSizeMode = 'input';
          lastModalState.fontSizeValue = size;
          updateTextPreview();
        }
      };
      
      // Stroke position button events
      strokePositionBtns.forEach(btn => {
        btn.onclick = () => {
          const oldPosition = strokePosition;
          strokePosition = btn.dataset.position;
          
          // Debug: Log stroke position change
          if (editingTextObj) {
            const currentScaleX = editingTextObj.scaleX || 1;
            const currentScaleY = editingTextObj.scaleY || 1;
            const hasDistortion = currentScaleX !== 1 || currentScaleY !== 1;
            console.log('Stroke position changed:', { 
              from: oldPosition, 
              to: strokePosition, 
              hasDistortion: hasDistortion,
              scaleX: currentScaleX,
              scaleY: currentScaleY
            });
          }
          
          updateStrokePositionButtons();
          updateTextPreview();
        };
      });
      
      // New text property events
      
      
      backgroundColor.oninput = updateTextPreview;
      shadowColor.oninput = updateTextPreview;
      
      // Shadow direction canvas interaction
      shadowDirectionCanvas.addEventListener('mousedown', (e) => {
        const rect = shadowDirectionCanvas.getBoundingClientRect();
        const centerX = shadowDirectionCanvas.width / 2;
        const centerY = shadowDirectionCanvas.height / 2;
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Calculate angle from center to mouse
        const deltaX = mouseX - centerX;
        const deltaY = mouseY - centerY;
        shadowDirectionAngle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
        
        // Keep angle positive (0-360)
        if (shadowDirectionAngle < 0) {
          shadowDirectionAngle += 360;
        }
        
        drawShadowDirectionCanvas();
        updateShadowDirectionLabel();
        updateTextPreview();
      });
      
      shadowDirectionCanvas.addEventListener('mousemove', (e) => {
        if (e.buttons === 1) { // Left mouse button pressed
          const rect = shadowDirectionCanvas.getBoundingClientRect();
          const centerX = shadowDirectionCanvas.width / 2;
          const centerY = shadowDirectionCanvas.height / 2;
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Calculate angle from center to mouse
          const deltaX = mouseX - centerX;
          const deltaY = mouseY - centerY;
          shadowDirectionAngle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
          
          // Keep angle positive (0-360)
          if (shadowDirectionAngle < 0) {
            shadowDirectionAngle += 360;
          }
          
          drawShadowDirectionCanvas();
          updateShadowDirectionLabel();
          updateTextPreview();
        }
      });
      
      // Transparent button events
      if (backgroundTransparent) {
        backgroundTransparent.onclick = () => {
          backgroundColor.value = '#000000';
          updateTextPreview();
        };
      }
      
      if (shadowTransparent) {
        shadowTransparent.onclick = () => {
          shadowColor.value = '#000000';
          updateTextPreview();
        };
      }
      
      // Shadow control events
      shadowDistance.oninput = () => {
        shadowDistanceValue.textContent = shadowDistance.value + 'px';
        updateTextPreview();
      };
      
      shadowBlur.oninput = () => {
        shadowBlurValue.textContent = shadowBlur.value + 'px';
        updateTextPreview();
      };
      
      // Function to update stroke position button states
      function updateStrokePositionButtons() {
        strokePositionBtns.forEach(btn => {
          const isActive = btn.dataset.position === strokePosition;
          btn.style.background = isActive ? '#f4a012' : '#444';
          btn.style.color = isActive ? '#fff' : '#ccc';
          btn.style.borderColor = isActive ? '#f4a012' : '#555';
        });
      }
      
      // Apply
      modal.querySelector('#modalApply').onclick = function() {
        // Save current state for next time
        lastModalState = {
          strokeEnabled: strokeEnabled.checked,
          strokeColor: strokeColor.value,
          strokeWidth: parseFloat(strokeWidth.value),
          strokePosition: strokePosition,
          shadowEnabled: shadowEnabled.checked,
          shadowColor: shadowColor.value,
          shadowDistance: parseInt(shadowDistance.value),
          shadowDirectionAngle: shadowDirectionAngle,
          shadowBlur: parseInt(shadowBlur.value),
          backgroundColor: backgroundColor.value,
          fontSizeMode: lastModalState.fontSizeMode || 'dropdown',
          fontSizeValue: parseInt(fontSizeInput.value)
        };
        
        const opts = {
          fontFamily: fontSel.value,
          fontSize: parseInt(fontSizeInput.value, 10),
          fill: fontColor.value,
          fontWeight: bold ? 'bold' : 'normal',
          fontStyle: italic ? 'italic' : 'normal',
          underline: underline,
          textAlign: align,
          backgroundColor: backgroundColor.value === '#000000' ? null : backgroundColor.value,
          shadow: shadowEnabled.checked ? {
            color: shadowColor.value,
            blur: parseInt(shadowBlur.value),
            offsetX: getShadowOffsetX(shadowDirectionAngle, parseInt(shadowDistance.value)),
            offsetY: getShadowOffsetY(shadowDirectionAngle, parseInt(shadowDistance.value))
          } : null,
          stroke: strokeEnabled.checked ? strokeColor.value : 'transparent',
          strokeWidth: strokeEnabled.checked ? parseFloat(strokeWidth.value) : 0,
          strokePosition: strokeEnabled.checked ? strokePosition : 'outer'
        };
        
        // Debug: Log opts construction
        console.log('Apply button - opts construction:', {
          strokeEnabled: strokeEnabled.checked,
          strokePosition: strokePosition,
          finalStrokePosition: opts.strokePosition,
          hasDistortion: editingTextObj ? (editingTextObj.scaleX !== 1 || editingTextObj.scaleY !== 1) : false
        });
        
        if (editingTextObj) {
          // For existing text, preserve position and distortion
          const text = textInput.value.trim();
          const finalText = text === '' ? ' ' : text;
          const finalFill = text === '' ? 'transparent' : fontColor.value;
          
          // Preserve the current distortion (scale) if it exists
          const currentScaleX = editingTextObj.scaleX || 1;
          const currentScaleY = editingTextObj.scaleY || 1;
          const hasDistortion = currentScaleX !== 1 || currentScaleY !== 1;
          
          // Debug: Log distortion preservation
          if (hasDistortion) {
            console.log('Preserving distortion:', { scaleX: currentScaleX, scaleY: currentScaleY });
          }
          
          // Ensure the text object doesn't get removed when empty
          editingTextObj.set({ 
            ...opts, 
            text: finalText,
            fill: finalFill,
            scaleX: hasDistortion ? currentScaleX : 1,
            scaleY: hasDistortion ? currentScaleY : 1,
            selectable: true,
            evented: true
          });
          
          // Force the object to stay on canvas and ensure it's visible
          if (!deskPadModalCanvas.contains(editingTextObj)) {
            deskPadModalCanvas.add(editingTextObj);
          }
          
          // Ensure the text object is properly positioned and visible
          editingTextObj.setCoords();
          editingTextObj.dirty = true;
          
          // Prevent the object from being removed when text is empty
          if (finalText === ' ') {
            editingTextObj.set('selectable', true);
            editingTextObj.set('evented', true);
            editingTextObj.set('visible', true);
          }
          

          
          // Force immediate re-render to see changes
          editingTextObj.dirty = true;
          editingTextObj.setCoords();
          
          // Check if we need to convert text type
          const needsStrokeText = strokeEnabled.checked && strokePosition === 'outer';
          const isCurrentlyStrokeText = editingTextObj instanceof fabric.StrokeText;
          
          if (needsStrokeText && !isCurrentlyStrokeText) {
            // Convert from IText to StrokeText
            console.log('Converting IText to StrokeText, preserving distortion:', hasDistortion);
            const newText = new fabric.StrokeText(finalText, {
              ...opts,
              fill: finalFill,
              left: editingTextObj.left,
              top: editingTextObj.top,
              originX: editingTextObj.originX,
              originY: editingTextObj.originY,
              scaleX: hasDistortion ? currentScaleX : 1,
              scaleY: hasDistortion ? currentScaleY : 1,
              angle: editingTextObj.angle || 0,
              flipX: editingTextObj.flipX || false,
              flipY: editingTextObj.flipY || false,
              strokePosition: strokePosition,
              selectable: true,
              evented: true,
              editable: false
            });
            
            const index = deskPadModalCanvas.getObjects().indexOf(editingTextObj);
            deskPadModalCanvas.remove(editingTextObj);
            deskPadModalCanvas.insertAt(newText, index);
            deskPadModalCanvas.setActiveObject(newText);
            
            // Update layer reference
            const layer = layers.find(l => l.object === editingTextObj);
            if (layer) {
              layer.object = newText;
            }
            
            editingTextObj = newText;
          } else if (!needsStrokeText && isCurrentlyStrokeText) {
            // Convert from StrokeText to IText
            console.log('Converting StrokeText to IText, preserving distortion:', hasDistortion);
            const newText = new fabric.IText(finalText, {
              ...opts,
              fill: finalFill,
              left: editingTextObj.left,
              top: editingTextObj.top,
              originX: editingTextObj.originX,
              originY: editingTextObj.originY,
              scaleX: hasDistortion ? currentScaleX : 1,
              scaleY: hasDistortion ? currentScaleY : 1,
              angle: editingTextObj.angle || 0,
              flipX: editingTextObj.flipX || false,
              flipY: editingTextObj.flipY || false,
              selectable: true,
              evented: true,
              editable: false
            });
            
            const index = deskPadModalCanvas.getObjects().indexOf(editingTextObj);
            deskPadModalCanvas.remove(editingTextObj);
            deskPadModalCanvas.insertAt(newText, index);
            deskPadModalCanvas.setActiveObject(newText);
            
            // Update layer reference
            const layer = layers.find(l => l.object === editingTextObj);
            if (layer) {
              layer.object = newText;
            }
            
                        editingTextObj = newText;
          }
          
          deskPadModalCanvas.requestRenderAll();
          
          // Force a more aggressive re-render for character spacing
          setTimeout(() => {
            deskPadModalCanvas.requestRenderAll();
          }, 10);
          
          // Update the layer name to reflect the new text content
          updateTextLayerName(editingTextObj);
          
          // Update the layers list to reflect any changes
          updateLayersList();
        } else {
          // For new text, set position to center
          const newTextOpts = {
            ...opts,
            left: deskPadModalCanvas.getWidth() / 2,
            top: deskPadModalCanvas.getHeight() / 2,
            originX: 'center',
            originY: 'center',
            textBaseline: 'alphabetic', // Fix for CanvasTextBaseline error
            scaleX: 1,
            scaleY: 1,
            selectable: true,
            evented: true,
            editable: false
          };
          

          
          // Create text object - use custom class for outer stroke only
          const text = textInput.value.trim();
          const finalText = text === '' ? ' ' : text;
          const finalFill = text === '' ? 'transparent' : fontColor.value;
          
          let t;
          if (strokeEnabled.checked && strokePosition === 'outer') {
            t = new fabric.StrokeText(finalText, { 
              ...newTextOpts, 
              fill: finalFill,
              strokePosition: 'outer' 
            });
          } else {
            t = new fabric.IText(finalText, { ...newTextOpts, fill: finalFill });
          }
          
          // Debug log removed since we're using manual spacing now
          

                      deskPadModalCanvas.add(t).setActiveObject(t);
            deskPadModalCanvas.requestRenderAll();
            
                    // Fix any textBaseline errors for the new text
        fixTextBaselineErrors();
        
        // Update the layer name to reflect the new text content
        updateTextLayerName(t);
          
          // Create a layer for this text
          const textName = `Text ${layers.length + 1}`;
          const layer = createLayer(textName, 'Text', t);
          
          // Set this as the active layer since the text is auto-selected
          activeLayerId = layer.id;
          updatePropertiesPanel(layer);
        }
        closeTextEditorModal();
      };
      
      modal.querySelector('#modalCancel').onclick = closeTextEditorModal;
      
      // Close button functionality
      modal.querySelector('#textModalClose').onclick = closeTextEditorModal;
      
      // Auto-expand textarea functionality
      function autoExpandTextarea() {
        textInput.style.height = 'auto';
        const scrollHeight = textInput.scrollHeight;
        const maxHeight = Math.min(window.innerHeight * 0.5, 300);
        textInput.style.height = Math.min(scrollHeight, maxHeight) + 'px';
      }
      
      // Update text preview functionality
      function updateTextPreview() {
        const preview = modal.querySelector('#textPreview');
        const text = textInput.value.trim();
        
        if (!text) {
          preview.innerHTML = '<span style="color: #888;">Preview...</span>';
          preview.style.height = '30px';
          return;
        }
        
        const previewText = document.createElement('div');
        // Handle line breaks by converting \n to <br> tags
        const processedText = text.replace(/\n/g, '<br>');
        previewText.innerHTML = text.length > 200 ? processedText.substring(0, 200) + '...' : processedText;
        previewText.style.fontFamily = fontSel.value;
        previewText.style.fontSize = Math.min(parseInt(fontSizeInput.value), 18) + 'px';
        previewText.style.color = fontColor.value;
        previewText.style.fontWeight = bold ? 'bold' : 'normal';
        previewText.style.fontStyle = italic ? 'italic' : 'normal';
        previewText.style.textDecoration = underline ? 'underline' : 'none';
        previewText.style.textAlign = align;
        previewText.style.display = 'block';
        previewText.style.width = '100%';
        previewText.style.overflow = 'hidden';
        previewText.style.wordWrap = 'break-word';

        
        // Background color
        if (backgroundColor.value !== '#000000') {
          previewText.style.backgroundColor = backgroundColor.value;
          previewText.style.padding = '4px 8px';
          previewText.style.borderRadius = '4px';
        }
        
        // Shadow (only if enabled and different from stroke)
        if (shadowEnabled.checked && (!strokeEnabled.checked || strokeColor.value !== shadowColor.value)) {
          previewText.style.textShadow = `${shadowDistance.value}px ${shadowDistance.value}px ${shadowBlur.value}px ${shadowColor.value}`;
        } else {
          previewText.style.textShadow = 'none';
        }
        
        preview.innerHTML = '';
        preview.appendChild(previewText);
        
        // Adjust preview height based on content
        const previewHeight = Math.min(Math.max(previewText.scrollHeight + 16, 30), 120);
        preview.style.height = previewHeight + 'px';
      }
      
      // Add event listeners for auto-expand and preview
      textInput.addEventListener('input', () => {
        autoExpandTextarea();
        updateTextPreview();
      });
      
      // Add event listeners for formatting changes
      fontSel.addEventListener('change', updateTextPreview);
      fontSizeDropdown.addEventListener('change', updateTextPreview);
      fontSizeInput.addEventListener('input', updateTextPreview);
      fontColor.addEventListener('input', updateTextPreview);
      textInput.addEventListener('keydown', autoExpandTextarea);
      
      // Add event listeners for new text properties
      
      backgroundColor.addEventListener('input', updateTextPreview);
      shadowColor.addEventListener('input', updateTextPreview);
      shadowDistance.addEventListener('input', updateTextPreview);
      shadowBlur.addEventListener('input', updateTextPreview);
      
      // Initial expand and preview
      setTimeout(() => {
        autoExpandTextarea();
        updateTextPreview();
      }, 10);
      
      // Fix any existing textBaseline errors before showing modal
      fixTextBaselineErrors();
      
      // Deselect any objects on the canvas to prevent keyboard shortcuts from affecting them
      if (deskPadModalCanvas) {
        deskPadModalCanvas.discardActiveObject();
        deskPadModalCanvas.requestRenderAll();
      }
      
      // Add a global event listener to prevent canvas keyboard events when modal is open
      const preventCanvasKeyboard = (e) => {
        if (modal.style.display === 'flex') {
          // Only prevent events from reaching the canvas, not the modal itself
          const target = e.target;
          if (!modal.contains(target)) {
            e.stopPropagation();
            e.preventDefault();
          }
        }
      };
      
      // Add the event listener to the document
      document.addEventListener('keydown', preventCanvasKeyboard, true);
      document.addEventListener('keyup', preventCanvasKeyboard, true);
      
      // Store the event listener so it can be removed when modal closes
      modal._preventCanvasKeyboard = preventCanvasKeyboard;
      
      modal.style.display = 'flex';
      textInput.focus();
    }
    
    function closeTextEditorModal() {
      const modal = document.getElementById('textEditorModal');
      if (modal) {
        modal.style.display = 'none';
        
        // Remove the global keyboard event listener
        if (modal._preventCanvasKeyboard) {
          document.removeEventListener('keydown', modal._preventCanvasKeyboard, true);
          document.removeEventListener('keyup', modal._preventCanvasKeyboard, true);
        }
      }
      editingTextObj = null;
    }

    // Font selection menu
    function showFontSelectionMenu() {
      // Create font selection popup if not exists
      let fontPopup = document.getElementById('font-selection-popup');
      if (!fontPopup) {
        fontPopup = document.createElement('div');
        fontPopup.id = 'font-selection-popup';
        fontPopup.className = 'shortcut-popup';
        fontPopup.style.cssText = 'position: absolute; left: 90px; top: 0; background: #333; border-radius: 8px; padding: 15px; min-width: 300px; max-width: 400px; max-height: 80vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: none;';
        
        // Font list with categories
        const fonts = [
          { category: 'Sans Serif', fonts: ['Arial', 'Helvetica', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Arial Black'] },
          { category: 'Serif', fonts: ['Times New Roman', 'Georgia', 'Garamond', 'Bookman Old Style', 'Palatino'] },
          { category: 'Display', fonts: ['Impact', 'Comic Sans MS', 'Brush Script MT', 'Lucida Handwriting'] },
          { category: 'Monospace', fonts: ['Courier New', 'Lucida Console'] }
        ];
        
        let fontOptionsHTML = '';
        fonts.forEach(category => {
          fontOptionsHTML += `<div class="font-category" style="margin-bottom: 15px;">
            <h4 style="color: #f4a012; margin-bottom: 8px; font-size: 14px; border-bottom: 1px solid #555; padding-bottom: 4px;">${category.category}</h4>`;
          
          category.fonts.forEach(font => {
            fontOptionsHTML += `
              <div class="font-option" data-font="${font}" style="
                padding: 8px 12px; 
                border: 1px solid #555; 
                border-radius: 4px; 
                background: #444; 
                cursor: pointer; 
                transition: all 0.2s;
                font-family: '${font}', sans-serif;
                margin-bottom: 5px;
              ">
                <div class="font-preview" style="
                  font-size: 16px; 
                  font-weight: bold; 
                  color: #fff; 
                  margin-bottom: 2px;
                  font-family: '${font}', sans-serif;
                ">${font}</div>
                <div class="font-sample" style="
                  font-size: 11px; 
                  color: #ccc;
                  font-family: '${font}', sans-serif;
                ">Sample text</div>
              </div>`;
          });
          
          fontOptionsHTML += `</div>`;
        });
        
        fontPopup.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="color: #f4a012; margin: 0; font-size: 16px;">Select Font</h3>
            <button id="font-popup-close" style="background: none; border: none; color: #f4a012; cursor: pointer; font-size: 18px; padding: 0;">—</button>
          </div>
          ${fontOptionsHTML}
        `;
        
        // Add to shortcut menu container
        const shortcutMenu = document.getElementById('shortcut-menu');
        if (shortcutMenu) {
          shortcutMenu.appendChild(fontPopup);
        } else {
          document.body.appendChild(fontPopup);
        }
        
        // Add click handlers for font options
        const fontOptions = fontPopup.querySelectorAll('.font-option');
        fontOptions.forEach(option => {
          option.addEventListener('click', function() {
            const selectedFont = this.dataset.font;
            hideFontSelectionMenu();
            addTextToCanvasWithFont(selectedFont);
          });
          
          // Hover effects
          option.addEventListener('mouseenter', function() {
            this.style.borderColor = '#f4a012';
            this.style.background = '#555';
          });
          
          option.addEventListener('mouseleave', function() {
            this.style.borderColor = '#555';
            this.style.background = '#444';
          });
        });
        
        // Close button
        fontPopup.querySelector('#font-popup-close').addEventListener('click', hideFontSelectionMenu);
      }
      
      // Show popup
      fontPopup.style.display = 'block';
    }
    
    function hideFontSelectionMenu() {
      const fontPopup = document.getElementById('font-selection-popup');
      if (fontPopup) {
        fontPopup.style.display = 'none';
      }
    }
    
    function closeFontSelectionMenu() {
      const fontModal = document.getElementById('fontSelectionModal');
      if (fontModal) {
        fontModal.style.display = 'none';
      }
    }
    
    // Add text to canvas with selected font
    function addTextToCanvasWithFont(fontFamily) {
      if (!deskPadModalCanvas) {
        console.error('Modal canvas not initialized');
        return;
      }
      
      // Calculate font size as 60% of canvas width
      const canvasWidth = deskPadModalCanvas.getWidth();
      const defaultFontSize = Math.floor(canvasWidth * 0.6 / 10); // 60% of width, divided by ~10 for reasonable text size
      
      // Create text object with selected font and large size
      const text = new fabric.IText('Double-click to edit', {
        left: deskPadModalCanvas.getWidth() / 2,
        top: deskPadModalCanvas.getHeight() / 2,
        fontFamily: fontFamily,
        fontSize: defaultFontSize,
        fill: '#ffffff',
        stroke: '#000000',
        strokeWidth: 1,
        originX: 'center',
        originY: 'center',
        textBaseline: 'alphabetic', // Fix for CanvasTextBaseline error
        selectable: true,
        evented: true,
        editable: false // We'll handle editing via modal
      });
      
      // Note: Removed real-time text change listener to prevent layer disappearance during editing
      // Layer names will be updated only when text modal is applied
      
      // Add to canvas
      deskPadModalCanvas.add(text);
      deskPadModalCanvas.setActiveObject(text);
      deskPadModalCanvas.requestRenderAll();
      
      // Create a layer for this text
      const textName = `Text ${layers.length + 1}`;
      const layer = createLayer(textName, 'Text', text);
      
      // Set this as the active layer since the text is auto-selected
      activeLayerId = layer.id;
      selectLayer(layer.id);
      updatePropertiesPanel(layer);
      
    }

    // Initialize shortcut menu functionality
    function initShortcutMenu() {
      // Add How To modal functionality
      const howToBtn = document.getElementById('shortcut-how-to');
      const howToModal = document.getElementById('how-to-modal');
      const howToClose = document.getElementById('how-to-close');
      
      if (howToBtn && howToModal) {
        howToBtn.addEventListener('click', function() {
          howToModal.style.display = 'block';
        });
      }
      
      if (howToClose && howToModal) {
        howToClose.addEventListener('click', function() {
          howToModal.style.display = 'none';
        });
      }
      
      // Close modal when clicking outside
      if (howToModal) {
        howToModal.addEventListener('click', function(e) {
          if (e.target === howToModal) {
            howToModal.style.display = 'none';
          }
        });
      }
      
      // Add Clear Canvas functionality
      const clearCanvasBtn = document.getElementById('shortcut-clear-canvas');
      if (clearCanvasBtn) {
        clearCanvasBtn.addEventListener('click', function() {
          if (confirm('Are you sure you want to clear the entire canvas? This action cannot be undone.')) {
            clearCanvas();
            
            // Clear any recent images or cached data if needed
            if (window.recentImages) {
              window.recentImages = [];
            }
          }
        });
      }
      
      const shortcutUpload = document.getElementById('shortcut-upload');
      const shortcutRecent = document.getElementById('shortcut-recent');
      const shortcutPadSize = document.getElementById('shortcut-pad-size');
      const shortcutAddText = document.getElementById('shortcut-add-text');
      const shortcutAddShapes = document.getElementById('shortcut-add-shapes');
      const recentPopup = document.getElementById('recent-images-popup');
      const recentPopupClose = document.getElementById('recent-popup-close');
      const padSizePopup = document.getElementById('pad-size-popup');
      const padSizePopupClose = document.getElementById('pad-size-popup-close');
      const addTextPopup = document.getElementById('add-text-popup');
      const addTextPopupClose = document.getElementById('add-text-popup-close');
      const addShapesPopup = document.getElementById('add-shapes-popup');
      const addShapesPopupClose = document.getElementById('add-shapes-popup-close');
      
      if (shortcutUpload) {
        shortcutUpload.addEventListener('click', function() {
          // Open file dialog directly (same as menu upload button)
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = 'image/*';
          fileInput.multiple = true;
          fileInput.style.display = 'none';
          document.body.appendChild(fileInput);
          
          fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
              handleModalFileUpload(e.target.files);
            }
            document.body.removeChild(fileInput);
          });
          
          fileInput.click();
        });
      }
      
      if (shortcutRecent) {
        shortcutRecent.addEventListener('click', function() {
          const recentPopup = document.getElementById('recent-images-popup');
          
          if (recentPopup && recentPopup.classList.contains('show')) {
            // Popup is open, close it
            hideRecentImagesPopup();
          } else {
            // Popup is closed, open it
            showRecentImagesPopup();
          }
        });
      }
      
      if (recentPopupClose) {
        recentPopupClose.addEventListener('click', function() {
          hideRecentImagesPopup();
        });
      }
      
      if (shortcutPadSize) {
        shortcutPadSize.addEventListener('click', function() {
          const padSizePopup = document.getElementById('pad-size-popup');
          
          if (padSizePopup && padSizePopup.classList.contains('show')) {
            // Popup is open, close it
            hidePadSizePopup();
          } else {
            // Popup is closed, open it
            showPadSizePopup();
          }
        });
      }
      
      if (padSizePopupClose) {
        padSizePopupClose.addEventListener('click', function() {
          hidePadSizePopup();
        });
      }
      
      if (shortcutAddText) {
        shortcutAddText.addEventListener('click', function() {
          // Show add text popup
          showAddTextPopup();
        });
      }
      
      if (addTextPopupClose) {
        addTextPopupClose.addEventListener('click', function() {
          hideAddTextPopup();
        });
      }

      // Add Shapes functionality
      if (shortcutAddShapes) {
        shortcutAddShapes.addEventListener('click', function() {
          showAddShapesPopup();
        });
      }

      if (addShapesPopupClose) {
        addShapesPopupClose.addEventListener('click', function() {
          hideAddShapesPopup();
        });
      }

      // Setup shape event listeners
      setupShapeEventListeners();
      
      // Close popup when clicking outside
      document.addEventListener('click', function(e) {
        if (recentPopup && recentPopup.classList.contains('show')) {
          if (!recentPopup.contains(e.target) && !shortcutRecent.contains(e.target)) {
            hideRecentImagesPopup();
          }
        }
        if (padSizePopup && padSizePopup.classList.contains('show')) {
          if (!padSizePopup.contains(e.target) && !shortcutPadSize.contains(e.target)) {
            hidePadSizePopup();
          }
        }
        if (addTextPopup && addTextPopup.classList.contains('show')) {
          if (!addTextPopup.contains(e.target) && !shortcutAddText.contains(e.target)) {
            hideAddTextPopup();
          }
        }
        
        // Close font selection popup when clicking outside
        const fontPopup = document.getElementById('font-selection-popup');
        if (fontPopup && fontPopup.style.display === 'block') {
          if (!fontPopup.contains(e.target) && !shortcutAddText.contains(e.target)) {
            hideFontSelectionMenu();
          }
        }
      });

      // Close popup when drag and drop occurs
      document.addEventListener('drop', function(e) {
        if (recentPopup && recentPopup.classList.contains('show')) {
          hideRecentImagesPopup();
        }
        if (padSizePopup && padSizePopup.classList.contains('show')) {
          hidePadSizePopup();
        }
        if (addTextPopup && addTextPopup.classList.contains('show')) {
          hideAddTextPopup();
        }
        
        // Close font selection popup when drag and drop occurs
        const fontPopup = document.getElementById('font-selection-popup');
        if (fontPopup && fontPopup.style.display === 'block') {
          hideFontSelectionMenu();
        }
      });
      
      // Add click-away functionality to close popups
      document.addEventListener('click', function(e) {
        // Check if click is on a quick bar button (don't close popups when clicking buttons)
        const quickBarButtons = [
          'shortcut-upload',
          'shortcut-recent', 
          'shortcut-pad-size',
          'shortcut-add-text',
          'shortcut-add-shapes',
          'shortcut-how-to',
          'shortcut-clear-canvas'
        ];
        
        let clickedOnQuickBarButton = false;
        quickBarButtons.forEach(buttonId => {
          const button = document.getElementById(buttonId);
          if (button && button.contains(e.target)) {
            clickedOnQuickBarButton = true;
          }
        });
        
        // If clicked on a quick bar button, don't close popups
        if (clickedOnQuickBarButton) {
          return;
        }
        
        // Check if click is outside any popup
        const popups = [
          'add-shapes-popup',
          'add-text-popup', 
          'recent-images-popup',
          'pad-size-popup'
        ];
        
        let clickedInsidePopup = false;
        popups.forEach(popupId => {
          const popup = document.getElementById(popupId);
          if (popup && popup.contains(e.target)) {
            clickedInsidePopup = true;
          }
        });
        
        // If clicked outside all popups, close them
        if (!clickedInsidePopup) {
          hideAllPopups();
        }
      });
      
    }

    // Show pad size popup
    function showPadSizePopup() {
      // Close other popups first
      hideAllPopups();
      
      const padSizePopup = document.getElementById('pad-size-popup');
      
      if (padSizePopup) {
        // Update active state
        updatePadSizeActiveState();
        
        // Update DPI display with current DPI
        const currentDPI = deskPadModalCanvas ? Math.round(deskPadModalCanvas.getWidth() / (deskPadModalCanvas.getWidth() / 100)) : 100;
        updatePadSizeDPIDisplay(currentDPI);
        
        // Show popup
        padSizePopup.classList.add('show');
        setupPadSizeEventListeners();
      }
    }

    // Hide pad size popup
    function hidePadSizePopup() {
      const padSizePopup = document.getElementById('pad-size-popup');
      if (padSizePopup) {
        padSizePopup.classList.remove('show');
      }
    }

    // Update active state in pad size popup
    function updatePadSizeActiveState() {
      const padSizeOptions = document.querySelectorAll('.pad-size-option');
      padSizeOptions.forEach(option => {
        option.classList.remove('active');
        if (option.dataset.preset === currentPreset) {
          option.classList.add('active');
        }
      });
    }

    // Setup pad size option event listeners
    function setupPadSizeEventListeners() {
      const padSizeOptions = document.querySelectorAll('.pad-size-option');
      padSizeOptions.forEach(option => {
        option.addEventListener('click', function() {
          const selectedPreset = this.dataset.preset;
          
          // Apply the selected preset
          applyAspectPreset(selectedPreset);
          
          // Close the popup
          hidePadSizePopup();
        });
      });
      
      // Setup DPI control event listeners
      setupDPIControlEventListeners();
    }
    
    // Setup DPI control event listeners
    function setupDPIControlEventListeners() {
      // DPI lock button click
      const dpiLockButton = document.getElementById('dpi-lock-button');
      if (dpiLockButton) {
        dpiLockButton.addEventListener('click', showDPISelectionModal);
      }
      
      // DPI modal close button
      const dpiModalClose = document.getElementById('dpi-modal-close');
      if (dpiModalClose) {
        dpiModalClose.addEventListener('click', hideDPISelectionModal);
      }
      
      // DPI modal cancel button
      const dpiModalCancel = document.getElementById('dpi-modal-cancel');
      if (dpiModalCancel) {
        dpiModalCancel.addEventListener('click', hideDPISelectionModal);
      }
      
      // DPI modal continue button
      const dpiModalContinue = document.getElementById('dpi-modal-continue');
      if (dpiModalContinue) {
        dpiModalContinue.addEventListener('click', applySelectedDPI);
      }
      
      // DPI option clicks
      const dpiOptions = document.querySelectorAll('.dpi-option');
      dpiOptions.forEach(option => {
        option.addEventListener('click', function() {
          // Remove selected class from all options
          dpiOptions.forEach(opt => opt.classList.remove('selected'));
          // Add selected class to clicked option
          this.classList.add('selected');
          // Enable continue button
          if (dpiModalContinue) {
            dpiModalContinue.disabled = false;
          }
        });
      });
      
      // Close modal on outside click
      const dpiModal = document.getElementById('dpi-selection-modal');
      if (dpiModal) {
        dpiModal.addEventListener('click', function(e) {
          if (e.target === this) {
            hideDPISelectionModal();
          }
        });
      }
    }
    
    // Show DPI selection modal
    function showDPISelectionModal() {
      const dpiModal = document.getElementById('dpi-selection-modal');
      if (dpiModal) {
        // Reset selection
        const dpiOptions = document.querySelectorAll('.dpi-option');
        dpiOptions.forEach(opt => opt.classList.remove('selected'));
        
        // Disable continue button until selection is made
        const dpiModalContinue = document.getElementById('dpi-modal-continue');
        if (dpiModalContinue) {
          dpiModalContinue.disabled = true;
        }
        
        dpiModal.classList.add('show');
      }
    }
    
    // Hide DPI selection modal
    function hideDPISelectionModal() {
      const dpiModal = document.getElementById('dpi-selection-modal');
      if (dpiModal) {
        dpiModal.classList.remove('show');
      }
    }
    
    // Apply selected DPI
    function applySelectedDPI() {
      const selectedOption = document.querySelector('.dpi-option.selected');
      if (selectedOption) {
        const selectedDPI = parseInt(selectedOption.dataset.dpi);
        
        // Calculate new canvas dimensions based on the current preset and new DPI
        const preset = aspectPresets[currentPreset];
        if (preset) {
          // Base dimensions are at 150 DPI, so scale relative to 150 DPI
          const dpiScale = selectedDPI / 150;
          const newCanvasWidth = Math.round(preset.w * dpiScale);
          const newCanvasHeight = Math.round(preset.h * dpiScale);
          
          // Update canvas DPI with new dimensions
          updateCanvasResolution(selectedDPI, newCanvasWidth, newCanvasHeight);
        } else {
          // Fallback: just update DPI without changing dimensions
          updateCanvasResolution(selectedDPI, deskPadModalCanvas.getWidth(), deskPadModalCanvas.getHeight());
        }
        
        // Update DPI display in pad size popup
        updatePadSizeDPIDisplay(selectedDPI);
        
        // Hide modal
        hideDPISelectionModal();
      }
    }
    
    // Update DPI display in pad size popup
    function updatePadSizeDPIDisplay(dpi) {
      const currentDpiDisplay = document.getElementById('current-dpi-display');
      if (currentDpiDisplay) {
        currentDpiDisplay.textContent = `${dpi} DPI`;
      }
    }

    // Show add text popup
    function showAddTextPopup() {
      // Close other popups first
      hideAllPopups();
      
      const addTextPopup = document.getElementById('add-text-popup');
      
      if (addTextPopup) {
        // Show popup
        addTextPopup.classList.add('show');
        setupFontEventListeners();
      }
    }

    // Hide add text popup
    function hideAddTextPopup() {
      const addTextPopup = document.getElementById('add-text-popup');
      if (addTextPopup) {
        addTextPopup.classList.remove('show');
      }
    }

    // Setup font option event listeners
    function setupFontEventListeners() {
      // Remove existing event listeners first to prevent duplicates
      const fontOptions = document.querySelectorAll('.font-option');
      fontOptions.forEach(option => {
        // Clone the element to remove all event listeners
        const newOption = option.cloneNode(true);
        option.parentNode.replaceChild(newOption, option);
        
        // Add new event listener
        newOption.addEventListener('click', function() {
          const selectedFont = this.dataset.font;
          
          // Add text to canvas with selected font
          addTextToCanvas(selectedFont);
          
          // Close the popup
          hideAddTextPopup();
        });
      });
    }

    // Add text to canvas with specified font
    function addTextToCanvas(fontFamily) {
      if (!deskPadModalCanvas) {
        console.error('Modal canvas not initialized');
        return;
      }
      
      // Create text object with large default size (60% of canvas width)
      const canvasWidth = deskPadModalCanvas.getWidth();
      const defaultFontSize = Math.floor(canvasWidth * 0.6 / 10); // 60% of width, divided by ~10 for reasonable text size
      
      const text = new fabric.IText('Double-click to edit', {
        left: deskPadModalCanvas.getWidth() / 2,
        top: deskPadModalCanvas.getHeight() / 2,
        fontFamily: fontFamily,
        fontSize: defaultFontSize,
        fill: '#ffffff',
        stroke: '#000000',
        strokeWidth: 1,
        originX: 'center',
        originY: 'center',
        textBaseline: 'alphabetic', // Fix for CanvasTextBaseline error
        selectable: true,
        evented: true,
        editable: false // We'll handle editing via modal
      });
      
      // Add to canvas
      deskPadModalCanvas.add(text);
      deskPadModalCanvas.setActiveObject(text);
      deskPadModalCanvas.requestRenderAll();
      
      // Create a layer for this text
      const textName = `Text ${layers.length + 1}`;
      const layer = createLayer(textName, 'Text', text);
      
      // Set this as the active layer since the text is auto-selected
      activeLayerId = layer.id;
      selectLayer(layer.id);
      updatePropertiesPanel(layer);
      
    }

    // Show recent images popup
    function showRecentImagesPopup() {
      // Close other popups first
      hideAllPopups();
      
      const recentPopup = document.getElementById('recent-images-popup');
      const recentPopupGrid = document.getElementById('recent-images-popup-grid');
      
      if (recentPopup && recentPopupGrid) {
        // Populate recent images
        populateRecentImagesPopup();
        
        // Show popup
        recentPopup.classList.add('show');
      }
    }

    // Hide recent images popup
    function hideRecentImagesPopup() {
      const recentPopup = document.getElementById('recent-images-popup');
      if (recentPopup) {
        recentPopup.classList.remove('show');
      }
    }

    // Populate recent images in popup
    function populateRecentImagesPopup() {
      const recentPopupGrid = document.getElementById('recent-images-popup-grid');
      
      if (!recentPopupGrid) return;
      
      // Clear existing content
      recentPopupGrid.innerHTML = '';
      
      // Get recent images (use the existing recentImages array)
      if (recentImages && recentImages.length > 0) {
        recentImages.forEach((imageData, index) => {
          const imageItem = document.createElement('div');
          imageItem.className = 'recent-image-item';
          imageItem.title = imageData.name || `Image ${index + 1}`;
          
          imageItem.innerHTML = `
            <img src="${imageData.url}" alt="${imageData.name || 'Recent image'}" class="recent-image-thumbnail">
            <div class="recent-image-name">${imageData.name || `Image ${index + 1}`}</div>
          `;
          
          // Add click handler to add image to canvas
          imageItem.addEventListener('click', function() {
            addImageToModalCanvas(imageData.url, imageData.name, 0);
            hideRecentImagesPopup();
          });
          
          recentPopupGrid.appendChild(imageItem);
        });
      } else {
        // Show empty state
        const emptyState = document.createElement('div');
        emptyState.style.cssText = 'grid-column: 1 / -1; text-align: center; color: #666; padding: 20px; font-size: 12px;';
        emptyState.textContent = 'No recent images';
        recentPopupGrid.appendChild(emptyState);
      }
    }

    // Auto-snap all images to current canvas edges
    function autoSnapAllImagesToEdges() {
      if (!deskPadModalCanvas) return;
      
      const allObjects = deskPadModalCanvas.getObjects();
      
      allObjects.forEach(obj => {
        if (obj.type === 'image') {
          applySimpleSnapping(obj);
        }
      });
      
      deskPadModalCanvas.requestRenderAll();
    }

    // Update canvas with current DPI-based snapping settings
    function updateAllObjectsSnappingSettings() {
      if (!deskPadModalCanvas) return;
      
      const dpiScale = currentDPI / 100;
      const scaledSnapThreshold = Math.round(30 * dpiScale); // Increased from 15 to 30
      const scaledSnapAngle = Math.round(30 * dpiScale); // Increased from 15 to 30
      
      const objects = deskPadModalCanvas.getObjects();

      
      // Update canvas-level snapping settings (these are the only ones that matter)
      deskPadModalCanvas.set({
        snapAngle: scaledSnapAngle,
        snapThreshold: scaledSnapThreshold,
        snapAngleThreshold: scaledSnapAngle
      });
      
      // Force a render to ensure settings are applied
      deskPadModalCanvas.requestRenderAll();
      
    }

    // Adaptive throttling for snapping - only throttle on very large canvases
    let lastSnapTime = 0;
    
    // Precise snapping that works with Fabric's selection border system
    function applySimpleSnapping(obj) {
      const canvas = deskPadModalCanvas;
      
      // Only throttle on very large canvases (>15M pixels) for better performance
      const totalPixels = canvas.getWidth() * canvas.getHeight();
      
      if (totalPixels > 15000000) { // 15 million pixels
        const now = Date.now();
        if (now - lastSnapTime < 8) { // ~120fps throttling only for large canvases
          return;
        }
        lastSnapTime = now;
      }
      const canvasWidth = canvas.getWidth();
      const canvasHeight = canvas.getHeight();
      
      // Scale snapping threshold with DPI to maintain consistent user experience
      // Base threshold is 25 pixels at 100 DPI, scales proportionally (increased from 10)
      const baseThreshold = 25;
      const dpiScale = currentDPI / 100;
      const snapThreshold = Math.round(baseThreshold * dpiScale);
      
      // Get object dimensions (accounting for scaling)
      const halfW = obj.getScaledWidth() / 2;
      const halfH = obj.getScaledHeight() / 2;
      
      // Calculate object edges (since objects are center-origin)
      const left = obj.left - halfW;
      const top = obj.top - halfH;
      const right = obj.left + halfW;
      const bottom = obj.top + halfH;
      
      let snapped = false;
      
      // Snap left edge to canvas left (pixel-perfect)
      if (Math.abs(left - 0) < snapThreshold) {
        obj.set('left', Math.round(halfW));
        snapped = true;
      }
      
      // Snap right edge to canvas right (pixel-perfect)
      if (Math.abs(right - canvasWidth) < snapThreshold) {
        obj.set('left', Math.round(canvasWidth - halfW));
        snapped = true;
      }
      
      // Snap top edge to canvas top (pixel-perfect)
      if (Math.abs(top - 0) < snapThreshold) {
        obj.set('top', Math.round(halfH));
        snapped = true;
      }
      
      // Snap bottom edge to canvas bottom (pixel-perfect)
      if (Math.abs(bottom - canvasHeight) < snapThreshold) {
        obj.set('top', Math.round(canvasHeight - halfH));
        snapped = true;
      }
      
      // Force integer positioning to avoid sub-pixel rendering
      if (snapped) {
        obj.set({
          left: Math.round(obj.left),
          top: Math.round(obj.top)
        });
        canvas.requestRenderAll();
      }
    }
    
    // Wrapper-based zoom functions (Photoshop-style Ctrl +/-)
    // store the "1—" size once, so you can reset or compute relative zooms
    let baseRect = null;
    let currentScale = 1;
    let fitToScreenScale = 1; // Store the scale that fits the canvas to screen

    function resizeCanvasDom(factor) {
      // factor: 1.0 = 100%, 1.2 = 120%, 0.8 = 80%, etc.
      const canvas = deskPadModalCanvas;
      const wrapper = canvas.wrapperEl;
      
      if (!baseRect) {
        baseRect = wrapper.getBoundingClientRect(); // original dimensions
      }
      
      wrapper.style.transformOrigin = 'center center';
      
      // Check if layers menu is open and combine transforms
      const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
      const layersMenuOpen = canvasContainer && canvasContainer.classList.contains('with-layers-menu');
      
      if (layersMenuOpen) {
        // Combine zoom scale with layers menu scale (0.85)
        const combinedScale = factor * 0.85;
        wrapper.style.transform = `scale(${combinedScale})`;
      } else {
        // Normal zoom only
        wrapper.style.transform = `scale(${factor})`;
      }

      // update your UI with percentage relative to fit-to-screen scale
      const zoomDisplay = document.getElementById('zoom-level');
      if (zoomDisplay) {
        // Calculate percentage relative to fit-to-screen scale
        // When factor = fitToScreenScale, it should show 100%
        const relativePercentage = Math.round((factor / fitToScreenScale) * 100);
        const clampedPercentage = Math.max(10, Math.min(300, relativePercentage)); // Cap at 300%, min 10%
        zoomDisplay.textContent = `${clampedPercentage}%`;
      }
      
      // you do NOT need to call canvas.setZoom or canvas.viewportTransform here
    }

    function canvasZoomIn() {
      currentScale = Math.min(3, currentScale * 1.2); // Cap at 300%
      resizeCanvasDom(currentScale);
    }

    function canvasZoomOut() {
      currentScale = Math.max(0.1, currentScale / 1.2); // Allow much lower zoom (10% of fit-to-screen)
      resizeCanvasDom(currentScale);
    }

    function canvasZoomFit() {
      // Calculate scale to fit canvas in viewport
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight - 60; // Account for toolbar
      const canvasWidth = deskPadModalCanvas.getWidth();
      const canvasHeight = deskPadModalCanvas.getHeight();
      
      // Calculate scale factors to fit in viewport with padding
      const scaleX = (viewportWidth * 0.9) / canvasWidth; // 90% of viewport width
      const scaleY = (viewportHeight * 0.9) / canvasHeight; // 90% of viewport height
      
      // Use the smaller scale to ensure canvas fits completely
      const fitScale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 100%
      
      // Store the fit-to-screen scale for percentage calculations
      fitToScreenScale = fitScale;
      currentScale = fitScale;
      resizeCanvasDom(currentScale);
      

    }
    
    // Fabric.js built-in snap settings (keeping for reference)
    function setupCanvasSnapping() {
    }

    // Update canvas size display
    function updateCanvasSizeDisplay(width, height) {
      const widthSpan = document.getElementById('canvas-width');
      const heightSpan = document.getElementById('canvas-height');
      if (widthSpan && heightSpan) {
        widthSpan.textContent = Math.round(width);
        heightSpan.textContent = Math.round(height);
      }
      
      // Also update any size info display
      const sizeInfoElement = document.getElementById('canvas-size-info');
      if (sizeInfoElement) {
        const aspectRatio = width / height;
        const is77to29 = Math.abs(aspectRatio - (77/29)) < 0.01;
        
        sizeInfoElement.innerHTML = `
          <strong>Canvas Size:</strong> ${Math.round(width)} — ${Math.round(height)}px<br>
          <strong>Aspect Ratio:</strong> ${aspectRatio.toFixed(3)} ${is77to29 ? '(77:29)' : ''}<br>
          <strong>Size Range:</strong> 1080p to 4K equivalent<br>
          <small>Images will scale to fit but won't upscale if too small</small>
        `;
      }
    }
    
    // Setup canvas resize handles
    function setupCanvasResizeHandles() {
      // Only target resize handles that are specifically for canvas resizing
      // Use a more specific selector to avoid conflicts with crop modal handles
      const handles = document.querySelectorAll('.canvas-resize-handle');
      handles.forEach(handle => {
        handle.addEventListener('mousedown', startResize);
      });
    }
    
    // Start resize operation
    function startResize(e) {
      // Check if we're in the crop modal context - if so, don't interfere
      if (e.target.closest('#crop-modal-cropbox') || e.target.closest('#crop-modal')) {
        return; // Let the crop modal handle its own resize
      }
      
      e.preventDefault();
      e.stopPropagation();
      
      const direction = e.target.dataset.direction;
      const startX = e.clientX;
      const startY = e.clientY;
      const startWidth = deskPadModalCanvas.getWidth();
      const startHeight = deskPadModalCanvas.getHeight();
      const aspectRatio = 77 / 29;
      
      
      function onMouseMove(e) {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        let newWidth = startWidth;
        let newHeight = startHeight;
        
        // Check if direction is defined before using it
        if (direction) {
          // Calculate new dimensions based on direction while maintaining aspect ratio
          if (direction.includes('e')) {
            newWidth = startWidth + deltaX;
          }
          if (direction.includes('w')) {
            newWidth = startWidth - deltaX;
          }
          if (direction.includes('s')) {
            newHeight = startHeight + deltaY;
          }
          if (direction.includes('n')) {
            newHeight = startHeight - deltaY;
          }
        } else {
          // Fallback: resize based on mouse movement without direction constraints
          newWidth = startWidth + deltaX;
          newHeight = startHeight + deltaY;
        }
        
        // Maintain aspect ratio
        if (direction && (direction.includes('e') || direction.includes('w'))) {
          newHeight = newWidth / aspectRatio;
        } else if (direction && (direction.includes('s') || direction.includes('n'))) {
          newWidth = newHeight * aspectRatio;
        } else {
          // For fallback case, maintain aspect ratio based on which dimension changed more
          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            newHeight = newWidth / aspectRatio;
          } else {
            newWidth = newHeight * aspectRatio;
          }
        }
        
        // Apply minimum and maximum constraints
        // Minimum: 1080p equivalent (1920x1080 scaled to 77:29 ratio)
        // Maximum: 4K equivalent (3840x2160 scaled to 77:29 ratio)
        const minWidth = 960; // Reasonable minimum for display
        const maxWidth = 2560; // Reasonable maximum for display
        const minHeight = Math.round(minWidth / aspectRatio); // ‰ 361px
        const maxHeight = Math.round(maxWidth / aspectRatio); // ‰ 964px
        
        newWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
        newHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));
        
        // Recalculate to maintain aspect ratio after constraints
        if (newWidth / newHeight > aspectRatio) {
          newHeight = newWidth / aspectRatio;
        } else {
          newWidth = newHeight * aspectRatio;
        }
        
        // Update canvas dimensions
        deskPadModalCanvas.setDimensions({
          width: newWidth,
          height: newHeight
        });
        
        // Update stored dimensions
        modalArtboardWidth = newWidth;
        modalArtboardHeight = newHeight;
        modalCanvasWidth = newWidth;
        modalCanvasHeight = newHeight;
        
        // Update background to match new canvas size
        updateCanvasBackground();
        
        // Border rectangle removed - no longer updating during resize
        
                  // Update size display
          updateCanvasSizeDisplay(newWidth, newHeight);
          

        
        // Re-render canvas
        deskPadModalCanvas.requestRenderAll();
      }
      
      function onMouseUp() {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        
        // Auto-snap all images to new canvas edges after manual resize
        autoSnapAllImagesToEdges();

      }
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    }
    
    // Fit canvas to viewport using wrapper scaling
    function fitCanvasToViewport() {
      if (!deskPadModalCanvas) return;
      
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight - 60;
      const canvasWidth = deskPadModalCanvas.getWidth();
      const canvasHeight = deskPadModalCanvas.getHeight();
      
      // Calculate zoom to fit canvas in viewport with padding
      const scaleX = (viewportWidth * 0.8) / canvasWidth;
      const scaleY = (viewportHeight * 0.8) / canvasHeight;
      const scale = Math.min(scaleX, scaleY, 1); // Don't zoom in beyond 100%
      
      // Use wrapper scaling instead of Fabric viewport zoom
      currentScale = scale;
      resizeCanvasDom(scale);
    }

    // Setup zoom and pan functionality for any canvas
    // This function provides Photoshop-style viewport zoom and pan for any Fabric.js canvas
    // Parameters:
    // - canvas: The Fabric.js canvas instance to add zoom/pan to
    function setupCanvasZoomAndPan(canvas) {
      if (!canvas) return;
      
      let isPanning = false;
      let lastPosX = 0;
      let lastPosY = 0;
      

      

      
      // Keyboard shortcuts (only for modal canvas to avoid conflicts)
      if (canvas === deskPadModalCanvas) {
        document.addEventListener('keydown', function(e) {
          if (!canvas) return;
          
          switch(e.key) {
            case '=':
            case '+':
              e.preventDefault();
              canvasZoomIn();
              break;
            case '-':
              e.preventDefault();
              canvasZoomOut();
              break;
            case '0':
              e.preventDefault();
              canvasZoomFit();
              break;
          }
        });
      }
      
      
      // Ensure canvas is always ready for object interaction
      canvas.selection = true;
      canvas.preserveObjectStacking = true;
      
      // Add zoom button event listeners (only for modal canvas)
      if (canvas === deskPadModalCanvas) {
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomFitBtn = document.getElementById('zoom-fit-btn');
        const zoomLevelSpan = document.getElementById('zoom-level');
        
        if (zoomInBtn) {
          zoomInBtn.addEventListener('click', function() {
            canvasZoomIn();
          });
        }
        
        if (zoomOutBtn) {
          zoomOutBtn.addEventListener('click', function() {
            canvasZoomOut();
          });
        }
        
        if (zoomFitBtn) {
          zoomFitBtn.addEventListener('click', function() {
            canvasZoomFit();
          });
        }
        
        // Zoom controls initialized successfully
      }
      
      // Test zoom functionality
      

      

      

      


      

      

      

       

       
       // Debug canvas objects and their interaction state

      

    }

    // Center view on safe area - let Flexbox handle centering
    function centerViewOnSafeArea() {
      if (!deskPadModalCanvas) return;
      
      // Reset zoom to 1
      deskPadModalCanvas.setZoom(1);
      deskPadModalCanvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
      
      // Reset CSS scaling
      const wrapper = deskPadModalCanvas.wrapperEl;
      wrapper.style.transformOrigin = 'center center';
      wrapper.style.transform = 'scale(1)';
      
      deskPadModalCanvas.requestRenderAll();
      

    }
    
    // Clear canvas function - properly handles all cleanup
    function clearCanvas() {
      if (!deskPadModalCanvas) return;
      
      const canvas = deskPadModalCanvas;
      
      // Remove all objects from canvas (images and text)
      const objects = canvas.getObjects();
      objects.forEach(obj => {
        canvas.remove(obj);
      });
      
      // Clear background
      if (backgroundRect) {
        canvas.remove(backgroundRect);
        backgroundRect = null;
      }
      
      // Reset background to transparent
      currentBackground.type = 'transparent';
      currentBackground.color = '#ffffff';
      
      // Clear layers array and active layer
      layers = [];
      activeLayerId = null;
      
      // Clear any selected objects
      canvas.discardActiveObject();
      
      // Update layers list display
      updateLayersList();
      
      // Update properties panel to show no selection
      updatePropertiesPanel(null);
      
      // Reset canvas view if needed
      canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
      
      // Request canvas render to update display
      canvas.requestRenderAll();
      
      
    }
    
    // Auto-center all objects in canvas (especially useful after aspect ratio changes)
    function centerAllObjectsInCanvas() {
      if (!deskPadModalCanvas) return;
      
      const canvas = deskPadModalCanvas;
      const canvasWidth = canvas.getWidth();
      const canvasHeight = canvas.getHeight();
      
      const objects = canvas.getObjects().filter(obj => 
        obj.type === 'image' || obj.type === 'i-text' || obj.type === 'text' || 
        obj.type === 'rect' || obj.type === 'circle' || obj.type === 'triangle'
      );
      
      if (objects.length === 0) return;
      
      
      
      objects.forEach(obj => {
        const originX = obj.originX || 'center';
        const originY = obj.originY || 'center';
        
        // Calculate scaled dimensions
        const scaledWidth = obj.getScaledWidth();
        const scaledHeight = obj.getScaledHeight();
        
        let newLeft, newTop;
        
        // Center horizontally
        if (originX === 'center') {
          newLeft = canvasWidth / 2;
        } else if (originX === 'right') {
          newLeft = canvasWidth - scaledWidth / 2;
        } else {
          newLeft = (canvasWidth - scaledWidth) / 2;
        }
        
        // Center vertically
        if (originY === 'center') {
          newTop = canvasHeight / 2;
        } else if (originY === 'bottom') {
          newTop = canvasHeight - scaledHeight / 2;
        } else {
          newTop = (canvasHeight - scaledHeight) / 2;
        }
        
        // Apply new position
        obj.set({
          left: newLeft,
          top: newTop
        });
        
        obj.setCoords();
        

      });
      
      canvas.requestRenderAll();
    }

    // Placeholder for snap-to-safe-area
    function setupSnapToSafeArea() {
      // TODO: Implement snapping logic for objects to stay within the safe area
    }
    
    // Canvas view is now fixed - no dynamic updates needed
    // Removed updateCanvasView function
    

    

    


    // Canvas boundary is now handled by the wrapper approach with CSS


    // Window resize no longer affects canvas size - canvas is fixed
    // Removed resize event listener to prevent dynamic sizing
    
    // Add keyboard support for deleting objects in modal canvas
    window.addEventListener('keydown', function(e) {
      if (e.key === 'Delete' || e.key === 'Backspace') {
        // Check if modal canvas is active
        if (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex') {
          const activeObject = deskPadModalCanvas.getActiveObject();
          if (activeObject) {
            // Handle multiple selected objects
            if (activeObject.type === 'activeSelection') {
              // Multiple objects selected - remove all of them
              const objectsToRemove = activeObject.getObjects();
              objectsToRemove.forEach(obj => {
                deskPadModalCanvas.remove(obj);
              });
              
            } else {
              // Single object selected - remove it
              deskPadModalCanvas.remove(activeObject);
            }
            
            deskPadModalCanvas.requestRenderAll();
            
            // Check if canvas is empty and reset auto-detection if needed
            if (deskPadModalCanvas.getObjects().length === 0) {
              
              modalAutoDetectionPerformed = false;
              modalTargetCanvasWidth = 4305;
              modalTargetCanvasHeight = 1620;
              
              // Reset DPI display
              modalDpiDisplay.innerHTML = 'No image selected';
              modalDpiDisplay.classList.remove('show');
              
              
            }
          }
        }
      }
      
      // Toggle background pattern with 'P' key
      if (e.key === 'p' || e.key === 'P') {
        if (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex') {
          const container = document.getElementById('desk-pad-modal-canvas-container');
          container.classList.toggle('no-pattern');
          
        }
      }
      
      // Toggle border visibility with 'B' key
      if (e.key === 'b' || e.key === 'B') {
        if (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex' && deskPadModalCanvas.borderRect) {
          deskPadModalCanvas.borderRect.visible = !deskPadModalCanvas.borderRect.visible;
          deskPadModalCanvas.requestRenderAll();
          
        }
      }
    });
    


    let smokeOverlay = document.getElementById('smoke-overlay');
    
    // Create smoke particles
    function createSmokeParticles(centerX, centerY, count = 50) {
      const particles = [];
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'smoke-particle';
        // Random direction and distance
        const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
        const distance = 300 + Math.random() * 200;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        // Position at center
        particle.style.left = centerX + 'px';
        particle.style.top = centerY + 'px';
        particle.style.setProperty('--dx', dx + 'px');
        particle.style.setProperty('--dy', dy + 'px');
        smokeOverlay.appendChild(particle);
        particles.push(particle);
      }
      return particles;
    }
    
    // Open desk pad modal with smoke animation
    deskPadButton.addEventListener('click', function() {
      
      const buttonRect = deskPadButton.getBoundingClientRect();
      const centerX = buttonRect.left + buttonRect.width / 2;
      const centerY = buttonRect.top + buttonRect.height / 2;
      
      smokeOverlay.classList.add('show');
      const particles = createSmokeParticles(centerX, centerY, 60);
      
      setTimeout(() => { 
        particles.forEach(p => p.classList.add('expanding')); 
      }, 50);
      
      setTimeout(() => {
        
        deskPadModalOverlay.style.display = 'flex';
        deskPadModalOverlay.classList.add('show');
        document.body.classList.add('modal-open');
        
        // Canvas boundary is now handled by the wrapper approach
        
        // Turn off background pattern by default
        const container = document.getElementById('desk-pad-modal-canvas-container');
        container.classList.add('no-pattern');
        
        
        initResizableDeskPadModalCanvas();
        initShortcutMenu();
        setupPadSizeEventListeners();
        setupFontEventListeners();
        
        setTimeout(() => { 
          
          smokeOverlay.classList.remove('show'); 
          particles.forEach(p => p.remove()); 
        }, 300);
      }, 800);
    });
    
    // Preview button functionality
    let deskPadPreviewBtn = document.getElementById('desk-pad-preview-btn');
    
    deskPadPreviewBtn.addEventListener('click', function() {
      
      generatePreview();
    });
    
    // Close desk pad modal with smoke animation
    deskPadFinishedBtn.addEventListener('click', function() {
      // Don't copy objects back to main canvas - keep modal independent
      
      // Create preview image for button
      if (deskPadModalCanvas) {
        const previewDataUrl = deskPadModalCanvas.toDataURL({ 
          format: 'png', 
          quality: 0.8, 
          multiplier: 0.3 
        });
        buttonPreview.style.backgroundImage = `url(${previewDataUrl})`;
        buttonPreview.classList.add('show');
      }
      
      const buttonRect = deskPadButton.getBoundingClientRect();
      const centerX = buttonRect.left + buttonRect.width / 2;
      const centerY = buttonRect.top + buttonRect.height / 2;
      
      // Start smoke animation while modal is still visible
      smokeOverlay.classList.add('show');
      const particles = createSmokeParticles(centerX, centerY, 60);
      setTimeout(() => { particles.forEach(p => p.classList.add('contracting')); }, 50);

              // Hide modal only after smoke animation is done
        setTimeout(() => {
          deskPadModalOverlay.classList.remove('show');
          deskPadModalOverlay.style.display = 'none';
          document.body.classList.remove('modal-open');
          
          // Canvas boundary is now handled by the wrapper approach
          
          smokeOverlay.classList.remove('show');
          particles.forEach(p => p.remove());
          
          // Reset modal canvas to default for next session
          resetModalCanvasToDefault();
        }, 800);
    });

    // Add Image Modal Functions
    function openAddImageModal() {
      if (!addImageModal) {
        console.error('addImageModal is null!');
        return;
      }
      
      if (!deskPadModalCanvasContainer) {
        console.error('deskPadModalCanvasContainer is null!');
        return;
      }
      
      updateRecentImages();
      addImageModal.classList.add('show');
      deskPadModalCanvasContainer.classList.add('shifted');
    }
    
    function closeAddImageModal() {
      addImageModal.classList.remove('show');
      deskPadModalCanvasContainer.classList.remove('shifted');
    }
    
    function updateRecentImages() {
      
      // Clear current grid
      recentImagesGrid.innerHTML = '';
      
      if (sessionImages.length === 0) {
        recentImagesGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">No images used yet</div>';
        return;
      }
      
      // Add recent images to grid (show most recent first)
      sessionImages.slice().reverse().forEach((imageData, index) => {
        const imageItem = document.createElement('div');
        imageItem.className = 'recent-image-item';
        imageItem.title = `Recent image ${index + 1}`;
        
        const img = document.createElement('img');
        // Create a thumbnail version for the grid
        const tempImg = new Image();
        tempImg.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 120; // Increased from 80
          canvas.height = 120; // Increased from 80
          
          // Enable image smoothing for better quality
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          // Draw the image centered and scaled to fit
          const scale = Math.min(120 / tempImg.width, 120 / tempImg.height);
          const scaledWidth = tempImg.width * scale;
          const scaledHeight = tempImg.height * scale;
          const x = (120 - scaledWidth) / 2;
          const y = (120 - scaledHeight) / 2;
          
          ctx.drawImage(tempImg, x, y, scaledWidth, scaledHeight);
          img.src = canvas.toDataURL('image/png', 1.0); // PNG with full quality
        };
        tempImg.src = imageData;
        img.alt = `Recent image ${index + 1}`;
        
        imageItem.appendChild(img);
        
        // Add click handler to add this image to modal canvas
        imageItem.addEventListener('click', () => {
          // Show loading overlay for recent image selection
          loadingOverlay.classList.add('show');
          const loadingText = document.getElementById('loading-text');
          loadingText.textContent = 'Adding recent image to modal canvas...';
          
          addImageToModalCanvas(imageData);
          closeAddImageModal();
          
          // Hide loading overlay after a short delay
          setTimeout(() => {
            loadingOverlay.classList.remove('show');
          }, 500);
        });
        
        recentImagesGrid.appendChild(imageItem);
      });
    }
    
    function addImageToModalCanvas(imageDataUrl, imageName = null, index = 0) {
      if (!deskPadModalCanvas) {
        console.error('Modal canvas not initialized');
        return;
      }
      
      
      
      // Check if image already exists in recent images
      const existingIndex = recentImages.findIndex(img => img.url === imageDataUrl);
      let imageData;
      
      if (existingIndex !== -1) {
        // Image already exists, move it to the front (most recent)
        imageData = recentImages.splice(existingIndex, 1)[0];
        recentImages.unshift(imageData);
        
      } else {
        // Add new image to recent images array
        imageData = {
          url: imageDataUrl,
          name: imageName || `Image ${recentImages.length + 1}`,
          timestamp: Date.now()
        };
        
        // Add to beginning of array (most recent first)
        recentImages.unshift(imageData);
        
        // Keep only the last 20 images
        if (recentImages.length > 20) {
          recentImages = recentImages.slice(0, 20);
        }
        
        
      }
      
      fabric.Image.fromURL(imageDataUrl, (img) => {
        // Store the original filename on the image object
        img.name = imageName;

        
        
        // Auto-detect DPI for first image BEFORE adjusting canvas area
        if (index === 0 && !modalAutoDetectionPerformed) {
          // Auto-detect appropriate DPI based on image resolution
          const suggestedDPI = autoDetectDPI(img.width, img.height);
          if (suggestedDPI > currentDPI) {
            // User chose a lower DPI than recommended (image is high-res)
            showQualityWarning(
              `Your image is high-res! You could use a higher DPI (e.g. ${suggestedDPI}) for sharper print quality.`,
              img.width, img.height
            );
          } else if (suggestedDPI < currentDPI) {
            // User chose a higher DPI than recommended (image is low-res)
            showQualityWarning(
              `Your image is low-res for ${currentDPI} DPI. Recommended: ${suggestedDPI} DPI or use a higher-res image.`,
              img.width, img.height
            );
          }
          // Never override user DPI choice, just warn
          modalAutoDetectionPerformed = true;
        }
        
        // Set up canvas area based on first image (but keep artboard stable)
        if (!modalAutoDetectionPerformed) {
          // Keep the artboard dimensions stable - don't change them
          // Only adjust the canvas area (77:29 output area) based on the image
          
          // Calculate optimal canvas size for this image while maintaining 77:29 ratio
          const aspectRatio = 77 / 29;
          const imageAspectRatio = img.width / img.height;
          
          let optimalCanvasWidth, optimalCanvasHeight;
          
          if (imageAspectRatio > aspectRatio) {
            // Image is wider than 77:29 - fit by height
            optimalCanvasHeight = Math.min(modalCanvasHeight, img.height);
            optimalCanvasWidth = optimalCanvasHeight * aspectRatio;
          } else {
            // Image is taller than 77:29 - fit by width
            optimalCanvasWidth = Math.min(modalCanvasWidth, img.width);
            optimalCanvasHeight = optimalCanvasWidth / aspectRatio;
          }
          
          // Update only the canvas area dimensions, not the artboard
          modalCanvasWidth = optimalCanvasWidth;
          modalCanvasHeight = optimalCanvasHeight;
          

          
          // Canvas boundary is now handled by the wrapper approach
          
          modalAutoDetectionPerformed = true;
          

          
          // Show canvas area info
          modalDpiDisplay.innerHTML = `
            <strong>Canvas Area Adjusted:</strong><br>
            Artboard: ${modalArtboardWidth} — ${modalArtboardHeight}px (stable)<br>
            Canvas area: ${modalCanvasWidth} — ${modalCanvasHeight}px (77:29)<br>
            Orange border shows final output area<br>
            Images outside border won't appear in final output
          `;
          
          // Add image immediately (no need to wait for resize)
          addImageToModalCanvasInternal(img, index);
          return;
        }
        
        // If not first image, add directly
        addImageToModalCanvasInternal(img, index);
      }, { crossOrigin: 'anonymous' });
    }

    function addImageToModalCanvasInternal(img, index = 0) {
      // Use safe area dimensions for positioning (canvas is now safe area size)
      const safeAreaWidth = deskPadModalCanvas.getWidth();
      const safeAreaHeight = deskPadModalCanvas.getHeight();

      
      // Smart image scaling that preserves quality
      const canvasWidth = safeAreaWidth;
      const canvasHeight = safeAreaHeight;
      const imageWidth = img.width;
      const imageHeight = img.height;
      
      // Calculate optimal scale using smart scaling function
      const scaling = calculateOptimalImageScale(imageWidth, imageHeight, canvasWidth, canvasHeight);
      let scale = scaling.scale;
      
      // Quality warning for poor scaling
      if (scaling.quality.includes('poor') || scaling.quality.includes('upscaled')) {
        console.warn(`💡 Image quality warning: ${scaling.quality}`);
        console.warn(`💡 Consider using a higher resolution image for better quality`);
      }
      
      
      let left, top;
      if (index === 0) {
        // First image goes to center of the safe area
        left = safeAreaWidth / 2;
        top = safeAreaHeight / 2;
      } else {
        // Subsequent images also go to center of safe area (stacked)
        // Add a small offset to prevent perfect overlap
        const offset = 20; // pixels between images
        left = (safeAreaWidth / 2) + (index * offset);
        top = (safeAreaHeight / 2) + (index * offset);
      }
      
      img.set({
        left: left,
        top: top,
        originX: 'center',
        originY: 'center',
        scaleX: scale,
        scaleY: scale,
        selectable: true,
        hasControls: true,
        hasBorders: true,
        evented: true,
        lockMovementX: false,
        lockMovementY: false,
        lockRotation: false,
        lockScalingX: false,
        lockScalingY: false,
        // Custom control colors for better visibility
        transparentCorners: false,
        cornerColor: '#2c3e50',
        cornerStrokeColor: '#ffffff',
        cornerSize: fabric.Object.prototype.cornerSize,
        cornerStrokeWidth: fabric.Object.prototype.cornerStrokeWidth,
        cornerStyle: 'circle',
        borderColor: '#2c3e50',
        borderScaleFactor: fabric.Object.prototype.borderScaleFactor,
        stroke: 'transparent',
        strokeWidth: 0
      });
      
      
      
      
      
      // Update DPI display for this image (but don't auto-show)
      updateModalDPIDisplay(img.width, img.height, modalCanvasWidth, modalCanvasHeight, scale);
      
      // Show quality warning if image is being upscaled
      if (scaling.quality.includes('poor') || scaling.quality.includes('upscaled')) {
        showQualityWarning(scaling.quality, imageWidth, imageHeight);
      }
      
      deskPadModalCanvas.add(img);
      deskPadModalCanvas.setActiveObject(img); // Select the new image
      
      // Create a layer for this image
      const imageName = img.name || `Image ${layers.length + 1}`;
      const layer = createLayer(imageName, 'Image', img);
      
      // Set this as the active layer since the image is auto-selected
      activeLayerId = layer.id;
      
      // Ensure layers menu is open so properties panel elements are available
      const layersMenu = document.getElementById('layers-menu');
      if (layersMenu && !layersMenu.classList.contains('active')) {
        layersMenu.classList.add('active');
      }
      
      // Update properties panel after ensuring menu is open
      setTimeout(() => {
        updatePropertiesPanel(layer);
      }, 100);
      
      updateLayersList();
      
      // Ensure new image has current DPI-based snapping settings
      updateAllObjectsSnappingSettings();
      
      // Ensure the image is fully interactive
      img.selectable = true;
      img.evented = true;
      img.hasControls = true;
      img.hasBorders = true;
      
      // Note: Removed real-time text change listener to prevent layer disappearance during editing
      // Layer names will be updated only when text modal is applied
      
      // Ensure canvas is in the correct state for interaction
      deskPadModalCanvas.selection = true;
      deskPadModalCanvas.preserveObjectStacking = true;
      
      deskPadModalCanvas.requestRenderAll();
      
      // Debug: Check if image is visible
      
      
      
      // Force a render and check if image is in the right place
      setTimeout(() => {
        const objects = deskPadModalCanvas.getObjects();
        if (objects.length > 0) {
          const lastObject = objects[objects.length - 1];
          
        }
      }, 100);
      
      // Add to session images for recent images grid
      const imageDataUrl = img.toDataURL();
      if (!sessionImages.includes(imageDataUrl)) {
        sessionImages.push(imageDataUrl);

      }
      
      
      
      // Track image processing completion for loading overlay
      // This will be called by the upload functions to signal when all images are done
      if (window.modalImageProcessingComplete) {
        window.modalImageProcessingComplete();
      }
    }
    
    function handleModalFileUpload(files) {
      
      
      
      
      // Show loading overlay for modal file upload
      loadingOverlay.classList.add('show');
      
      
      const loadingText = document.getElementById('loading-text');
      loadingText.textContent = `Processing ${files.length} image${files.length > 1 ? 's' : ''} for modal canvas...`;
      
      // Process each image file
      let processedCount = 0;
      const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
      
      if (imageFiles.length === 0) {
        alert('Please select at least one image file.');
        loadingOverlay.classList.remove('show');
        return;
      }
      
      // Set up completion callback for loading overlay
      window.modalImageProcessingComplete = () => {
        processedCount++;
        
        // Update loading text
        loadingText.textContent = `Processing modal image ${processedCount} of ${imageFiles.length}...`;
        
        // Hide loading overlay when all images are processed
        if (processedCount === imageFiles.length) {
          // Use a longer delay for high-resolution images to ensure all processing is complete
          const delay = 1000; // Longer delay to ensure all processing is complete
          
          setTimeout(() => {
            if (loadingOverlay.classList.contains('show')) {
      
              loadingOverlay.classList.remove('show');
            }
            // Clean up the callback
            window.modalImageProcessingComplete = null;
          }, delay);
        }
      };
      
      imageFiles.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          addImageToModalCanvas(e.target.result, file.name, index);
        };
        reader.readAsDataURL(file);
      });
    }
    
    // Add Image Modal Event Listeners - moved to DOMContentLoaded
    function setupModalEventListeners() {
      

      
      if (deskPadMenuBtn) {
        deskPadMenuBtn.addEventListener('click', (e) => {

          
          // Check if modal is already open
          if (addImageModal && addImageModal.classList.contains('show')) {
            // Modal is open, so close it
            closeAddImageModal();
          } else {
            // Modal is closed, so open it
            openAddImageModal();
          }
        });
        
      } else {
        console.error('deskPadMenuBtn is null!');
      }
      
      if (addImageClose) {
        addImageClose.addEventListener('click', closeAddImageModal);
        
      } else {
        console.error('addImageClose is null!');
      }
      

      
      // Menu item event listeners
      if (menuAddImage) {
        menuAddImage.addEventListener('click', () => {
          // Open file dialog directly
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = 'image/*';
          fileInput.multiple = true;
          fileInput.style.display = 'none';
          document.body.appendChild(fileInput);
          
          fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
              handleModalFileUpload(e.target.files);
              closeAddImageModal();
            }
            document.body.removeChild(fileInput);
          });
          
          fileInput.click();
        });
        
      } else {
        console.error('menuAddImage is null!');
      }
      
      if (menuRecentImages) {
        menuRecentImages.addEventListener('click', () => {
          // This could expand the recent images section or show a larger view
        });
        
      } else {
        console.error('menuRecentImages is null!');
      }
      
      // DPI selection event listeners
      const dpiOptions = document.querySelectorAll('.dpi-option');
      dpiOptions.forEach(option => {
        option.addEventListener('click', () => {
          const dpi = parseInt(option.dataset.dpi);
          const width = parseInt(option.dataset.width);
          const height = parseInt(option.dataset.height);
          
          // Check if DPI is locked and this is a different option
          if (dpiLocked && dpi !== currentDPI) {
            showDPIChangeWarning(() => {
              // User confirmed - unlock and change DPI
              unlockDPIOptions();
              
              // Update active state
              dpiOptions.forEach(opt => opt.classList.remove('active'));
              option.classList.add('active');
              
              // Update canvas resolution
              updateCanvasResolution(dpi, width, height);
            });
          } else {
            // Normal DPI change (not locked or same DPI)
            // Update active state
            dpiOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');
            
            // Update canvas resolution
            updateCanvasResolution(dpi, width, height);
            
            // Lock DPI options after manual selection
            lockDPIOptions(dpi);
          }
        });
      });
      
      // Canvas size selection event listener
      const canvasSizeSelect = document.getElementById('canvasSizeSelect');
      if (canvasSizeSelect) {
        canvasSizeSelect.addEventListener('change', function(e) {
          const selectedPreset = e.target.value;
          applyAspectPreset(selectedPreset);
        });
      } else {
        console.error('canvasSizeSelect is null!');
      }
      
      // DPI submenu toggle functionality
      const dpiSectionToggle = document.querySelector('.dpi-section-toggle');
      const dpiSubmenu = document.querySelector('.dpi-submenu');
      const dpiToggleIcon = document.querySelector('.dpi-toggle-icon');
      
      if (dpiSectionToggle && dpiSubmenu && dpiToggleIcon) {
        dpiSectionToggle.addEventListener('click', () => {
          const isVisible = dpiSubmenu.style.display !== 'none';
          
          if (isVisible) {
            // Hide submenu
            dpiSubmenu.style.display = 'none';
            dpiToggleIcon.style.transform = 'rotate(0deg)';
          } else {
            // Show submenu
            dpiSubmenu.style.display = 'block';
            dpiToggleIcon.style.transform = 'rotate(180deg)';
          }
        });
      }
      
      // Close panel with Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && addImageModal && addImageModal.classList.contains('show')) {
          closeAddImageModal();
        }
      });
      
    }
    
    // Call setup function when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupModalEventListeners);
    } else {
      setupModalEventListeners();
    }
    
    // Modal Canvas Drag and Drop Support
    deskPadModalCanvasContainer.addEventListener('dragover', e => {
      e.preventDefault();
      e.stopPropagation();
      modalDropOverlay.style.display = 'flex';
    });
    
    deskPadModalCanvasContainer.addEventListener('dragleave', e => {
      e.preventDefault();
      e.stopPropagation();
      modalDropOverlay.style.display = 'none';
    });
    
    deskPadModalCanvasContainer.addEventListener('drop', e => {
      e.preventDefault();
      e.stopPropagation();
      modalDropOverlay.style.display = 'none';
      
      const files = Array.from(e.dataTransfer.files);
      const imageFiles = files.filter(file => file.type.startsWith('image/'));
      
      if (imageFiles.length === 0) {
        alert('Please drop at least one image file.');
        return;
      }
      
      
      
      // Close recent images popup if it's open
      const recentPopup = document.getElementById('recent-images-popup');
      if (recentPopup && recentPopup.classList.contains('show')) {
        hideRecentImagesPopup();
      }
      
      // Show loading overlay for modal drag and drop
      
      loadingOverlay.classList.add('show');
      
      const loadingText = document.getElementById('loading-text');
      loadingText.textContent = `Processing ${imageFiles.length} dropped image${imageFiles.length > 1 ? 's' : ''} for modal canvas...`;
      
      // Process each image file
      let processedCount = 0;
      
      // Set up completion callback for loading overlay
      window.modalImageProcessingComplete = () => {
        processedCount++;
        
        // Update loading text
        loadingText.textContent = `Processing dropped modal image ${processedCount} of ${imageFiles.length}...`;
        
        // Hide loading overlay when all images are processed
        if (processedCount === imageFiles.length) {
          // Use a longer delay for high-resolution images to ensure all processing is complete
          const delay = 1000; // Longer delay to ensure all processing is complete
          
          setTimeout(() => {
            if (loadingOverlay.classList.contains('show')) {
      
              loadingOverlay.classList.remove('show');
            }
            // Clean up the callback
            window.modalImageProcessingComplete = null;
          }, delay);
        }
      };
      
      imageFiles.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = ev => {
          addImageToModalCanvas(ev.target.result, file.name, index);
        };
        reader.readAsDataURL(file);
      });
    });

    function resetModalCanvasToDefault() {
      if (!deskPadModalCanvas) return;
      
      // Show loading overlay for modal canvas reset
      loadingOverlay.classList.add('show');
      const loadingText = document.getElementById('loading-text');
      loadingText.textContent = 'Resetting modal canvas...';
      
      // Clean up all properties buttons
      const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
      const propertiesButtons = canvasContainer.querySelectorAll('.image-properties-btn');
      propertiesButtons.forEach(btn => btn.remove());
      
      // Reset modal canvas to default size (responsive to container)
      const container = document.getElementById('desk-pad-modal-canvas-container');
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      
      // Calculate artboard size using 95% of container space
      const maxArtboardWidth = containerWidth * 0.95;
      const maxArtboardHeight = containerHeight * 0.95;
      
      // Canvas is 77:29 aspect ratio, sized to fill 85% of artboard area
      const aspectRatio = 77 / 29;
      
      // Calculate canvas size to fill 85% of artboard while maintaining 77:29 ratio
      let canvasWidth, canvasHeight;
      
      // Try fitting by width first (most common case)
      canvasWidth = maxArtboardWidth * 0.85;
      canvasHeight = canvasWidth / aspectRatio;
      
      // If height exceeds artboard, fit by height instead
      if (canvasHeight > maxArtboardHeight * 0.85) {
        canvasHeight = maxArtboardHeight * 0.85;
        canvasWidth = canvasHeight * aspectRatio;
      }
      
      // Artboard uses the calculated maximum size
      const artboardWidth = maxArtboardWidth;
      const artboardHeight = maxArtboardHeight;
      
      // Resize modal canvas back to default
      deskPadModalCanvas.setDimensions({
        width: artboardWidth,
        height: artboardHeight
      });
      
      // Update stored dimensions
      modalArtboardWidth = artboardWidth;
      modalArtboardHeight = artboardHeight;
      modalCanvasWidth = canvasWidth;
      modalCanvasHeight = canvasHeight;
      
      // Update background to match new canvas size
      updateCanvasBackground();
      
      // Canvas view is now fixed - no dynamic updates needed
      
      // Reset auto-detection flag
      modalAutoDetectionPerformed = false;
      
      // Reset DPI display
      modalDpiDisplay.innerHTML = 'No image selected';
      modalDpiDisplay.classList.remove('show');
      
      // Unlock DPI options when canvas is reset
      unlockDPIOptions();
      
      // Reset the current DPI display
      const currentDpiDisplay = document.getElementById('current-dpi-display');
      if (currentDpiDisplay) {
        currentDpiDisplay.textContent = `100 DPI • 2900 × 1093px`;
      }
      
      // Reset handle sizes to default (100 DPI)
      updateHandleSizes(100);
      
      // Hide loading overlay after a short delay
      setTimeout(() => {
        loadingOverlay.classList.remove('show');
      }, 300);
    }


    
    // Add debug function to force update handle sizes
    window.forceUpdateHandles = function() {
      forceUpdateAllHandles();
    };

    // Set global default for all images to have no stroke
    fabric.Image.prototype.stroke = 'transparent';
    fabric.Image.prototype.strokeWidth = 0;

    // Function to show quality warning for upscaled images
    function showQualityWarning(quality, originalWidth, originalHeight) {
      const warningDiv = document.createElement('div');
      warningDiv.className = 'quality-warning';
      warningDiv.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 1001;
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        max-width: 300px;
        animation: slideInRight 0.3s ease;
      `;
      
      warningDiv.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 8px;">
          <span style="font-size: 18px; margin-right: 8px;">🚨</span>
          <strong>Image Quality Warning</strong>
        </div>
        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 8px;">
          ${quality}
        </div>
        <div style="font-size: 11px; opacity: 0.8;">
          Original: ${originalWidth} — ${originalHeight}px
        </div>
        <div style="font-size: 11px; opacity: 0.8; margin-top: 4px;">
          💡 Use a higher resolution image for better quality
        </div>
      `;
      
      // Add close button
      const closeBtn = document.createElement('button');
              closeBtn.textContent = '×';
      closeBtn.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
        opacity: 0.8;
      `;
      closeBtn.onclick = () => warningDiv.remove();
      warningDiv.appendChild(closeBtn);
      
      document.body.appendChild(warningDiv);
      
      // Auto-remove after 8 seconds
      setTimeout(() => {
        if (warningDiv.parentNode) {
          warningDiv.style.animation = 'slideOutRight 0.3s ease';
          setTimeout(() => warningDiv.remove(), 300);
        }
      }, 8000);
    }

    // Function to calculate optimal image scale that preserves quality
    function calculateOptimalImageScale(imageWidth, imageHeight, targetWidth, targetHeight) {
      // Calculate scale factors for width and height
      const scaleX = targetWidth / imageWidth;
      const scaleY = targetHeight / imageHeight;
      
      // Use the smaller scale to fit image within target (maintains aspect ratio)
      const scale = Math.min(scaleX, scaleY);
      
      // Calculate final dimensions
      const finalWidth = Math.round(imageWidth * scale);
      const finalHeight = Math.round(imageHeight * scale);
      
      // Quality assessment
      let quality = 'excellent';
      if (scale > 1.5) {
        quality = 'poor (upscaled)';
      } else if (scale > 1.2) {
        quality = 'fair (slightly upscaled)';
      } else if (scale < 0.5) {
        quality = 'excellent (downscaled)';
      } else if (scale < 0.8) {
        quality = 'good (downscaled)';
      }
      

      
      return { scale, finalWidth, finalHeight, quality };
    }



    // Alignment toolbar toggle
    const alignmentToggleBtn = document.getElementById('alignment-toggle-btn');
    const alignmentToolbar = document.getElementById('alignment-toolbar');
    const alignmentToggleIcon = document.getElementById('alignment-toggle-icon');
    const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');

    if (alignmentToggleBtn && alignmentToolbar) {
      alignmentToggleBtn.addEventListener('click', () => {
        const isVisible = alignmentToolbar.classList.contains('show');
        
        if (isVisible) {
          alignmentToolbar.classList.remove('show');
          alignmentToggleBtn.classList.remove('active');
          alignmentToggleIcon.textContent = '▼';
          if (canvasContainer) {
            canvasContainer.classList.remove('with-alignment-toolbar');
          }
        } else {
          // Close canvas toolbar first
          canvasToolbar.classList.remove('show');
          canvasToggleBtn.classList.remove('active');
          canvasToggleIcon.textContent = '▼';
          
          // Close background toolbar
          const backgroundToolbar = document.getElementById('background-toolbar');
          const backgroundToggleBtn = document.getElementById('background-toggle-btn');
          const backgroundToggleIcon = document.getElementById('background-toggle-icon');
          if (backgroundToolbar) backgroundToolbar.classList.remove('show');
          if (backgroundToggleBtn) backgroundToggleBtn.classList.remove('active');
          if (backgroundToggleIcon) backgroundToggleIcon.textContent = '▼';
          
          // Open alignment toolbar
          alignmentToolbar.classList.add('show');
          alignmentToggleBtn.classList.add('active');
          alignmentToggleIcon.textContent = '▲';
          if (canvasContainer) {
            canvasContainer.classList.add('with-alignment-toolbar');
          }
        }
      });
    }

    // Canvas toolbar toggle
    const canvasToggleBtn = document.getElementById('canvas-toggle-btn');
    const canvasToolbar = document.getElementById('canvas-toolbar');
    const canvasToggleIcon = document.getElementById('canvas-toggle-icon');

    if (canvasToggleBtn && canvasToolbar) {
      canvasToggleBtn.addEventListener('click', () => {
        const isVisible = canvasToolbar.classList.contains('show');
        
        if (isVisible) {
          canvasToolbar.classList.remove('show');
          canvasToggleBtn.classList.remove('active');
          canvasToggleIcon.textContent = '▼';
          if (canvasContainer) {
            canvasContainer.classList.remove('with-alignment-toolbar');
          }
        } else {
          // Close alignment toolbar first
          alignmentToolbar.classList.remove('show');
          alignmentToggleBtn.classList.remove('active');
          alignmentToggleIcon.textContent = '▼';
          if (canvasContainer) {
            canvasContainer.classList.remove('with-alignment-toolbar');
          }
          
          // Close background toolbar
          const backgroundToolbar = document.getElementById('background-toolbar');
          const backgroundToggleBtn = document.getElementById('background-toggle-btn');
          const backgroundToggleIcon = document.getElementById('background-toggle-icon');
          if (backgroundToolbar) backgroundToolbar.classList.remove('show');
          if (backgroundToggleBtn) backgroundToggleBtn.classList.remove('active');
          if (backgroundToggleIcon) backgroundToggleIcon.textContent = '▼';
          
          // Open canvas toolbar
          canvasToolbar.classList.add('show');
          canvasToggleBtn.classList.add('active');
          canvasToggleIcon.textContent = '▲';
          if (canvasContainer) {
            canvasContainer.classList.add('with-alignment-toolbar');
          }
        }
      });
    }

    // Layers menu toggle
    const layersToggleBtn = document.getElementById('layers-toggle-btn');
    const layersMenu = document.getElementById('layers-menu');
    const layersToggleIcon = document.getElementById('layers-toggle-icon');
    const layersCloseBtn = document.getElementById('layers-close');

    if (layersToggleBtn && layersMenu) {
      layersToggleBtn.addEventListener('click', () => {
        const isVisible = layersMenu.classList.contains('show');
        
        if (isVisible) {
          layersMenu.classList.remove('show');
          layersToggleBtn.classList.remove('active');
          layersToggleIcon.textContent = '▼';
          // Remove canvas adjustment
          if (canvasContainer) {
            canvasContainer.classList.remove('with-layers-menu');
            
            // Update the canvas transform to remove layers menu scale
            if (typeof resizeCanvasDom === 'function') {
              resizeCanvasDom(currentScale);
            }
            

          }
          if (alignmentToolbar) {
            alignmentToolbar.classList.remove('with-layers-menu');
          }
          if (canvasToolbar) {
            canvasToolbar.classList.remove('with-layers-menu');
          }
          if (backgroundToolbar) {
            backgroundToolbar.classList.remove('with-layers-menu');
          }
        } else {

          // Don't close other toolbars - let them stay open
          
          // Open layers menu
          layersMenu.classList.add('show');
          layersToggleBtn.classList.add('active');
          layersToggleIcon.textContent = '▲';
          
          // Initialize layer management
          initializeLayerManagement();
          
          // Initialize properties panel
          if (activeLayerId) {
            const activeLayer = layers.find(l => l.id === activeLayerId);
            updatePropertiesPanel(activeLayer);
          } else {
            updatePropertiesPanel(null);
          }
          // Add canvas adjustment
          if (canvasContainer) {
            canvasContainer.classList.add('with-layers-menu');
            
            // Force a reflow to ensure styles are applied
            canvasContainer.offsetHeight;
            
            // Update the canvas transform to include layers menu scale
            if (typeof resizeCanvasDom === 'function') {
              resizeCanvasDom(currentScale);
            }
          }
          if (alignmentToolbar) {
            alignmentToolbar.classList.add('with-layers-menu');
          }
          if (canvasToolbar) {
            canvasToolbar.classList.add('with-layers-menu');
          }
          if (backgroundToolbar) {
            backgroundToolbar.classList.add('with-layers-menu');
          }
        }
      });
    }

    // Layers menu close button
    if (layersCloseBtn && layersMenu) {
      layersCloseBtn.addEventListener('click', () => {
        layersMenu.classList.remove('show');
        layersToggleBtn.classList.remove('active');
        layersToggleIcon.textContent = '▼';
        // Remove canvas adjustment
        if (canvasContainer) {
          canvasContainer.classList.remove('with-layers-menu');
        }
        if (alignmentToolbar) {
          alignmentToolbar.classList.remove('with-layers-menu');
        }
        if (canvasToolbar) {
          canvasToolbar.classList.remove('with-layers-menu');
        }
        if (backgroundToolbar) {
          backgroundToolbar.classList.remove('with-layers-menu');
        }
      });
    }

    // Background popup toggle
    const backgroundToggleBtn = document.getElementById('background-toggle-btn');
    const backgroundToolbar = document.getElementById('background-toolbar');
    const backgroundToggleIcon = document.getElementById('background-toggle-icon');
    const backgroundToolbarClose = document.getElementById('background-toolbar-close');

    if (backgroundToggleBtn && backgroundToolbar) {
      backgroundToggleBtn.addEventListener('click', () => {
        const isVisible = backgroundToolbar.classList.contains('show');
        if (isVisible) {
          backgroundToolbar.classList.remove('show');
          backgroundToggleBtn.classList.remove('active');
          backgroundToggleIcon.textContent = '▼';
        } else {
          // Close other toolbars
          const canvasToolbar = document.getElementById('canvas-toolbar');
          const canvasToggleBtn = document.getElementById('canvas-toggle-btn');
          const canvasToggleIcon = document.getElementById('canvas-toggle-icon');
          const alignmentToolbar = document.getElementById('alignment-toolbar');
          const alignmentToggleBtn = document.getElementById('alignment-toggle-btn');
          const alignmentToggleIcon = document.getElementById('alignment-toggle-icon');
          
          if (canvasToolbar) canvasToolbar.classList.remove('show');
          if (canvasToggleBtn) canvasToggleBtn.classList.remove('active');
          if (canvasToggleIcon) canvasToggleIcon.textContent = '▼';
          if (alignmentToolbar) alignmentToolbar.classList.remove('show');
          if (alignmentToggleBtn) alignmentToggleBtn.classList.remove('active');
          if (alignmentToggleIcon) alignmentToggleIcon.textContent = '▼';
          
          backgroundToolbar.classList.add('show');
          backgroundToggleBtn.classList.add('active');
          backgroundToggleIcon.textContent = '▲';
          
          // Setup background event listeners
          setupBackgroundEventListeners();
        }
      });
    }
    if (backgroundToolbarClose) {
      backgroundToolbarClose.addEventListener('click', () => {
        backgroundToolbar.classList.remove('show');
        backgroundToggleBtn.classList.remove('active');
        backgroundToggleIcon.textContent = '▼';
      });
    }



    // Layer Management System
    let layers = [];
    let activeLayerId = null;
    let draggedLayer = null;
    let potentialDragLayer = null;
    let dragStartY = 0;
    let dragStartX = 0;

    // Initialize layer management
    function initializeLayerManagement() {
      updateLayersList();
      setupLayerDragAndDrop();
    }

    // Create a shortened, user-friendly name from filename
    function createShortName(filename) {
      if (!filename) return 'Image';
      
      // Remove file extension
      let name = filename.replace(/\.[^/.]+$/, '');
      
      // Remove common prefixes/suffixes
      name = name.replace(/^(IMG_|DSC_|PXL_|Screenshot_|image_|photo_)/i, '');
      name = name.replace(/(_\d+|\d+)$/, ''); // Remove trailing numbers
      
      // If name is still too long, truncate it (increased limit to 50 characters)
      if (name.length > 50) {
        name = name.substring(0, 47) + '...';
      }
      
      // If name is empty after cleaning, use a fallback
      if (!name || name.trim() === '') {
        name = 'Image';
      }
      
      return name;
    }

    // Create a shortened, user-friendly name from text content
    function createTextName(textContent) {
      if (!textContent || textContent === ' ' || textContent.trim() === '') {
        return 'Text';
      }
      
      // Clean up the text content
      let name = textContent.trim();
      
      // Remove line breaks and extra spaces
      name = name.replace(/\n/g, ' ').replace(/\s+/g, ' ');
      
      // If text is too long, truncate it (increased limit to 50 characters)
      if (name.length > 50) {
        name = name.substring(0, 47) + '...';
      }
      
      // If name is empty after cleaning, use a fallback
      if (!name || name.trim() === '') {
        name = 'Text';
      }
      
      return name;
    }

    // Create a new layer
    function createLayer(name, type, object = null) {
      let displayName;
      
      if (type === 'Image') {
        displayName = createShortName(name);
      } else if (type === 'Text' && object && object.text) {
        displayName = createTextName(object.text);
      } else {
        displayName = name;
      }
      
      const layer = {
        id: 'layer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: displayName,
        originalName: name, // Keep the original name for reference
        type: type,
        visible: true,
        locked: false,
        object: object,
        order: layers.length
      };
      
      
      layers.push(layer);
      
      updateLayersList();
      return layer;
    }

    // Update the layers list display
    function updateLayersList() {
      const layersList = document.getElementById('layers-list');
      if (!layersList) {
        return;
      }

      // Don't update if we're currently dragging
      if (draggedLayer) {
        return;
      }

      layersList.innerHTML = '';

      // Sort layers by order (top to bottom - matching visual stacking)
      const sortedLayers = [...layers].sort((a, b) => b.order - a.order);

      sortedLayers.forEach((layer, index) => {
        const layerElement = createLayerElement(layer, index);
        layersList.appendChild(layerElement);
      });
    }

    // Create a layer element
    function createLayerElement(layer, index) {
      const layerDiv = document.createElement('div');
      layerDiv.className = 'layer-item';
      layerDiv.dataset.layerId = layer.id;
      
      // Check if this layer is part of a multiple selection
      const activeObject = deskPadModalCanvas ? deskPadModalCanvas.getActiveObject() : null;
      const selectedObjects = deskPadModalCanvas ? deskPadModalCanvas.getActiveObjects() : [];
      const isInMultipleSelection = selectedObjects.length > 1 && selectedObjects.some(obj => {
        const objLayer = layers.find(l => l.object === obj);
        return objLayer && objLayer.id === layer.id;
      });
      
      if (layer.id === activeLayerId) {
        layerDiv.classList.add('active');
      }
      if (isInMultipleSelection) {
        layerDiv.classList.add('multi-selected');
      }
      if (layer.locked) {
        layerDiv.classList.add('locked');
      }
      if (!layer.visible) {
        layerDiv.classList.add('hidden');
      }

      layerDiv.innerHTML = `
        <div class="layer-item-header">
          <div class="layer-info">
            <div class="layer-name" title="Double-click to rename">${layer.name}</div>
            <div class="layer-bottom-row">
              <div class="layer-type">${layer.type}</div>
              <div class="layer-controls">
                <button class="layer-control-btn visibility-btn" title="${layer.visible ? 'Hide' : 'Show'} layer">
                  <i class="bi ${layer.visible ? 'bi-eye-fill' : 'bi-eye-slash-fill'}"></i>
                </button>
                <button class="layer-control-btn lock-btn" title="${layer.locked ? 'Unlock' : 'Lock'} layer">
                  <i class="bi ${layer.locked ? 'bi-lock-fill' : 'bi-unlock-fill'}"></i>
                </button>
                <button class="layer-control-btn delete-btn" title="Delete layer">
                  <i class="bi bi-trash3-fill"></i>
                </button>
              </div>
            </div>
          </div>
        </div>
      `;

      // Add event listeners
      const visibilityBtn = layerDiv.querySelector('.visibility-btn');
      const lockBtn = layerDiv.querySelector('.lock-btn');
      const deleteBtn = layerDiv.querySelector('.delete-btn');

      visibilityBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleLayerVisibility(layer.id);
      });

      lockBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleLayerLock(layer.id);
      });

      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteLayer(layer.id);
      });

      // Layer selection
      layerDiv.addEventListener('click', () => {
        selectLayer(layer.id);
      });

      // Layer name double-click to rename
      const layerNameElement = layerDiv.querySelector('.layer-name');
      
      // Add both click and double-click handlers for better compatibility
      let clickTimeout = null;
      let clickCount = 0;
      
      layerNameElement.addEventListener('click', (e) => {
        e.stopPropagation();
        clickCount++;
        
        if (clickCount === 1) {
          clickTimeout = setTimeout(() => {
            clickCount = 0;
          }, 300);
        } else if (clickCount === 2) {
          clearTimeout(clickTimeout);
          clickCount = 0;
          
          // Double-click detected - start rename
          e.preventDefault();
          
          // Prevent drag from starting during rename
          if (potentialDragLayer === layerDiv) {
            potentialDragLayer = null;
          }
          
          // Add renaming class to prevent drag interference
          layerDiv.classList.add('renaming');
          
          // Create input element for editing
          const input = document.createElement('input');
          input.type = 'text';
          input.value = layer.name;
          input.className = 'layer-name-input';
          input.maxLength = 30;
          
          // Handle input events
          const finishRename = () => {
            const newName = input.value.trim();
            if (newName && newName !== layer.name) {
              layer.name = newName;
              updateLayersList();
            } else {
              // Restore original name if empty or unchanged
              layerNameElement.textContent = layer.name;
            }
            
            // Clean up input element and remove renaming class
            if (input.parentNode) {
              input.parentNode.removeChild(input);
            }
            layerNameElement.style.display = 'block';
            layerDiv.classList.remove('renaming');
          };
          
          const cancelRename = () => {
            layerNameElement.textContent = layer.name;
            if (input.parentNode) {
              input.parentNode.removeChild(input);
            }
            layerNameElement.style.display = 'block';
            layerDiv.classList.remove('renaming');
          };
          
          input.addEventListener('blur', finishRename);
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              finishRename();
            } else if (e.key === 'Escape') {
              e.preventDefault();
              cancelRename();
            }
          });
          
          // Replace layer name with input
          layerNameElement.style.display = 'none';
          layerNameElement.parentNode.insertBefore(input, layerNameElement);
          input.focus();
          input.select();
        }
      });

      return layerDiv;
    }

    // Get layer properties string (for layer list display)
    function getLayerProperties(layer) {
      if (layer.object) {
        const obj = layer.object;
        if (obj.type === 'image') {
          return 'Image layer';
        } else if (obj.type === 'text') {
          return `${obj.text.length} characters`;
        }
      }
      return 'Layer properties';
    }

    // Update layer name when text content changes
    function updateTextLayerName(textObject) {
      // Find the layer that contains this text object
      const layer = layers.find(l => l.object === textObject);
      if (layer && layer.type === 'Text') {
        // Handle empty text - keep the layer with a default name
        let textContent = textObject.text;
        if (textContent === ' ' || textContent === '' || !textContent) {
          textContent = ' ';
          // Ensure the text object has placeholder text to keep it visible
          textObject.set('text', ' ');
          textObject.set('fill', 'transparent');
        }
        
        const newName = createTextName(textContent);
        if (layer.name !== newName) {
          layer.name = newName;
          // Update layers list to reflect the change
          updateLayersList();
        }
      }
    }

    // Update layer object reference when image is replaced (crop/rotation)
    function updateLayerObjectReference(oldObject, newObject) {
      // Find the layer that contains the old object
      const layer = layers.find(l => l.object === oldObject);
      if (layer) {
        // Update the layer to point to the new object
        layer.object = newObject;
        
        // Note: Removed real-time text change listener to prevent layer disappearance during editing
        // Layer names will be updated only when text modal is applied
        
        // Update the layers list to reflect the change
        updateLayersList();
      }
    }

    // Reorder layers array to match canvas object order
    function reorderLayersArray() {
      if (!deskPadModalCanvas) return;
      
      const canvasObjects = deskPadModalCanvas.getObjects();
      const newLayersOrder = [];
      
      // Create new order based on canvas object positions (bottom to top)
      for (let i = canvasObjects.length - 1; i >= 0; i--) {
        const object = canvasObjects[i];
        const layer = layers.find(l => l.object === object);
        if (layer) {
          layer.order = newLayersOrder.length;
          newLayersOrder.push(layer);
        }
      }
      
      // Preserve layers that don't have objects on canvas (e.g., during text editing)
      // Add them at the end with higher order numbers
      layers.forEach(layer => {
        if (!newLayersOrder.includes(layer)) {
          layer.order = newLayersOrder.length;
          newLayersOrder.push(layer);
        }
      });
      
      // Replace layers array with new order
      layers = newLayersOrder;
    }

    // Layer reordering helper functions using Fabric.js methods
    function bringLayerToFront(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer && layer.object && deskPadModalCanvas) {
        deskPadModalCanvas.bringToFront(layer.object);
        deskPadModalCanvas.requestRenderAll();
        reorderLayersArray();
        updateLayersList();
      }
    }

    function sendLayerToBack(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer && layer.object && deskPadModalCanvas) {
        deskPadModalCanvas.sendToBack(layer.object);
        deskPadModalCanvas.requestRenderAll();
        reorderLayersArray();
        updateLayersList();
      }
    }

    function bringLayerForward(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer && layer.object && deskPadModalCanvas) {
        // Get the sorted layers (same order as displayed in UI)
        const sortedLayers = [...layers].sort((a, b) => b.order - a.order);
        const visualIndex = sortedLayers.findIndex(l => l.id === layerId);
        
        if (visualIndex > 0) { // Can't move up if already at top
  
          
          // Move object on canvas
          deskPadModalCanvas.bringForward(layer.object);
          deskPadModalCanvas.requestRenderAll();
          
          // Get the layer above this one in visual order
          const layerAbove = sortedLayers[visualIndex - 1];
          
          // Swap their orders
          const tempOrder = layer.order;
          layer.order = layerAbove.order;
          layerAbove.order = tempOrder;
          
          
          // Update UI
          updateLayersList();
        }
      }
    }

    function sendLayerBackward(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer && layer.object && deskPadModalCanvas) {
        // Get the sorted layers (same order as displayed in UI)
        const sortedLayers = [...layers].sort((a, b) => b.order - a.order);
        const visualIndex = sortedLayers.findIndex(l => l.id === layerId);
        
        if (visualIndex < sortedLayers.length - 1) { // Can't move down if already at bottom

          
          // Move object on canvas
          deskPadModalCanvas.sendBackwards(layer.object);
          deskPadModalCanvas.requestRenderAll();
          
          // Get the layer below this one in visual order
          const layerBelow = sortedLayers[visualIndex + 1];
          
          // Swap their orders
          const tempOrder = layer.order;
          layer.order = layerBelow.order;
          layerBelow.order = tempOrder;
          
          
          // Update UI
          updateLayersList();
        }
      }
    }

    // Update properties panel with detailed information and preview
    function updatePropertiesPanel(layer) {
      const objectPreviewContainer = document.getElementById('object-preview-container');
      const objectPreview = document.getElementById('object-preview');
      const propertiesContent = document.getElementById('properties-content');
      

      
      if (!objectPreviewContainer || !objectPreview || !propertiesContent) {

        
        // Try to open the layers menu if it's not already open
        const layersMenu = document.getElementById('layers-menu');
        if (layersMenu && !layersMenu.classList.contains('active')) {
          layersMenu.classList.add('active');
          
          // Try again after a short delay
          setTimeout(() => {
            updatePropertiesPanel(layer);
          }, 200);
        }
        return;
      }

      if (!layer || !layer.object) {
        // Check if multiple objects are selected
        const selectedObjects = deskPadModalCanvas ? deskPadModalCanvas.getActiveObjects() : [];
        if (selectedObjects.length > 1) {
          objectPreviewContainer.style.display = 'none';
          propertiesContent.innerHTML = `
            <div style="color: #ccc; font-size: 12px; font-style: italic;">
              Multiple objects selected (${selectedObjects.length})
            </div>
          `;
        } else {
          objectPreviewContainer.style.display = 'none';
          propertiesContent.innerHTML = `
            <div style="color: #ccc; font-size: 12px; font-style: italic;">
              Select an object to view its properties
            </div>
          `;
        }
        return;
      }

      // Show preview container
      objectPreviewContainer.style.display = 'block';
      
      // Generate preview based on object type
      generateObjectPreview(layer.object, objectPreview);
      
      // Generate properties
      const obj = layer.object;
      let propertiesHTML = '';

      if (obj.type === 'image') {
        const displayWidth = Math.round(obj.width * obj.scaleX);
        const displayHeight = Math.round(obj.height * obj.scaleY);
        const originalWidth = Math.round(obj.width);
        const originalHeight = Math.round(obj.height);
        const scaleX = Math.round(obj.scaleX * 100);
        const scaleY = Math.round(obj.scaleY * 100);
        const rotation = Math.round(obj.angle || 0);
        const x = Math.round(obj.left || 0);
        const y = Math.round(obj.top || 0);

        // Calculate DPI for the image
        const dpiInfo = calculateDPI(originalWidth, originalHeight, displayWidth, displayHeight);
        const dpiXQuality = getDPIQualityInfo(dpiInfo.dpiX);
        const dpiYQuality = getDPIQualityInfo(dpiInfo.dpiY);

        propertiesHTML = `
          <div style="margin-bottom: 16px;">
            <div style="font-weight: bold; color: #f4a012; margin-bottom: 8px;">Image Properties</div>
            <div style="font-size: 12px; color: #ccc; line-height: 1.4;">
              <div><strong>Display Size:</strong> ${displayWidth} × ${displayHeight}px</div>
              <div><strong>Original Size:</strong> ${originalWidth} × ${originalHeight}px</div>
              <div><strong>Scale:</strong> ${scaleX}% × ${scaleY}%</div>
              <div><strong>Rotation:</strong> ${rotation}°</div>
              <div><strong>Position:</strong> X: ${x}, Y: ${y}</div>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #444;">
                <div style="font-weight: bold; color: #f4a012; margin-bottom: 4px;">DPI Quality:</div>
                <div><strong>Horizontal DPI:</strong> <span style="color: ${dpiXQuality.color};">${dpiInfo.dpiX} (${dpiXQuality.quality})</span></div>
                <div><strong>Vertical DPI:</strong> <span style="color: ${dpiYQuality.color};">${dpiInfo.dpiY} (${dpiYQuality.quality})</span></div>
              </div>
            </div>
          </div>
        `;
      } else if (obj.type === 'text') {
        const fontSize = Math.round(obj.fontSize || 16);
        const fontFamily = obj.fontFamily || 'Arial';
        const textLength = obj.text ? obj.text.length : 0;
        const x = Math.round(obj.left || 0);
        const y = Math.round(obj.top || 0);
        const rotation = Math.round(obj.angle || 0);

        propertiesHTML = `
          <div style="margin-bottom: 16px;">
            <div style="font-weight: bold; color: #f4a012; margin-bottom: 8px;">Text Properties</div>
            <div style="font-size: 12px; color: #ccc; line-height: 1.4;">
              <div><strong>Characters:</strong> ${textLength}</div>
              <div><strong>Font:</strong> ${fontFamily}</div>
              <div><strong>Size:</strong> ${fontSize}px</div>
              <div><strong>Position:</strong> X: ${x}, Y: ${y}</div>
              <div><strong>Rotation:</strong> ${rotation}°</div>
            </div>
          </div>
        `;
      } else if (obj.type === 'rect' || obj.type === 'circle' || obj.type === 'triangle' || obj.type === 'polygon' || obj.type === 'line' || obj.type === 'path') {
        const width = Math.round(obj.width * (obj.scaleX || 1));
        const height = Math.round(obj.height * (obj.scaleY || 1));
        const x = Math.round(obj.left || 0);
        const y = Math.round(obj.top || 0);
        const rotation = Math.round(obj.angle || 0);
        const fillColor = obj.fill || 'transparent';
        const strokeColor = obj.stroke || 'none';
        const strokeWidth = obj.strokeWidth || 0;

        propertiesHTML = `
          <div style="margin-bottom: 16px;">
            <div style="font-weight: bold; color: #f4a012; margin-bottom: 8px;">Shape Properties</div>
            <div style="font-size: 12px; color: #ccc; line-height: 1.4;">
              <div><strong>Size:</strong> ${width} × ${height}px</div>
              <div><strong>Position:</strong> X: ${x}, Y: ${y}</div>
              <div><strong>Rotation:</strong> ${rotation}°</div>
              <div><strong>Fill:</strong> <span style="color: ${fillColor};">${fillColor}</span></div>
              <div><strong>Stroke:</strong> <span style="color: ${strokeColor};">${strokeColor}</span></div>
              <div><strong>Stroke Width:</strong> ${strokeWidth}px</div>
            </div>
          </div>
        `;
      }

      propertiesContent.innerHTML = propertiesHTML;
    }

    function generateObjectPreview(object, previewContainer) {
      if (!object || !previewContainer) {
        return;
      }
      
      previewContainer.innerHTML = '';
      
      // Create a small canvas for preview
      const previewCanvas = document.createElement('canvas');
      previewCanvas.width = 120;
      previewCanvas.height = 80;
      previewCanvas.style.borderRadius = '4px';
      previewCanvas.style.border = '1px solid #555';
      
      const previewCtx = previewCanvas.getContext('2d');
      
      // Set background
      previewCtx.fillStyle = '#1a1a1a';
      previewCtx.fillRect(0, 0, 120, 80);
      
      // Scale and position object for preview
      const objectWidth = object.width || 100;
      const objectHeight = object.height || 100;
      const scale = Math.min(100 / objectWidth, 60 / objectHeight, 0.8);
      const scaledWidth = objectWidth * scale;
      const scaledHeight = objectHeight * scale;
      const x = (120 - scaledWidth) / 2;
      const y = (80 - scaledHeight) / 2;
      
      // Draw object based on type
      if (object.type === 'image') {
        // For images, try to draw the image element
        if (object._element) {
          previewCtx.drawImage(object._element, x, y, scaledWidth, scaledHeight);
        } else {
          // Fallback for images without element
          previewCtx.fillStyle = '#f4a012';
          previewCtx.fillRect(x, y, scaledWidth, scaledHeight);
          previewCtx.fillStyle = '#000';
          previewCtx.font = '10px Arial';
          previewCtx.textAlign = 'center';
          previewCtx.fillText('Image', 60, 45);
        }
      } else if (object.type === 'text') {
        // For text objects
        previewCtx.fillStyle = object.fill || '#f4a012';
        previewCtx.font = `${Math.max(8, object.fontSize * scale)}px ${object.fontFamily || 'Arial'}`;
        previewCtx.textAlign = 'center';
        previewCtx.textBaseline = 'middle';
        previewCtx.fillText(object.text || 'Text', 60, 40);
      } else if (object.type === 'rect') {
        // For rectangles
        previewCtx.fillStyle = object.fill || '#f4a012';
        previewCtx.fillRect(x, y, scaledWidth, scaledHeight);
        if (object.stroke && object.strokeWidth > 0) {
          previewCtx.strokeStyle = object.stroke;
          previewCtx.lineWidth = object.strokeWidth * scale;
          previewCtx.strokeRect(x, y, scaledWidth, scaledHeight);
        }
      } else if (object.type === 'circle') {
        // For circles
        previewCtx.fillStyle = object.fill || '#f4a012';
        previewCtx.beginPath();
        previewCtx.arc(60, 40, Math.min(scaledWidth, scaledHeight) / 2, 0, 2 * Math.PI);
        previewCtx.fill();
        if (object.stroke && object.strokeWidth > 0) {
          previewCtx.strokeStyle = object.stroke;
          previewCtx.lineWidth = object.strokeWidth * scale;
          previewCtx.stroke();
        }
      } else if (object.type === 'triangle') {
        // For triangles
        previewCtx.fillStyle = object.fill || '#f4a012';
        previewCtx.beginPath();
        previewCtx.moveTo(60, y);
        previewCtx.lineTo(x, y + scaledHeight);
        previewCtx.lineTo(x + scaledWidth, y + scaledHeight);
        previewCtx.closePath();
        previewCtx.fill();
        if (object.stroke && object.strokeWidth > 0) {
          previewCtx.strokeStyle = object.stroke;
          previewCtx.lineWidth = object.strokeWidth * scale;
          previewCtx.stroke();
        }
      } else if (object.type === 'polygon') {
        // For polygons (including star, hexagon, etc.)
        previewCtx.fillStyle = object.fill || '#f4a012';
        previewCtx.beginPath();
        const points = object.points;
        if (points && points.length > 0) {
          const centerX = 60;
          const centerY = 40;
          const maxRadius = Math.min(scaledWidth, scaledHeight) / 2;
          
          points.forEach((point, index) => {
            const px = centerX + (point.x * scale);
            const py = centerY + (point.y * scale);
            if (index === 0) {
              previewCtx.moveTo(px, py);
            } else {
              previewCtx.lineTo(px, py);
            }
          });
          previewCtx.closePath();
          previewCtx.fill();
          if (object.stroke && object.strokeWidth > 0) {
            previewCtx.strokeStyle = object.stroke;
            previewCtx.lineWidth = object.strokeWidth * scale;
            previewCtx.stroke();
          }
        }
      } else if (object.type === 'line' || object.type === 'path') {
        // For lines and paths
        previewCtx.strokeStyle = object.stroke || '#f4a012';
        previewCtx.lineWidth = Math.max(1, (object.strokeWidth || 4) * scale);
        previewCtx.lineCap = 'round';
        
        if (object.type === 'line') {
          previewCtx.beginPath();
          previewCtx.moveTo(x, 40);
          previewCtx.lineTo(x + scaledWidth, 40);
          previewCtx.stroke();
        } else if (object.type === 'path') {
          // For path objects (arrows, curves), draw a simple line as preview
          previewCtx.beginPath();
          previewCtx.moveTo(x, 40);
          previewCtx.lineTo(x + scaledWidth, 40);
          previewCtx.stroke();
        }
      } else {
        // Fallback for other object types
        previewCtx.fillStyle = '#f4a012';
        previewCtx.fillRect(x, y, scaledWidth, scaledHeight);
        previewCtx.fillStyle = '#000';
        previewCtx.font = '10px Arial';
        previewCtx.textAlign = 'center';
        previewCtx.fillText('Object', 60, 45);
      }
      
      previewContainer.appendChild(previewCanvas);
    }

    // Toggle layer visibility
    function toggleLayerVisibility(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer) {
        layer.visible = !layer.visible;
        
        // Update canvas object visibility and controls
        if (layer.object && deskPadModalCanvas) {
          layer.object.visible = layer.visible;
          
          // Hide borders and controls when layer is hidden
          if (!layer.visible) {
            layer.object.hasBorders = false;
            layer.object.hasControls = false;
            // Deselect if this object is currently selected
            if (deskPadModalCanvas.getActiveObject() === layer.object) {
              deskPadModalCanvas.discardActiveObject();
            }
          } else {
            // Restore borders and controls when layer is shown
            layer.object.hasBorders = true;
            layer.object.hasControls = true;
          }
          
          deskPadModalCanvas.renderAll();
        }
        
        updateLayersList();
      }
    }

    // Toggle layer lock
    function toggleLayerLock(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer) {
        layer.locked = !layer.locked;
        
        // Update canvas object lock
        if (layer.object && deskPadModalCanvas) {
          layer.object.selectable = !layer.locked;
          layer.object.evented = !layer.locked;
          deskPadModalCanvas.renderAll();
        }
        
        updateLayersList();
      }
    }

    // Delete layer
    function deleteLayer(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer && layer.type !== 'Canvas') {
        // Remove from canvas
        if (layer.object && deskPadModalCanvas) {
          deskPadModalCanvas.remove(layer.object);
          deskPadModalCanvas.renderAll();
        }
        
        // Remove from layers array
        layers = layers.filter(l => l.id !== layerId);
        
        // Update active layer
        if (activeLayerId === layerId) {
          activeLayerId = layers.length > 0 ? layers[0].id : null;
        }
        
        updateLayersList();
      }
    }

    // Select layer
    function selectLayer(layerId) {
      
      activeLayerId = layerId;
      
      // Select object on canvas
      const layer = layers.find(l => l.id === layerId);
      
      
      if (layer && layer.object && deskPadModalCanvas) {
        // Only select if the layer is visible
        if (layer.visible) {
          deskPadModalCanvas.setActiveObject(layer.object);
          // Ensure borders and controls are enabled for visible layers
          layer.object.hasBorders = true;
          layer.object.hasControls = true;
        } else {
          // If layer is hidden, deselect any current selection
          deskPadModalCanvas.discardActiveObject();
        }
        deskPadModalCanvas.renderAll();
      }
      
      // Ensure layers menu is open so properties panel elements are available
      const layersMenu = document.getElementById('layers-menu');
      if (layersMenu && !layersMenu.classList.contains('active')) {
        layersMenu.classList.add('active');
      }
      
      // Update properties panel after ensuring menu is open
      setTimeout(() => {
        updatePropertiesPanel(layer);
      }, 100);
      
      updateLayersList();
    }

    // Setup layer management with drag and drop
    function setupLayerDragAndDrop() {
      // Remove any existing listeners to prevent duplicates
      document.removeEventListener('mousedown', handleLayerMouseDown);
      document.removeEventListener('mousemove', handleLayerMouseMove);
      document.removeEventListener('mouseup', handleLayerMouseUp);
      
      // Add event listeners for layer reordering
      document.addEventListener('mousedown', handleLayerMouseDown);
      document.addEventListener('mousemove', handleLayerMouseMove);
      document.addEventListener('mouseup', handleLayerMouseUp);
    }

    // Mouse event handlers for drag and drop
    function handleLayerMouseDown(e) {
      const layerItem = e.target.closest('.layer-item');
      if (layerItem && !e.target.closest('.layer-control-btn') && !e.target.closest('.layer-name')) {
        // Store initial position for drag threshold
        e.preventDefault();
        dragStartY = e.clientY;
        dragStartX = e.clientX;
        potentialDragLayer = layerItem;
      }
    }

    function handleLayerMouseMove(e) {
      if (draggedLayer) {
        e.preventDefault();
        handleDrag(e);
      } else if (potentialDragLayer) {
        // Check if mouse has moved enough to start dragging
        const deltaX = Math.abs(e.clientX - dragStartX);
        const deltaY = Math.abs(e.clientY - dragStartY);
        const dragThreshold = 5; // pixels
        
        if (deltaX > dragThreshold || deltaY > dragThreshold) {
          startDrag(potentialDragLayer, dragStartY, dragStartX);
          potentialDragLayer = null;
        }
      }
    }

    function handleLayerMouseUp(e) {
      if (draggedLayer) {
        e.preventDefault();
        stopDrag(e);
      }
      // Reset potential drag
      potentialDragLayer = null;
    }

    // Start dragging
    function startDrag(layerItem, startY, startX) {
      const layerId = layerItem.dataset.layerId;
      const layer = layers.find(l => l.id === layerId);
      
      if (!layer || layer.locked) {
        return;
      }


      
      draggedLayer = layerItem;
      dragStartY = startY;
      dragStartX = startX;
      
      // Store current visual index
      const sortedLayers = [...layers].sort((a, b) => b.order - a.order);
      draggedLayer.currentVisualIndex = sortedLayers.findIndex(l => l.id === layerId);
      
      // Get original position
      const rect = layerItem.getBoundingClientRect();
      
      // Create a drag clone instead of moving the original
      const dragClone = layerItem.cloneNode(true);
      dragClone.classList.add('drag-clone');
      dragClone.style.position = 'fixed';
      dragClone.style.zIndex = '10000';
      dragClone.style.pointerEvents = 'none';
      dragClone.style.width = rect.width + 'px';
      dragClone.style.left = rect.left + 'px';
      dragClone.style.top = rect.top + 'px';
      dragClone.style.opacity = '0.9';
      dragClone.style.transform = 'rotate(3deg) scale(1.02)';
      dragClone.style.boxShadow = '0 8px 24px rgba(244, 160, 18, 0.4)';
      dragClone.style.border = '2px solid #f4a012';
      dragClone.style.borderRadius = '8px';
      dragClone.style.transition = 'none';
      
      // Add clone to body
      document.body.appendChild(dragClone);
      
      // Store reference to clone
      draggedLayer.dragClone = dragClone;
      
      // Make original semi-transparent but keep it in place
      layerItem.classList.add('dragging');
      layerItem.style.opacity = '0.3';
      
      // Create drop indicators
      createDropIndicators();
    }

    // Handle drag movement
    function handleDrag(e) {
      if (!draggedLayer || !draggedLayer.dragClone) {
        return;
      }

      const rect = draggedLayer.getBoundingClientRect();
      const newX = e.clientX - rect.width / 2;
      const newY = e.clientY - rect.height / 2;
      
      // Move the clone to follow the cursor
      draggedLayer.dragClone.style.left = newX + 'px';
      draggedLayer.dragClone.style.top = newY + 'px';

      // Store current mouse position for use in stopDrag
      draggedLayer.currentMouseY = e.clientY;

      // Update drop indicators
      updateDropIndicators(e.clientY);
    }

    // Stop dragging
    function stopDrag(e) {
      if (!draggedLayer) {
        return;
      }

      const layerId = draggedLayer.dataset.layerId;

      // Clean up the dragged element
      const draggedElement = draggedLayer;
      draggedLayer = null;
      removeDropIndicators();

      // Clean up the original element
      if (draggedElement) {
        draggedElement.classList.remove('dragging');
        draggedElement.style.opacity = '';
      }

      // Remove the drag clone
      if (draggedElement && draggedElement.dragClone) {
        draggedElement.dragClone.remove();
        draggedElement.dragClone = null;
      }

      // Apply the final position change using the helper function
      const layersList = document.getElementById('layers-list');
      // Use stored mouse position or event position
      const mouseY = draggedElement.currentMouseY || (e ? e.clientY : 0);
      const afterElement = getDragAfterElement(layersList, mouseY);
      
      if (afterElement !== draggedElement) {
        const layer = layers.find(l => l.id === layerId);
        if (layer) {
          // Remove the dragged element from its current position
          layersList.removeChild(draggedElement);
          
          // Insert it at the new position
          if (afterElement) {
            // Insert before the target element
            layersList.insertBefore(draggedElement, afterElement);
          } else {
            // Insert at the end (bottom)
            layersList.appendChild(draggedElement);
          }
          
          // Calculate the new position index
          const layerItems = layersList.querySelectorAll('.layer-item');
          const newIndex = Array.from(layerItems).indexOf(draggedElement);
          
          // Update the layer order in the data structure
          updateLayerOrderToPosition(layer, newIndex);
          
          // Update canvas object positions
          updateCanvasObjectOrder();
          
          showDragSuccessFeedback(layer.name);
        }
      }
    }

    // Helper function to find the element directly after the cursor (following friend's pattern)
    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.layer-item:not(.dragging)')];
      
      if (draggableElements.length === 0) {
        return null;
      }
      
      const result = draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        // offset < 0 means the cursor is above the element's center
        if (offset < 0 && offset > closest.offset) {
          return { offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY });
      
      // If we found an element above the cursor, return it
      if (result.element) {
        return result.element;
      }
      
      // If cursor is above all elements, return the first element (drop at top)
      if (y < draggableElements[0].getBoundingClientRect().top) {
        return draggableElements[0];
      }
      
      // If cursor is below all elements, return null (drop at bottom)
      const lastElement = draggableElements[draggableElements.length - 1];
      if (y > lastElement.getBoundingClientRect().bottom) {
        return null;
      }
      
      // If cursor is in the middle of elements, find the closest one
      for (let i = 0; i < draggableElements.length; i++) {
        const element = draggableElements[i];
        const rect = element.getBoundingClientRect();
        
        // If cursor is in the top half of this element, drop above it
        if (y >= rect.top && y < rect.top + rect.height / 2) {
          return element;
        }
        
        // If cursor is in the bottom half of this element, drop below it
        if (y >= rect.top + rect.height / 2 && y <= rect.bottom) {
          return i < draggableElements.length - 1 ? draggableElements[i + 1] : null;
        }
      }
      
      // Fallback: return null (drop at bottom)
      return null;
    }

    // Update canvas object order to match layer order
    function updateCanvasObjectOrder() {
      if (!deskPadModalCanvas) return;
      
      // Get layers sorted by order (top to bottom)
      const sortedLayers = [...layers].sort((a, b) => b.order - a.order);
      
      // Move all canvas objects to their correct positions
      // In Fabric.js: index 0 = bottom layer, highest index = top layer
      sortedLayers.forEach((layer, visualIndex) => {
        if (layer.object) {
          // Convert visual index to Fabric.js index
          // visualIndex 0 = top layer = highest Fabric.js index
          const fabricIndex = sortedLayers.length - 1 - visualIndex;
          deskPadModalCanvas.moveTo(layer.object, fabricIndex);
        }
      });
      
      deskPadModalCanvas.requestRenderAll();
    }

    // Update layer order to a specific position
    function updateLayerOrderToPosition(layer, targetPosition) {
      // Get current sorted layers (top to bottom)
      const sortedLayers = [...layers].sort((a, b) => b.order - a.order);
      const currentIndex = sortedLayers.findIndex(l => l.id === layer.id);
      
      if (currentIndex === targetPosition) {
        return; // Already at target position
      }
      
      // Remove layer from current position
      sortedLayers.splice(currentIndex, 1);
      
      // Insert at target position
      sortedLayers.splice(targetPosition, 0, layer);
      
      // Update all order values based on new positions
      // Higher order = higher in stack (top layer)
      sortedLayers.forEach((l, visualIndex) => {
        l.order = sortedLayers.length - 1 - visualIndex;
      });
      
      // Update the original layers array to match the new order
      layers.length = 0; // Clear the original array
      layers.push(...sortedLayers); // Add all layers in the new order
    }

    // Create drop indicators
    function createDropIndicators() {
      const layersList = document.getElementById('layers-list');
      if (!layersList) return;
      
      // Create top indicator
      const topIndicator = document.createElement('div');
      topIndicator.className = 'drop-indicator top';
      topIndicator.style.position = 'absolute';
      topIndicator.style.left = '0';
      topIndicator.style.right = '0';
      topIndicator.style.height = '3px';
      topIndicator.style.backgroundColor = '#f4a012';
      topIndicator.style.zIndex = '999';
      topIndicator.style.display = 'none';
      topIndicator.style.borderRadius = '2px';
      
      layersList.appendChild(topIndicator);
      
      // Create bottom indicator
      const bottomIndicator = document.createElement('div');
      bottomIndicator.className = 'drop-indicator bottom';
      bottomIndicator.style.position = 'absolute';
      bottomIndicator.style.left = '0';
      bottomIndicator.style.right = '0';
      bottomIndicator.style.height = '3px';
      bottomIndicator.style.backgroundColor = '#f4a012';
      bottomIndicator.style.zIndex = '999';
      bottomIndicator.style.display = 'none';
      bottomIndicator.style.borderRadius = '2px';
      
      layersList.appendChild(bottomIndicator);
    }

    // Update drop indicators
    function updateDropIndicators(mouseY) {
      const layersList = document.getElementById('layers-list');
      if (!layersList) return;
      
      const layerItems = layersList.querySelectorAll('.layer-item:not(.dragging)');
      const topIndicator = layersList.querySelector('.drop-indicator.top');
      const bottomIndicator = layersList.querySelector('.drop-indicator.bottom');
      
      if (!topIndicator || !bottomIndicator) return;
      
      // Hide all indicators first
      topIndicator.style.display = 'none';
      bottomIndicator.style.display = 'none';
      
      // Remove all drop-target classes
      layerItems.forEach(item => item.classList.remove('drop-target'));
      
      const layersListRect = layersList.getBoundingClientRect();
      
      // Check if we're at the very top (first 10px of the list)
      if (mouseY < layersListRect.top + 10) {
        // Drop at top
        topIndicator.style.display = 'block';
        topIndicator.style.top = '0';
        topIndicator.style.height = '4px';
        topIndicator.style.backgroundColor = '#f4a012';
        return;
      }
      
      // Check if we're at the very bottom (last 10px of the list)
      if (mouseY > layersListRect.bottom - 10) {
        // Drop at bottom
        bottomIndicator.style.display = 'block';
        bottomIndicator.style.top = (layersListRect.height - 4) + 'px';
        bottomIndicator.style.height = '4px';
        bottomIndicator.style.backgroundColor = '#f4a012';
        return;
      }
      
      // Find drop position between layers
      for (let i = 0; i < layerItems.length; i++) {
        const item = layerItems[i];
        const rect = item.getBoundingClientRect();
        
        // Check if mouse is in the top half of this layer (drop above)
        if (mouseY >= rect.top && mouseY < rect.top + rect.height / 2) {
          // Show indicator above this layer
          const indicatorTop = rect.top - layersListRect.top;
          topIndicator.style.display = 'block';
          topIndicator.style.top = indicatorTop + 'px';
          topIndicator.style.height = '4px';
          topIndicator.style.backgroundColor = '#f4a012';
          return;
        }
        
        // Check if mouse is in the bottom half of this layer (drop below)
        if (mouseY >= rect.top + rect.height / 2 && mouseY <= rect.bottom) {
          // Show indicator below this layer
          const indicatorTop = rect.bottom - layersListRect.top;
          bottomIndicator.style.display = 'block';
          bottomIndicator.style.top = indicatorTop + 'px';
          bottomIndicator.style.height = '4px';
          bottomIndicator.style.backgroundColor = '#f4a012';
          return;
        }
      }
    }

    // Remove drop indicators
    function removeDropIndicators() {
      const layersList = document.getElementById('layers-list');
      if (!layersList) return;
      
      const indicators = layersList.querySelectorAll('.drop-indicator');
      indicators.forEach(indicator => indicator.remove());
    }



    // Show success feedback for drag and drop
    function showDragSuccessFeedback(layerName) {
      // Create a temporary success message
      const successMsg = document.createElement('div');
      successMsg.textContent = `Moved "${layerName}"`;
      successMsg.style.position = 'fixed';
      successMsg.style.top = '20px';
      successMsg.style.right = '20px';
      successMsg.style.background = '#4CAF50';
      successMsg.style.color = 'white';
      successMsg.style.padding = '8px 16px';
      successMsg.style.borderRadius = '4px';
      successMsg.style.fontSize = '14px';
      successMsg.style.zIndex = '10001';
      successMsg.style.opacity = '0';
      successMsg.style.transform = 'translateX(100%)';
      successMsg.style.transition = 'all 0.3s ease';
      
      document.body.appendChild(successMsg);
      
      // Animate in
      setTimeout(() => {
        successMsg.style.opacity = '1';
        successMsg.style.transform = 'translateX(0)';
      }, 10);
      
      // Animate out and remove
      setTimeout(() => {
        successMsg.style.opacity = '0';
        successMsg.style.transform = 'translateX(100%)';
        setTimeout(() => {
          successMsg.remove();
        }, 300);
      }, 2000);
    }

    // Initialize layer management when layers menu is opened
    // (This is now handled directly in the layers toggle button click handler)

    // Function to update alignment toolbar based on selected object type
    function updateAlignmentToolbar() {
      if (!deskPadModalCanvas) return;
      
      const activeObject = deskPadModalCanvas.getActiveObject();
      const alignmentToolbar = document.getElementById('alignment-toolbar');
      
      if (!alignmentToolbar) return;
      
      // Get all alignment buttons
      const imageButtons = ['fill-canvas', 'fit-canvas', 'center-canvas'];
      const duplicateButton = ['duplicate-object'];
      const layerButtons = ['bring-forward', 'send-backward'];
      const commonButtons = ['align-top', 'align-center', 'align-bottom', 'align-left', 'align-right'];
      
      if (activeObject) {
        // Show common alignment buttons for all object types
        commonButtons.forEach(btnId => {
          const btn = document.getElementById(btnId);
          if (btn) btn.style.display = 'flex';
        });
        
        // Show duplicate button for all object types
        duplicateButton.forEach(btnId => {
          const btn = document.getElementById(btnId);
          if (btn) btn.style.display = 'flex';
        });
        
        // Show layer ordering buttons for all object types
        layerButtons.forEach(btnId => {
          const btn = document.getElementById(btnId);
          if (btn) btn.style.display = 'flex';
        });
        
        if (activeObject.type === 'i-text' || activeObject.type === 'text') {
          // Hide image-specific buttons for text
          imageButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'none';
          });
        } else if (activeObject.type === 'image') {
          // Show image-specific buttons
          imageButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'flex';
          });
        } else if (activeObject.type === 'rect' || activeObject.type === 'circle' || activeObject.type === 'triangle' || activeObject.type === 'ellipse' || activeObject.type === 'polygon') {
          // Hide image-specific buttons for shapes
          imageButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'none';
          });
        }
      } else {
        // No selection - show all buttons
        [...commonButtons, ...imageButtons, ...duplicateButton, ...layerButtons].forEach(btnId => {
          const btn = document.getElementById(btnId);
          if (btn) btn.style.display = 'flex';
        });
      }
    }

    // Alignment button event listeners
    const alignmentButtons = [
      'align-top', 'align-center', 'align-bottom',
      'align-left', 'align-right', 'fill-canvas', 'fit-canvas', 'center-canvas',
      'duplicate-object', 'bring-forward', 'send-backward'
    ];

    alignmentButtons.forEach(btnId => {
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.addEventListener('click', () => {
          // Check if objects are selected
          if (!deskPadModalCanvas) {

            return;
          }
          
          const activeObjects = deskPadModalCanvas.getActiveObjects();
          if (activeObjects.length === 0) {

            // Show visual feedback
            btn.style.background = '#ff4444';
            btn.style.color = '#fff';
            setTimeout(() => {
              btn.style.background = '';
              btn.style.color = '';
            }, 500);
            return;
          }
          
          // Remove active class from all buttons
          alignmentButtons.forEach(id => {
            const button = document.getElementById(id);
            if (button) button.classList.remove('active');
          });
          
          // Add active class to clicked button
          btn.classList.add('active');
          
          // Handle alignment action
          handleAlignment(btnId);
          
          // Remove active class after a short delay
          setTimeout(() => {
            btn.classList.remove('active');
          }, 300);
        });
      }
    });
    
    // Opacity slider functionality
    function setupOpacitySlider() {
      const opacitySlider = document.getElementById('opacity-slider');
      const opacityValue = document.getElementById('opacity-value');
      
      if (!opacitySlider || !opacityValue) return;
      
      // Update opacity when slider changes
      opacitySlider.addEventListener('input', function() {
        const opacity = this.value / 100;
        opacityValue.textContent = this.value + '%';
        
        if (!deskPadModalCanvas) return;
        
        const activeObjects = deskPadModalCanvas.getActiveObjects();
        if (activeObjects.length === 0) return;
        
        // Apply opacity to all selected objects
        activeObjects.forEach(obj => {
          obj.set('opacity', opacity);
        });
        
        deskPadModalCanvas.requestRenderAll();
      });
      
      // Update slider when selection changes
      function updateOpacitySlider() {
        if (!deskPadModalCanvas) return;
        
        const activeObjects = deskPadModalCanvas.getActiveObjects();
        if (activeObjects.length === 0) {
          // Reset slider when no selection
          opacitySlider.value = 100;
          opacityValue.textContent = '100%';
          return;
        }
        
        // Use the opacity of the first selected object
        const firstObject = activeObjects[0];
        const opacity = firstObject.opacity || 1;
        const opacityPercent = Math.round(opacity * 100);
        
        opacitySlider.value = opacityPercent;
        opacityValue.textContent = opacityPercent + '%';
      }
      
      // Update slider on selection change
      deskPadModalCanvas.on('selection:created', updateOpacitySlider);
      deskPadModalCanvas.on('selection:updated', updateOpacitySlider);
      deskPadModalCanvas.on('selection:cleared', updateOpacitySlider);
      
      // Initial update
      updateOpacitySlider();
    }
    
    // Alignment function
    function handleAlignment(alignmentType) {
      if (!deskPadModalCanvas) {

        return;
      }
      
      const activeObjects = deskPadModalCanvas.getActiveObjects();
      if (activeObjects.length === 0) {

        return;
      }
      
      const canvas = deskPadModalCanvas;
      
      // Get the actual canvas dimensions (these are the logical dimensions)
      const canvasWidth = canvas.getWidth();
      const canvasHeight = canvas.getHeight();
      
      // Get the visual canvas container dimensions
      const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
      const visualWidth = canvasContainer ? canvasContainer.clientWidth : canvasWidth;
      const visualHeight = canvasContainer ? canvasContainer.clientHeight : canvasHeight;
      

      
      // Handle alignment using logical canvas dimensions
      activeObjects.forEach((obj, index) => {
        const oldLeft = obj.left;
        const oldTop = obj.top;
        
        // Calculate the actual scaled dimensions
        const scaledWidth = obj.getScaledWidth();
        const scaledHeight = obj.getScaledHeight();
        
        let newLeft = oldLeft;
        let newTop = oldTop;
        
        // Account for origin point when calculating alignment
        const originX = obj.originX || 'left';
        const originY = obj.originY || 'top';
        
        switch(alignmentType) {
          case 'align-top':
            if (originY === 'center') {
              newTop = scaledHeight / 2;
            } else if (originY === 'bottom') {
              newTop = scaledHeight;
            } else {
              newTop = 0;
            }
            break;
          case 'align-center':
            // Center both horizontally and vertically
            // Horizontal centering
            if (originX === 'center') {
              newLeft = canvasWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth - scaledWidth / 2;
            } else {
              newLeft = (canvasWidth - scaledWidth) / 2;
            }
            
            // Vertical centering
            if (originY === 'center') {
              newTop = canvasHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight - scaledHeight / 2;
            } else {
              newTop = (canvasHeight - scaledHeight) / 2;
            }
            break;
          case 'align-bottom':
            if (originY === 'center') {
              newTop = canvasHeight - scaledHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight;
            } else {
              newTop = canvasHeight - scaledHeight;
            }
            break;
          case 'align-left':
            if (originX === 'center') {
              newLeft = scaledWidth / 2;
            } else if (originX === 'right') {
              newLeft = scaledWidth;
            } else {
              newLeft = 0;
            }
            break;
          case 'fill-canvas':
            // Scale image to fill canvas while maintaining aspect ratio
            const canvasAspect = canvasWidth / canvasHeight;
            const imageAspect = scaledWidth / scaledHeight;
            
            let newScaleX, newScaleY;
            if (imageAspect > canvasAspect) {
              // Image is wider than canvas - fit to width
              newScaleX = canvasWidth / (obj.width || scaledWidth);
              newScaleY = newScaleX;
            } else {
              // Image is taller than canvas - fit to height
              newScaleY = canvasHeight / (obj.height || scaledHeight);
              newScaleX = newScaleY;
            }
            
            // Center the image
            if (originX === 'center') {
              newLeft = canvasWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth;
            } else {
              newLeft = canvasWidth / 2;
            }
            
            if (originY === 'center') {
              newTop = canvasHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight;
            } else {
              newTop = canvasHeight / 2;
            }
            
            // Apply new scale and position
            obj.set({
              scaleX: newScaleX,
              scaleY: newScaleY,
              left: newLeft,
              top: newTop
            });
            

            
            // Force the object to update its coordinates
            obj.setCoords();
            
            // Update properties panel to refresh DPI calculations
            setTimeout(() => {
              const selectedLayer = layers.find(l => l.object === obj);
              if (selectedLayer) {
                updatePropertiesPanel(selectedLayer);
              }
            }, 100);
            break;
          case 'fit-canvas':
            // Scale image to fit canvas while maintaining aspect ratio (may have letterboxing)
            const fitCanvasAspect = canvasWidth / canvasHeight;
            const fitImageAspect = scaledWidth / scaledHeight;
            
            let fitScaleX, fitScaleY;
            if (fitImageAspect > fitCanvasAspect) {
              // Image is wider than canvas - fit to height
              fitScaleY = canvasHeight / (obj.height || scaledHeight);
              fitScaleX = fitScaleY;
            } else {
              // Image is taller than canvas - fit to width
              fitScaleX = canvasWidth / (obj.width || scaledWidth);
              fitScaleY = fitScaleX;
            }
            
            // Center the image
            if (originX === 'center') {
              newLeft = canvasWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth;
            } else {
              newLeft = canvasWidth / 2;
            }
            
            if (originY === 'center') {
              newTop = canvasHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight;
            } else {
              newTop = canvasHeight / 2;
            }
            
            // Apply new scale and position
            obj.set({
              scaleX: fitScaleX,
              scaleY: fitScaleY,
              left: newLeft,
              top: newTop
            });
            

            
            // Force the object to update its coordinates
            obj.setCoords();
            
            // Update properties panel to refresh DPI calculations
            setTimeout(() => {
              const selectedLayer = layers.find(l => l.object === obj);
              if (selectedLayer) {
                updatePropertiesPanel(selectedLayer);
              }
            }, 100);
            break;
          case 'center-canvas':
            // Just center the image without changing scale
            if (originX === 'center') {
              newLeft = canvasWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth;
            } else {
              newLeft = canvasWidth / 2;
            }
            
            if (originY === 'center') {
              newTop = canvasHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight;
            } else {
              newTop = canvasHeight / 2;
            }
            

            break;

          case 'align-right':
            if (originX === 'center') {
              newLeft = canvasWidth - scaledWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth;
            } else {
              newLeft = canvasWidth - scaledWidth;
            }
            break;
          case 'duplicate-object':
            // Universal duplicate function for all object types
            if (obj.type === 'image') {
              // Duplicate image
              fabric.Image.fromURL(obj._originalDataUrl || obj._element.src, newImg => {
                // Copy all properties from the original
                newImg.set({
                  left: obj.left + 20, // Offset slightly from original
                  top: obj.top + 20,
                  scaleX: obj.scaleX,
                  scaleY: obj.scaleY,
                  angle: obj.angle,
                  flipX: obj.flipX,
                  flipY: obj.flipY,
                  originX: obj.originX,
                  originY: obj.originY,
                  selectable: true,
                  hasControls: true,
                  hasBorders: true,
                  stroke: 'transparent',
                  strokeWidth: 0
                });
                
                // Copy original data URL
                newImg._originalDataUrl = obj._originalDataUrl;
                
                // Add to canvas
                canvas.add(newImg);
                canvas.setActiveObject(newImg);
                canvas.requestRenderAll();
                
                // Create a layer for this duplicated image
                const imageName = `Image ${layers.length + 1}`;
                const layer = createLayer(imageName, 'Image', newImg);
                
                // Set this as the active layer since the image is auto-selected
                activeLayerId = layer.id;
                selectLayer(layer.id);
                updatePropertiesPanel(layer);
              });
            } else if (obj.type === 'i-text' || obj.type === 'text') {
              // Duplicate text
              const newText = new fabric.IText(obj.text, {
                left: obj.left + 20, // Offset slightly from original
                top: obj.top + 20,
                fontSize: obj.fontSize,
                fontFamily: obj.fontFamily,
                fill: obj.fill,
                angle: obj.angle,
                scaleX: obj.scaleX,
                scaleY: obj.scaleY,
                flipX: obj.flipX,
                flipY: obj.flipY,
                originX: obj.originX,
                originY: obj.originY,
                selectable: true,
                hasControls: true,
                hasBorders: true,
                textBaseline: 'alphabetic'
              });
              
              // Note: Removed real-time text change listener to prevent layer disappearance during editing
              // Layer names will be updated only when text modal is applied
              
              // Add to canvas
              canvas.add(newText);
              canvas.setActiveObject(newText);
              canvas.requestRenderAll();
              
              // Create a layer for this duplicated text
              const textName = `Text ${layers.length + 1}`;
              const layer = createLayer(textName, 'Text', newText);
              
              // Set this as the active layer since the text is auto-selected
              activeLayerId = layer.id;
              selectLayer(layer.id);
              updatePropertiesPanel(layer);
            } else if (obj.type === 'rect' || obj.type === 'circle' || obj.type === 'triangle' || obj.type === 'ellipse' || obj.type === 'polygon') {
              // Duplicate shape
              let newShape;
              
              if (obj.type === 'rect') {
                newShape = new fabric.Rect({
                  left: obj.left + 20,
                  top: obj.top + 20,
                  width: obj.width,
                  height: obj.height,
                  fill: obj.fill,
                  stroke: obj.stroke,
                  strokeWidth: obj.strokeWidth,
                  angle: obj.angle,
                  scaleX: obj.scaleX,
                  scaleY: obj.scaleY,
                  flipX: obj.flipX,
                  flipY: obj.flipY,
                  originX: obj.originX,
                  originY: obj.originY,
                  selectable: true,
                  hasControls: true,
                  hasBorders: true
                });
              } else if (obj.type === 'circle') {
                newShape = new fabric.Circle({
                  left: obj.left + 20,
                  top: obj.top + 20,
                  radius: obj.radius,
                  fill: obj.fill,
                  stroke: obj.stroke,
                  strokeWidth: obj.strokeWidth,
                  angle: obj.angle,
                  scaleX: obj.scaleX,
                  scaleY: obj.scaleY,
                  flipX: obj.flipX,
                  flipY: obj.flipY,
                  originX: obj.originX,
                  originY: obj.originY,
                  selectable: true,
                  hasControls: true,
                  hasBorders: true
                });
              } else if (obj.type === 'triangle') {
                newShape = new fabric.Triangle({
                  left: obj.left + 20,
                  top: obj.top + 20,
                  width: obj.width,
                  height: obj.height,
                  fill: obj.fill,
                  stroke: obj.stroke,
                  strokeWidth: obj.strokeWidth,
                  angle: obj.angle,
                  scaleX: obj.scaleX,
                  scaleY: obj.scaleY,
                  flipX: obj.flipX,
                  flipY: obj.flipY,
                  originX: obj.originX,
                  originY: obj.originY,
                  selectable: true,
                  hasControls: true,
                  hasBorders: true
                });
              } else if (obj.type === 'ellipse') {
                newShape = new fabric.Ellipse({
                  left: obj.left + 20,
                  top: obj.top + 20,
                  rx: obj.rx,
                  ry: obj.ry,
                  fill: obj.fill,
                  stroke: obj.stroke,
                  strokeWidth: obj.strokeWidth,
                  angle: obj.angle,
                  scaleX: obj.scaleX,
                  scaleY: obj.scaleY,
                  flipX: obj.flipX,
                  flipY: obj.flipY,
                  originX: obj.originX,
                  originY: obj.originY,
                  selectable: true,
                  hasControls: true,
                  hasBorders: true
                });
              } else if (obj.type === 'polygon') {
                newShape = new fabric.Polygon(obj.points, {
                  left: obj.left + 20,
                  top: obj.top + 20,
                  fill: obj.fill,
                  stroke: obj.stroke,
                  strokeWidth: obj.strokeWidth,
                  angle: obj.angle,
                  scaleX: obj.scaleX,
                  scaleY: obj.scaleY,
                  flipX: obj.flipX,
                  flipY: obj.flipY,
                  originX: obj.originX,
                  originY: obj.originY,
                  selectable: true,
                  hasControls: true,
                  hasBorders: true
                });
              }
              
              if (newShape) {
                // Add to canvas
                canvas.add(newShape);
                canvas.setActiveObject(newShape);
                canvas.requestRenderAll();
                
                // Create a layer for this duplicated shape
                const shapeName = getShapeDisplayName(obj.shapeType || 'shape');
                const layer = createLayer(shapeName, 'Shape', newShape);
                
                // Set this as the active layer since the shape is auto-selected
                activeLayerId = layer.id;
                selectLayer(layer.id);
                updatePropertiesPanel(layer);
              }
            }
            break;
          case 'bring-forward':
            // Bring the selected object forward in the layer stack
            if (activeLayerId) {
              bringLayerForward(activeLayerId);
            }
            break;
          case 'send-backward':
            // Send the selected object backward in the layer stack
            if (activeLayerId) {
              sendLayerBackward(activeLayerId);
            }
            break;

        }
        
        // Apply the new position
        obj.set({
          left: newLeft,
          top: newTop
        });
        

        
        // Force the object to update its coordinates
        obj.setCoords();
        

      });
      
      // Force canvas to update
      canvas.requestRenderAll();
      canvas.calcOffset();
      

      

      
      // Add visual feedback
      showAlignmentFeedback(alignmentType);
    }
    
    // Helper function to ensure canvas is in a known state for alignment
    function ensureCanvasAlignmentState() {
      if (!deskPadModalCanvas) return;
      
      const canvas = deskPadModalCanvas;
      
      // Reset viewport transform to identity (no zoom/pan)
      canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
      
      // Ensure canvas is at 100% zoom
      canvas.setZoom(1);
      
      // Recalculate everything
      canvas.requestRenderAll();
      canvas.calcOffset();
      

    }
    

    
    // Visual feedback for alignment
    function showAlignmentFeedback(alignmentType) {
      // Create a temporary visual indicator
      const feedback = document.createElement('div');
      feedback.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(244, 160, 18, 0.9);
        color: #222;
        padding: 8px 16px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
        z-index: 20000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      // Create appropriate feedback text based on action type
      let feedbackText = '';
      if (alignmentType.startsWith('align-')) {
        feedbackText = `Aligned: ${alignmentType.replace('align-', '').toUpperCase()}`;
      } else if (alignmentType === 'duplicate-image') {
        feedbackText = 'Image Duplicated';
      } else if (alignmentType === 'pattern-mode') {
        feedbackText = 'Pattern Mode Toggled';
      } else {
        feedbackText = alignmentType.replace('-', ' ').toUpperCase();
      }
      feedback.textContent = feedbackText;
      
      document.body.appendChild(feedback);
      
      // Show feedback
      setTimeout(() => feedback.style.opacity = '1', 10);
      
      // Hide feedback after 1 second
      setTimeout(() => {
        feedback.style.opacity = '0';
        setTimeout(() => document.body.removeChild(feedback), 300);
      }, 1000);
    } 

    // Shape Management Functions
    function hideAllPopups() {
      // Hide all popups
      const popups = [
        'add-shapes-popup',
        'add-text-popup',
        'recent-images-popup',
        'pad-size-popup',
        'background-popup'
      ];
      
      popups.forEach(popupId => {
        const popup = document.getElementById(popupId);
        if (popup) {
          popup.classList.remove('show');
        }
      });
    }

    function showAddShapesPopup() {
      // Close other popups first
      hideAllPopups();
      
      const addShapesPopup = document.getElementById('add-shapes-popup');
      if (addShapesPopup) {
        addShapesPopup.classList.add('show');
        setupShapeEventListeners();
      }
    }

    function hideAddShapesPopup() {
      const addShapesPopup = document.getElementById('add-shapes-popup');
      if (addShapesPopup) {
        addShapesPopup.classList.remove('show');
      }
    }

    function setupShapeEventListeners() {
      // Remove existing event listeners first to prevent duplicates
      const shapeOptions = document.querySelectorAll('.shape-option');
      shapeOptions.forEach(option => {
        // Clone the element to remove all event listeners
        const newOption = option.cloneNode(true);
        option.parentNode.replaceChild(newOption, option);
        
        // Add new event listener
        newOption.addEventListener('click', function() {
          const shapeType = this.getAttribute('data-shape');
          addShapeToCanvas(shapeType);
          hideAddShapesPopup();
        });
      });
    }

    function addShapeToCanvas(shapeType) {
      const canvas = deskPadModalCanvas;
      if (!canvas) return;

      // Use standard 500px base size
      const baseSize = 500;
      const strokeWidth = 25; // 5% of 500px

      let shape;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      switch (shapeType) {
        case 'rect':
          const rectWidth = baseSize * 1.5;
          const rectHeight = baseSize;
          shape = new fabric.Rect({
            left: centerX - rectWidth / 2,
            top: centerY - rectHeight / 2,
            width: rectWidth,
            height: rectHeight,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;

        case 'square':
          const squareSize = baseSize;
          shape = new fabric.Rect({
            left: centerX - squareSize / 2,
            top: centerY - squareSize / 2,
            width: squareSize,
            height: squareSize,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;

        case 'circle':
          const circleRadius = baseSize / 2;
          shape = new fabric.Circle({
            left: centerX - circleRadius,
            top: centerY - circleRadius,
            radius: circleRadius,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;

        case 'triangle':
          const triangleSize = baseSize;
          shape = new fabric.Triangle({
            left: centerX - triangleSize / 2,
            top: centerY - triangleSize / 2,
            width: triangleSize,
            height: triangleSize,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;

        case 'ellipse':
          const ellipseWidth = baseSize * 1.5;
          const ellipseHeight = baseSize;
          shape = new fabric.Ellipse({
            left: centerX - ellipseWidth / 2,
            top: centerY - ellipseHeight / 2,
            rx: ellipseWidth / 2,
            ry: ellipseHeight / 2,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;

        case 'polygon-5':
          const pentagonSize = baseSize / 2;
          shape = new fabric.Polygon([
            {x: 0, y: -pentagonSize},
            {x: pentagonSize * 0.95, y: -pentagonSize * 0.3},
            {x: pentagonSize * 0.6, y: pentagonSize * 0.8},
            {x: -pentagonSize * 0.6, y: pentagonSize * 0.8},
            {x: -pentagonSize * 0.95, y: -pentagonSize * 0.3}
          ], {
            left: centerX,
            top: centerY,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;

        case 'polygon-6':
          const hexagonSize = baseSize / 2;
          shape = new fabric.Polygon([
            {x: 0, y: -hexagonSize},
            {x: hexagonSize * 0.875, y: -hexagonSize * 0.5},
            {x: hexagonSize * 0.875, y: hexagonSize * 0.5},
            {x: 0, y: hexagonSize},
            {x: -hexagonSize * 0.875, y: hexagonSize * 0.5},
            {x: -hexagonSize * 0.875, y: -hexagonSize * 0.5}
          ], {
            left: centerX,
            top: centerY,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;

        case 'polygon-8':
          const octagonSize = baseSize / 2;
          shape = new fabric.Polygon([
            {x: 0, y: -octagonSize},
            {x: octagonSize * 0.7, y: -octagonSize * 0.7},
            {x: octagonSize, y: 0},
            {x: octagonSize * 0.7, y: octagonSize * 0.7},
            {x: 0, y: octagonSize},
            {x: -octagonSize * 0.7, y: octagonSize * 0.7},
            {x: -octagonSize, y: 0},
            {x: -octagonSize * 0.7, y: -octagonSize * 0.7}
          ], {
            left: centerX,
            top: centerY,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;

        case 'star':
          const starSize = baseSize / 2;
          shape = new fabric.Polygon([
            {x: 0, y: -starSize},
            {x: starSize * 0.3, y: -starSize * 0.3},
            {x: starSize, y: -starSize * 0.3},
            {x: starSize * 0.5, y: starSize * 0.2},
            {x: starSize * 0.6, y: starSize * 0.9},
            {x: 0, y: starSize * 0.6},
            {x: -starSize * 0.6, y: starSize * 0.9},
            {x: -starSize * 0.5, y: starSize * 0.2},
            {x: -starSize, y: -starSize * 0.3},
            {x: -starSize * 0.3, y: -starSize * 0.3}
          ], {
            left: centerX,
            top: centerY,
            fill: '#f4a012',
            stroke: '#000',
            strokeWidth: strokeWidth,
            selectable: true,
            evented: true
          });
          break;





        default:
          return;
      }

      // Add shape to canvas
      canvas.add(shape);
      canvas.setActiveObject(shape);
      canvas.requestRenderAll();

      // Add double-click event for shape editing
      shape.on('mousedblclick', function() {
        showShapeEditorModal(shape);
      });

      // Create layer for the shape
      const shapeName = getShapeDisplayName(shapeType);
      const layer = createLayer(shapeName, 'Shape', shape);
      
      // Select the new layer
      activeLayerId = layer.id;
      selectLayer(layer.id);
      updatePropertiesPanel(layer);
    }

    // Background management functions
    function showBackgroundPopup() {
      // Close other popups first
      hideAllPopups();
      
      const backgroundPopup = document.getElementById('background-popup');
      if (backgroundPopup) {
        // Force the popup to show by setting style directly
        backgroundPopup.style.display = 'block';
        backgroundPopup.style.visibility = 'visible';
        backgroundPopup.style.opacity = '1';
        backgroundPopup.classList.add('show');
        
        setupBackgroundEventListeners();
        updateBackgroundPreview();
      }
    }

    function hideBackgroundPopup() {
      const backgroundPopup = document.getElementById('background-popup');
      if (backgroundPopup) {
        backgroundPopup.style.display = 'none';
        backgroundPopup.style.visibility = 'hidden';
        backgroundPopup.style.opacity = '0';
        backgroundPopup.classList.remove('show');
      }
    }

    function setupBackgroundEventListeners() {
      // Color picker
      const colorPicker = document.getElementById('background-color-picker');
      const colorInput = document.getElementById('background-color-input');
      
      if (colorPicker) {
        colorPicker.addEventListener('input', function() {
          colorInput.value = this.value;
          // Apply color immediately
          currentBackground.type = 'solid';
          currentBackground.color = this.value;
          updateCanvasBackground();
          
          // Update selected state
          const presetColors = document.querySelectorAll('.preset-color');
          presetColors.forEach(p => p.classList.remove('selected'));
        });
      }
      
      if (colorInput) {
        colorInput.addEventListener('input', function() {
          colorPicker.value = this.value;
          // Apply color immediately
          currentBackground.type = 'solid';
          currentBackground.color = this.value;
          updateCanvasBackground();
          
          // Update selected state
          const presetColors = document.querySelectorAll('.preset-color');
          presetColors.forEach(p => p.classList.remove('selected'));
        });
      }

      // Preset colors
      const presetColors = document.querySelectorAll('.preset-color');
      presetColors.forEach(preset => {
        preset.addEventListener('click', function() {
          const color = this.getAttribute('data-color');
          colorPicker.value = color;
          colorInput.value = color;
          
          // Update selected state
          presetColors.forEach(p => p.classList.remove('selected'));
          this.classList.add('selected');
          
          // Apply color immediately
          currentBackground.type = 'solid';
          currentBackground.color = color;
          updateCanvasBackground();
        });
      });

      // Reset background button
      const resetBtn = document.getElementById('reset-background');
      if (resetBtn) {
        resetBtn.addEventListener('click', resetBackground);
      }
    }

    function updateBackgroundPreview() {
      const preview = document.getElementById('background-preview');
      const backgroundType = document.querySelector('input[name="background-type"]:checked').value;
      const colorPicker = document.getElementById('background-color-picker');
      
      if (!preview) return;
      
      if (backgroundType === 'transparent') {
        preview.style.background = 'transparent';
        preview.style.backgroundImage = 'url("Pattern Master black low gray.png")';
        preview.style.backgroundRepeat = 'repeat';
        preview.style.backgroundSize = 'auto';
      } else {
        preview.style.background = colorPicker ? colorPicker.value : '#ffffff';
        preview.style.backgroundImage = 'none';
      }
    }

    function applyBackground() {
      const backgroundType = document.querySelector('input[name="background-type"]:checked').value;
      const colorPicker = document.getElementById('background-color-picker');
      
      currentBackground.type = backgroundType;
      currentBackground.color = colorPicker ? colorPicker.value : '#ffffff';
      
      updateCanvasBackground();
      
      // Hide the toolbar instead of popup
      const backgroundToolbar = document.getElementById('background-toolbar');
      const backgroundToggleBtn = document.getElementById('background-toggle-btn');
      const backgroundToggleIcon = document.getElementById('background-toggle-icon');
      
      if (backgroundToolbar) backgroundToolbar.classList.remove('show');
      if (backgroundToggleBtn) backgroundToggleBtn.classList.remove('active');
      if (backgroundToggleIcon) backgroundToggleIcon.textContent = '▼';
    }

    function resetBackground() {
      currentBackground.type = 'transparent';
      currentBackground.color = '#ffffff';
      
      // Reset UI
      const colorPicker = document.getElementById('background-color-picker');
      const colorInput = document.getElementById('background-color-input');
      if (colorPicker) colorPicker.value = '#ffffff';
      if (colorInput) colorInput.value = '#ffffff';
      
      // Clear selected state from preset colors
      const presetColors = document.querySelectorAll('.preset-color');
      presetColors.forEach(p => p.classList.remove('selected'));
      
      updateCanvasBackground();
    }

    function updateCanvasBackground() {
      const canvas = deskPadModalCanvas;
      if (!canvas) return;
      
      // Remove existing background
      if (backgroundRect) {
        canvas.remove(backgroundRect);
        backgroundRect = null;
      }
      
      // Add new background if needed
      if (currentBackground.type === 'solid') {
        backgroundRect = new fabric.Rect({
          left: 0,
          top: 0,
          width: canvas.width,
          height: canvas.height,
          fill: currentBackground.color,
          selectable: false,
          evented: false,
          hoverCursor: 'default'
        });
        
        // Add background to the very back
        canvas.insertAt(backgroundRect, 0);
      }
      
      canvas.requestRenderAll();
    }

    function getShapeDisplayName(shapeType) {
      const shapeNames = {
        'rect': 'Rectangle',
        'square': 'Square',
        'circle': 'Circle',
        'triangle': 'Triangle',
        'ellipse': 'Ellipse',
        'polygon-5': 'Pentagon',
        'polygon-6': 'Hexagon',
        'polygon-8': 'Octagon',
        'star': 'Star'
      };
      return shapeNames[shapeType] || 'Shape';
    }

    // Shape Editor Functions
    let currentEditingShape = null;

    function showShapeEditorModal(shape) {
      currentEditingShape = shape;
      
      // Get current shape properties - ensure we get the actual values
      const fillColor = shape.fill || '#f4a012';
      const strokeColor = shape.stroke || '#000000';
      const strokeWidth = shape.strokeWidth || 25;
      

      
      // Set modal values
      document.getElementById('shape-fill-color').value = fillColor;
      document.getElementById('shape-stroke-color').value = strokeColor;
      document.getElementById('shape-stroke-width').value = strokeWidth;
      document.getElementById('stroke-width-value').textContent = strokeWidth + 'px';
      
      // Set transparent center checkbox based on current fill
      const isTransparent = fillColor === 'transparent' || fillColor === 'rgba(0,0,0,0)';
      document.getElementById('shape-transparent-center').checked = isTransparent;
      
      // Generate initial preview
      generateShapePreview(shape, fillColor, strokeColor, strokeWidth);
      
      // Show modal
      document.getElementById('shape-editor-modal').style.display = 'block';
      
      // Setup event listeners
      setupShapeEditorEvents();
    }

    function hideShapeEditorModal() {
      document.getElementById('shape-editor-modal').style.display = 'none';
      currentEditingShape = null;
    }

    function setupShapeEditorEvents() {
      // Close button
      document.getElementById('shape-editor-close').onclick = hideShapeEditorModal;
      
      // Cancel button
      document.getElementById('shape-editor-cancel').onclick = hideShapeEditorModal;
      
      // Apply button
      document.getElementById('shape-editor-apply').onclick = applyShapeChanges;
      
      // Real-time preview updates
      document.getElementById('shape-fill-color').oninput = updateShapePreview;
      document.getElementById('shape-stroke-color').oninput = updateShapePreview;
      document.getElementById('shape-stroke-width').oninput = function() {
        document.getElementById('stroke-width-value').textContent = this.value + 'px';
        updateShapePreview();
      };
      
      // Transparent center checkbox
      document.getElementById('shape-transparent-center').onchange = updateShapePreview;
      
      // Close on outside click
      document.getElementById('shape-editor-modal').onclick = function(e) {
        if (e.target === this) {
          hideShapeEditorModal();
        }
      };
    }

    function applyShapeChanges() {
      if (!currentEditingShape) return;
      
      const fillColor = document.getElementById('shape-fill-color').value;
      const strokeColor = document.getElementById('shape-stroke-color').value;
      const strokeWidth = parseInt(document.getElementById('shape-stroke-width').value);
      const isTransparentCenter = document.getElementById('shape-transparent-center').checked;
      
      // Determine final fill color based on transparent center checkbox
      const finalFillColor = isTransparentCenter ? 'transparent' : fillColor;
      
      // Apply changes to shape
      currentEditingShape.set({
        fill: finalFillColor,
        stroke: strokeColor,
        strokeWidth: strokeWidth
      });
      
      // Update canvas
      const canvas = deskPadModalCanvas;
      if (canvas) {
        canvas.requestRenderAll();
      }
      
      // Update layer properties if needed
      const layer = layers.find(l => l.object === currentEditingShape);
      if (layer) {
        updatePropertiesPanel(layer);
      }
      

      hideShapeEditorModal();
    }

    function generateShapePreview(shape, fillColor, strokeColor, strokeWidth) {
      const previewContainer = document.getElementById('shape-preview');
      if (!previewContainer) return;
      
      previewContainer.innerHTML = '';
      
      // Create a canvas for the preview
      const previewCanvas = document.createElement('canvas');
      previewCanvas.width = 280;
      previewCanvas.height = 180;
      previewCanvas.style.borderRadius = '4px';
      
      const previewCtx = previewCanvas.getContext('2d');
      
      // Set background
      previewCtx.fillStyle = '#1a1a1a';
      previewCtx.fillRect(0, 0, 280, 180);
      
      // Calculate preview dimensions
      const centerX = 140;
      const centerY = 90;
      const maxSize = 150;
      
      // Calculate scale factor to match the layers preview stroke width
      // Use the same logic as generateObjectPreview but adapted for larger preview
      const typicalShapeSize = 500;
      const scale = Math.min(280 / typicalShapeSize, 180 / typicalShapeSize, 0.8);
      
      // Draw shape based on type
      if (shape.type === 'rect') {
        // Check if this is a square (width === height) or rectangle
        const isSquare = shape.width === shape.height;
        
        if (isSquare) {
          // Square preview
          const size = maxSize;
          const x = centerX - size / 2;
          const y = centerY - size / 2;
          
          // Fill
          if (fillColor !== 'transparent') {
            previewCtx.fillStyle = fillColor;
            previewCtx.fillRect(x, y, size, size);
          }
          
          // Stroke
          if (strokeColor !== 'transparent' && strokeWidth > 0) {
            previewCtx.strokeStyle = strokeColor;
            previewCtx.lineWidth = Math.max(1, strokeWidth * scale);
            previewCtx.strokeRect(x, y, size, size);
          }
        } else {
          // Rectangle preview
          const width = maxSize;
          const height = maxSize * 0.8;
          const x = centerX - width / 2;
          const y = centerY - height / 2;
          
          // Fill
          if (fillColor !== 'transparent') {
            previewCtx.fillStyle = fillColor;
            previewCtx.fillRect(x, y, width, height);
          }
          
          // Stroke
          if (strokeColor !== 'transparent' && strokeWidth > 0) {
            previewCtx.strokeStyle = strokeColor;
            previewCtx.lineWidth = Math.max(1, strokeWidth * scale);
            previewCtx.strokeRect(x, y, width, height);
          }
        }
        
      } else if (shape.type === 'circle') {
        const radius = maxSize / 2;
        
        // Fill
        if (fillColor !== 'transparent') {
          previewCtx.fillStyle = fillColor;
          previewCtx.beginPath();
          previewCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
          previewCtx.fill();
        }
        
        // Stroke
        if (strokeColor !== 'transparent' && strokeWidth > 0) {
          previewCtx.strokeStyle = strokeColor;
          previewCtx.lineWidth = Math.max(1, strokeWidth * scale);
          previewCtx.beginPath();
          previewCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
          previewCtx.stroke();
        }
        
      } else if (shape.type === 'ellipse') {
        const width = maxSize * 1.5;
        const height = maxSize;
        const x = centerX - width / 2;
        const y = centerY - height / 2;
        
        // Fill
        if (fillColor !== 'transparent') {
          previewCtx.fillStyle = fillColor;
          previewCtx.beginPath();
          previewCtx.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
          previewCtx.fill();
        }
        
        // Stroke
        if (strokeColor !== 'transparent' && strokeWidth > 0) {
          previewCtx.strokeStyle = strokeColor;
          previewCtx.lineWidth = Math.max(1, strokeWidth * scale);
          previewCtx.beginPath();
          previewCtx.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
          previewCtx.stroke();
        }
        
      } else if (shape.type === 'triangle') {
        const size = maxSize;
        const x = centerX;
        const y = centerY;
        
        // Fill
        if (fillColor !== 'transparent') {
          previewCtx.fillStyle = fillColor;
          previewCtx.beginPath();
          previewCtx.moveTo(x, y - size / 2);
          previewCtx.lineTo(x - size / 2, y + size / 2);
          previewCtx.lineTo(x + size / 2, y + size / 2);
          previewCtx.closePath();
          previewCtx.fill();
        }
        
        // Stroke
        if (strokeColor !== 'transparent' && strokeWidth > 0) {
          previewCtx.strokeStyle = strokeColor;
          previewCtx.lineWidth = Math.max(1, strokeWidth * scale);
          previewCtx.beginPath();
          previewCtx.moveTo(x, y - size / 2);
          previewCtx.lineTo(x - size / 2, y + size / 2);
          previewCtx.lineTo(x + size / 2, y + size / 2);
          previewCtx.closePath();
          previewCtx.stroke();
        }
        
      } else if (shape.type === 'polygon') {
        // Check if this is a star (10 points) or regular polygon
        const sides = shape.points ? shape.points.length : 6;
        
        if (sides === 10) {
          // This is a star - draw it with alternating inner and outer points
          const outerRadius = maxSize / 2;
          const innerRadius = outerRadius * 0.45;
          const points = 5;
          
          // Fill
          if (fillColor !== 'transparent') {
            previewCtx.fillStyle = fillColor;
            previewCtx.beginPath();
            for (let i = 0; i < points * 2; i++) {
              const angle = (i * Math.PI) / points - Math.PI / 2;
              const r = i % 2 === 0 ? outerRadius : innerRadius;
              const px = centerX + r * Math.cos(angle);
              const py = centerY + r * Math.sin(angle);
              if (i === 0) {
                previewCtx.moveTo(px, py);
              } else {
                previewCtx.lineTo(px, py);
              }
            }
            previewCtx.closePath();
            previewCtx.fill();
          }
          
          // Stroke
          if (strokeColor !== 'transparent' && strokeWidth > 0) {
            previewCtx.strokeStyle = strokeColor;
            previewCtx.lineWidth = Math.max(1, strokeWidth * scale);
            previewCtx.beginPath();
            for (let i = 0; i < points * 2; i++) {
              const angle = (i * Math.PI) / points - Math.PI / 2;
              const r = i % 2 === 0 ? outerRadius : innerRadius;
              const px = centerX + r * Math.cos(angle);
              const py = centerY + r * Math.sin(angle);
              if (i === 0) {
                previewCtx.moveTo(px, py);
              } else {
                previewCtx.lineTo(px, py);
              }
            }
            previewCtx.closePath();
            previewCtx.stroke();
          }
        } else {
          // Regular polygon
          const radius = maxSize / 2;
          
          // Fill
          if (fillColor !== 'transparent') {
            previewCtx.fillStyle = fillColor;
            previewCtx.beginPath();
            for (let i = 0; i < sides; i++) {
              const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
              const px = centerX + radius * Math.cos(angle);
              const py = centerY + radius * Math.sin(angle);
              if (i === 0) {
                previewCtx.moveTo(px, py);
              } else {
                previewCtx.lineTo(px, py);
              }
            }
            previewCtx.closePath();
            previewCtx.fill();
          }
          
          // Stroke
          if (strokeColor !== 'transparent' && strokeWidth > 0) {
            previewCtx.strokeStyle = strokeColor;
            previewCtx.lineWidth = Math.max(1, strokeWidth * scale);
            previewCtx.beginPath();
            for (let i = 0; i < sides; i++) {
              const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
              const px = centerX + radius * Math.cos(angle);
              const py = centerY + radius * Math.sin(angle);
              if (i === 0) {
                previewCtx.moveTo(px, py);
              } else {
                previewCtx.lineTo(px, py);
              }
            }
            previewCtx.closePath();
            previewCtx.stroke();
          }
        }
      }
      
      previewContainer.appendChild(previewCanvas);
    }

    function updateShapePreview() {
      if (!currentEditingShape) return;
      
      const fillColor = document.getElementById('shape-fill-color').value;
      const strokeColor = document.getElementById('shape-stroke-color').value;
      const strokeWidth = parseInt(document.getElementById('shape-stroke-width').value);
      const isTransparentCenter = document.getElementById('shape-transparent-center').checked;
      
      // Determine final fill color for preview
      const finalFillColor = isTransparentCenter ? 'transparent' : fillColor;
      
      generateShapePreview(currentEditingShape, finalFillColor, strokeColor, strokeWidth);
    }

