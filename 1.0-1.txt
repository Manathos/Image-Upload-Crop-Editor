<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Fabric.js Simple Image Upload Test</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <style>
    /* Quality warning animations */
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    
    body { background: #222; color: #fff; font-family: sans-serif; }
    #main-interface { 
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      width: 100vw;
      position: relative;
      z-index: 1; /* Lower than modal */
    }
    /* Remove global canvas border - will be applied specifically where needed */
    canvas { 
      background: transparent; 
      border: none !important; /* Remove all canvas borders by default */
      display: block; 
      margin: 0 auto; 
      position: relative;
      z-index: 1;
      /* max-width: 100%; */
      /* height: auto; */
    }
    
    /* Add border only to main interface canvas */
    #main-interface canvas {
      border: 2px solid #f4a012 !important;
    }
    
    /* Custom PNG background pattern for transparency indication */
    .canvas-wrapper::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: url('Pattern Master black low gray.png');
      background-repeat: repeat;
      background-size: auto;
      z-index: 0;
      pointer-events: none;
    }
    
    /* Photoshop-style artboard boundary overlay */
    .artboard-boundary {
      position: absolute;
      border: 3px solid #f4a012;
      background: transparent;
      box-shadow: 0 0 20px rgba(244, 160, 18, 0.4);
      z-index: 10;
      pointer-events: none;
      transition: all 0.3s ease;
      display: none; /* Hidden by default */
      top: 0;
      left: 0;
    }
    
    /* Artboard corner indicators */
    .artboard-boundary::before,
    .artboard-boundary::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid #f4a012;
      background: #222;
    }
    
    .artboard-boundary::before {
      top: -12px;
      left: -12px;
      border-right: none;
      border-bottom: none;
    }
    
    .artboard-boundary::after {
      bottom: -12px;
      right: -12px;
      border-left: none;
      border-top: none;
    }
    .canvas-wrapper {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      overflow: visible; /* Allow content to extend beyond boundaries */
      position: relative;
      min-height: 600px; /* Ensure minimum height for extended workspace */
    }
    .lower-canvas {
      background: transparent !important;
      /* Removed global border - only modal canvas needs border */
    }
    .upper-canvas {
      background: transparent !important;
    }
    #upload-btn { margin: 20px 0; }
    #dpi-display { 
      margin: 10px 0; 
      padding: 10px; 
      background: #333; 
      border: 1px solid #f4a012; 
      border-radius: 5px;
      font-size: 14px;
    }
    #target-dpi { 
      margin: 10px 0; 
      padding: 10px; 
      background: #333; 
      border: 1px solid #f4a012; 
      border-radius: 5px;
      font-size: 14px;
    }
    #crop-overlay {
      display: none;
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 100;
      cursor: crosshair;
      pointer-events: none;
    }
    #crop-overlay.active {
      pointer-events: auto;
    }
    #crop-selection {
      position: absolute;
      border: 2px dashed #f4a012;
      background: rgba(244,160,18,0.1);
      cursor: move;
      box-sizing: border-box;
      /* Add resize handles */
    }
    #crop-selection .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #f4a012;
      border: 2px solid #fff;
      border-radius: 50%;
      z-index: 102;
      box-sizing: border-box;
    }
    #crop-selection .resize-handle.nw { top: -7px; left: -7px; cursor: nwse-resize; }
    #crop-selection .resize-handle.ne { top: -7px; right: -7px; cursor: nesw-resize; }
    #crop-selection .resize-handle.sw { bottom: -7px; left: -7px; cursor: nesw-resize; }
    #crop-selection .resize-handle.se { bottom: -7px; right: -7px; cursor: nwse-resize; }
    #crop-selection .resize-handle.n { top: -7px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
    #crop-selection .resize-handle.s { bottom: -7px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
    #crop-selection .resize-handle.e { right: -7px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
    #crop-selection .resize-handle.w { left: -7px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
    #crop-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #333;
      padding: 10px;
      border-radius: 5px;
      z-index: 101;
    }
    #drop-overlay {
      display: none;
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(244,160,18,0.2);
      color: #222;
      font-size: 2em;
      align-items: center;
      justify-content: center;
      z-index: 10;
      pointer-events: none;
    }
    
    /* Modal button styles */
    #crop-modal-apply, #crop-modal-cancel {
      background: #f4a012;
      color: #222;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    #crop-modal-apply:hover, #crop-modal-cancel:hover {
      background: #e6950f;
    }
    #crop-modal-cancel {
      background: #666;
      color: #fff;
    }
    #crop-modal-cancel:hover {
      background: #555;
    }
    
    /* Rotation transition */
    #crop-modal-img {
      transition: transform 0.3s ease;
    }
    
    /* Container size transition */
    #crop-modal-img-container {
      transition: width 0.3s ease, height 0.3s ease;
    }
    
    /* Rotate button hover effect */
    #crop-modal-rotate:hover {
      background: #555 !important;
      transform: scale(1.1);
    }
    #crop-modal-rotate {
      transition: all 0.2s ease;
    }
    
    /* Flip button hover effects */
    #crop-modal-flip-h:hover, #crop-modal-flip-v:hover {
      background: #555 !important;
      transform: scale(1.1);
    }
    #crop-modal-flip-h, #crop-modal-flip-v {
      transition: all 0.2s ease;
    }
    
    /* Flip button active/pressed effect */
    #crop-modal-flip-h:active, #crop-modal-flip-v:active {
      transform: scale(0.95);
      background: #666 !important;
    }
    
    /* Flip button glow effect */
    #crop-modal-flip-h, #crop-modal-flip-v {
      box-shadow: 0 0 0 rgba(255, 224, 102, 0);
      transition: all 0.2s ease, box-shadow 0.3s ease;
    }
    #crop-modal-flip-h:hover, #crop-modal-flip-v:hover {
      box-shadow: 0 0 15px rgba(255, 224, 102, 0.3);
    }
    
    /* 3D flip animation styles */
    #crop-modal-canvas {
      transform-style: preserve-3d;
      backface-visibility: hidden;
    }
    
    /* Add a subtle shadow during flip animations */
    #crop-modal-canvas.flipping {
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    /* Canvas instructions - make click-transparent */
    #canvas-instructions {
      pointer-events: none;
    }
    
    /* Loading overlay - separate from modal */
    #loading-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5); /* semi-transparent so image shows through */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-family: Arial, sans-serif;
      z-index: 10002; /* above crop modal (10000) */
      opacity: 0;
      pointer-events: none; /* don't block clicks when hidden */
      transition: opacity 0.2s ease;
    }
    
    #loading-overlay.show {
      opacity: 1;
      pointer-events: auto; /* block events when visible */
    }
    
    #loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #333;
      border-top: 4px solid #f4a012;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    #loading-text {
      font-size: 18px;
      font-weight: bold;
      color: #f4a012;
    }
    
    /* Modal overlay covers most of the screen, centered */
    #crop-modal-overlay {
      display: none;
      position: fixed;
      z-index: 10000;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.98);
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #crop-modal-toolbar {
      position: fixed;
      top: 32px;
      left: 0;
      width: 100vw;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 48px;
      box-sizing: border-box;
      z-index: 103;
      pointer-events: auto;
    }
    #crop-modal-bottom-buttons {
      position: fixed;
      bottom: 32px;
      left: 0;
      width: 100vw;
      display: flex;
      justify-content: center;
      gap: 32px;
      padding: 0 0 0 0;
      box-sizing: border-box;
      z-index: 103;
      pointer-events: auto;
    }
    #crop-modal-croparea {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: visible; /* Allow crop handles to extend outside */
    }
    #crop-modal-img-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
      overflow: visible; /* Allow crop handles to extend outside */
      /* margin: auto; removed for better centering */
    }
    #crop-modal-img {
      display: block;
      user-select: none;
      width: 90vw;
      height: 90vh;
      max-width: 90vw;
      max-height: 90vh;
      object-fit: contain;
      box-shadow: none;
      margin: 0;
    }
    #crop-modal-cropbox {
      position: absolute;
      border: 2px dashed #ffe066 !important;
      border-radius: 8px;
      box-sizing: border-box;
      pointer-events: auto;
      display: none;
      background: rgba(255, 255, 0, 0.08) !important;
      z-index: 200 !important;
    }
    
    #crop-modal-cropbox .resize-handle {
      z-index: 201 !important;
    }
    /* Ensure transparent background for modal canvas */
    #crop-modal-canvas {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
    }
    #crop-modal-img-container {
      border: none !important;
      box-shadow: none !important;
    }
    
    /* Desk Pad Editor Button Styles */
    .desk-pad-button {
      width: 300px;
      height: 180px;
      background: linear-gradient(135deg, #f4a012, #e6950f);
      border: 4px solid #fff;
      border-radius: 20px;
      cursor: pointer;
      overflow: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 12px 40px rgba(244, 160, 18, 0.4);
      z-index: 1000;
      position: relative;
    }
    
    .desk-pad-button:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 12px 40px rgba(244, 160, 18, 0.4);
    }
    
    .desk-pad-button:active {
      transform: translateY(-2px) scale(0.98);
    }
    
    .button-content {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #222;
      font-weight: bold;
      text-align: center;
      padding: 16px;
      box-sizing: border-box;
    }
    
    .button-text {
      font-size: 18px;
      font-weight: 800;
      margin-bottom: 4px;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
    }
    
    .button-subtitle {
      font-size: 12px;
      opacity: 0.8;
      font-weight: 600;
    }
    
    .button-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      border-radius: 13px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .button-preview.show {
      opacity: 1;
    }
    
    .button-hover-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .desk-pad-button:hover .button-hover-effect {
      opacity: 1;
    }
    
    /* Desk Pad Modal Styles */
    #desk-pad-modal-overlay {
      display: none;
      position: fixed;
      z-index: 15000;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: #222;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    
    /* Prevent body scroll when modal is open */
    body.modal-open {
      overflow: hidden;
    }
    
    #desk-pad-modal-toolbar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
      background: #1a1919;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 24px;
      box-sizing: border-box;
      z-index: 15001;
      border-bottom: 2px solid #f4a012;
    }
    
    #modal-dpi-display {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 12px;
      border-radius: 8px;
      font-size: 12px;
      font-family: monospace;
      max-width: 300px;
      z-index: 15002;
      border: 1px solid #f4a012;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    #modal-dpi-display.show {
      opacity: 1;
    }
    

    
    /* Shortcut Menu Styles */
    #shortcut-menu {
      position: fixed;
      top: 60px;
      left: 0;
      width: 80px; /* Increased from 50px to 80px (60% wider) */
      height: calc(100vh - 60px);
      background: #1a1919;
      border-right: 2px solid #f4a012;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px 0;
      gap: 12px;
      z-index: 15002;
      /* Remove transition and positioning changes - keep it fixed */
    }

    .shortcut-btn {
      width: 60px;
      height: 60px;
      background: #333;
      border: 1px solid #555;
      border-radius: 8px;
      color: #f4a012;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.2s ease;
      position: relative;
      gap: 4px;
    }

    .shortcut-btn-text {
      font-size: 10px;
      color: #f4a012;
      text-align: center;
      line-height: 1.2;
      word-wrap: break-word;
      max-width: 56px;
      font-weight: 500;
    }

    /* Recent Images Popup Styles */
    .recent-images-popup {
      position: fixed;
      top: 60px;
      left: 80px;
      width: 300px;
      height: calc(100vh - 60px); /* Same height as shortcut menu */
      background: #1a1919;
      border: 2px solid #f4a012;
      border-radius: 8px;
      z-index: 15004;
      display: none;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }

    .recent-images-popup.show {
      display: flex;
    }

    .recent-images-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      border-bottom: 1px solid #444;
      background: #2a2a2a;
      border-radius: 6px 6px 0 0;
      flex-shrink: 0; /* Prevent header from shrinking */
    }

    .recent-images-header span {
      color: #f4a012;
      font-weight: bold;
      font-size: 14px;
    }

    .recent-popup-close {
      background: none;
      border: none;
      color: #f4a012;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Layers/Properties Menu Styles */
    #layers-menu {
      position: fixed;
      top: 60px;
      right: 0;
      width: 300px;
      height: calc(100vh - 60px);
      background: #1a1919;
      border-left: 2px solid #f4a012;
      display: flex;
      flex-direction: column;
      z-index: 15002;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    #layers-menu.show {
      transform: translateX(0);
    }

    /* Canvas adjustment when layers menu is open */
    #desk-pad-modal-canvas-container.with-layers-menu {
      left: 80px !important; /* Keeps it anchored to the left */
      width: calc(100vw - 380px) !important; /* Shrinks the width instead of using right positioning */
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Toolbar adjustment when layers menu is open */
    #alignment-toolbar.with-layers-menu,
    #canvas-toolbar.with-layers-menu {
      right: 320px; /* 300px for layers menu + 20px gap */
      transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .layers-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid #444;
      background: #2a2a2a;
      flex-shrink: 0;
    }

    .layers-header span {
      color: #f4a012;
      font-weight: bold;
      font-size: 16px;
    }

    .layers-close {
      background: none;
      border: none;
      color: #f4a012;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .layers-content {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
    }

    .layers-section {
      margin-bottom: 24px;
    }

    .layers-section-title {
      color: #f4a012;
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 12px;
      border-bottom: 1px solid #444;
      padding-bottom: 8px;
    }

    .layer-item {
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: grab;
      transition: all 0.2s ease;
      position: relative;
      user-select: none;
    }

    .layer-item:hover {
      background: #444;
      border-color: #f4a012;
    }

    .layer-item.active {
      background: #f4a012;
      color: #222;
      border-color: #f4a012;
    }



    .layer-item.locked {
      opacity: 0.6;
      background: #2a2a2a;
    }

    .layer-item.hidden {
      opacity: 0.4;
    }

    .layer-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .layer-info {
      flex: 1;
      min-width: 0;
    }

    .layer-name {
      font-weight: bold;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .layer-type {
      font-size: 12px;
      opacity: 0.7;
    }

    .layer-properties {
      font-size: 12px;
      color: #ccc;
    }

    .layer-controls {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .layer-control-btn {
      background: none;
      border: none;
      color: #ccc;
      cursor: pointer;
      padding: 4px;
      border-radius: 3px;
      font-size: 12px;
      transition: all 0.2s ease;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .layer-control-btn:hover {
      background: #555;
      color: #f4a012;
    }

    .layer-control-btn.locked {
      color: #f4a012;
    }

    .layer-control-btn.hidden {
      color: #f4a012;
    }

    .layer-name {
      cursor: pointer;
      user-select: none;
    }

    .layer-info {
      cursor: pointer;
      user-select: none;
    }



    .recent-popup-close:hover {
      background: #444;
    }

    .recent-images-popup-grid {
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      align-content: start; /* Start from top, don't stretch */
      overflow-y: auto;
      /* Only show scrollbar when content overflows */
      scrollbar-width: thin;
      scrollbar-color: #f4a012 #333;
    }

    /* Custom scrollbar styling for webkit browsers */
    .recent-images-popup-grid::-webkit-scrollbar {
      width: 8px;
    }

    .recent-images-popup-grid::-webkit-scrollbar-track {
      background: #333;
      border-radius: 4px;
    }

    .recent-images-popup-grid::-webkit-scrollbar-thumb {
      background: #f4a012;
      border-radius: 4px;
    }

    .recent-images-popup-grid::-webkit-scrollbar-thumb:hover {
      background: #ffb84d;
    }

    .recent-image-item {
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .recent-image-item:hover {
      border-color: #f4a012;
      background: #444;
      box-shadow: 0 2px 8px rgba(244, 160, 18, 0.3);
      /* Use box-shadow instead of transform to avoid layout shifts */
    }

    .recent-image-thumbnail {
      width: 100%;
      height: 80px;
      object-fit: cover;
      border-radius: 4px;
      background: #222;
    }

    .recent-image-name {
      font-size: 10px;
      color: #ccc;
      text-align: center;
      word-break: break-word;
      line-height: 1.2;
      max-width: 100%;
    }

    /* Pad Size Popup Styles */
    .pad-size-popup {
      position: fixed;
      top: 60px;
      left: 80px;
      width: 320px;
      height: calc(100vh - 60px);
      background: #1a1919;
      border: 2px solid #f4a012;
      border-radius: 8px;
      z-index: 15004;
      display: none;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }

    .pad-size-popup.show {
      display: flex;
    }

    .pad-size-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      border-bottom: 1px solid #444;
      background: #2a2a2a;
      border-radius: 6px 6px 0 0;
      flex-shrink: 0;
    }

    .pad-size-header span {
      color: #f4a012;
      font-weight: bold;
      font-size: 14px;
    }

    .pad-size-popup-close {
      background: none;
      border: none;
      color: #f4a012;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .pad-size-popup-close:hover {
      background: #444;
    }

    .pad-size-content {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      flex: 1;
    }

    .pad-size-option {
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .pad-size-option:hover {
      border-color: #f4a012;
      background: #444;
      box-shadow: 0 2px 8px rgba(244, 160, 18, 0.3);
    }

    .pad-size-option.active {
      border-color: #f4a012;
      background: #2a2a2a;
      box-shadow: 0 0 0 2px rgba(244, 160, 18, 0.5);
    }

    .pad-size-name {
      font-size: 14px;
      font-weight: bold;
      color: #f4a012;
      margin-bottom: 4px;
    }

    .pad-size-details {
      font-size: 12px;
      color: #ccc;
      font-family: monospace;
      margin-bottom: 2px;
    }

    .pad-size-desc {
      font-size: 11px;
      color: #999;
      font-style: italic;
    }

    /* Add Text Popup Styles */
    .add-text-popup {
      position: fixed;
      top: 60px;
      left: 80px;
      width: 280px;
      height: calc(100vh - 60px);
      background: #1a1919;
      border: 2px solid #f4a012;
      border-radius: 8px;
      z-index: 15004;
      display: none;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }

    .add-text-popup.show {
      display: flex;
    }

    .add-text-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      border-bottom: 1px solid #444;
      background: #2a2a2a;
      border-radius: 6px 6px 0 0;
      flex-shrink: 0;
    }

    .add-text-header span {
      color: #f4a012;
      font-weight: bold;
      font-size: 14px;
    }

    .add-text-popup-close {
      background: none;
      border: none;
      color: #f4a012;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .add-text-popup-close:hover {
      background: #444;
    }

    .add-text-content {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .font-category {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .font-category-title {
      font-size: 12px;
      font-weight: bold;
      color: #f4a012;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #444;
      padding-bottom: 4px;
    }

    .font-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .font-option {
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 13px;
      color: #ccc;
    }

    .font-option:hover {
      border-color: #f4a012;
      background: #444;
      box-shadow: 0 2px 8px rgba(244, 160, 18, 0.3);
      transform: translateX(4px);
    }

    .font-option:active {
      transform: translateX(4px) scale(0.98);
    }

    .shortcut-btn:hover {
      background: #444;
      border-color: #f4a012;
      transform: scale(1.05);
    }

    .shortcut-btn:active {
      transform: scale(0.95);
    }

    .shortcut-btn.active {
      background: #f4a012;
      color: #222;
      border-color: #f4a012;
    }

    .shortcut-btn[title]:hover::after {
      content: attr(title);
      position: absolute;
      left: 70px;
      top: 50%;
      transform: translateY(-50%);
      background: #222;
      color: #f4a012;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 15003;
      border: 1px solid #f4a012;
    }

    #desk-pad-modal-canvas-container {
      position: fixed;
      top: 60px;
      left: 80px;
      width: calc(100vw - 80px);
      height: calc(100vh - 60px);
      background: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      border: none !important;
      overflow: hidden; /* Clip content when window is too small */
      min-width: 720px; /* Adjusted for wider shortcut menu */
      min-height: 600px; /* Minimum height to prevent excessive shrinking */
      transition: top 0.3s ease, left 0.3s ease, width 0.3s ease;
    }
    
    #desk-pad-modal-canvas-container.with-alignment-toolbar {
      top: 80px;
      height: calc(100vh - 80px);
    }
    
    /* Pattern background for transparency */
    #desk-pad-modal-canvas-container::before {
      content: '';
      position: absolute;
      top: -1000px;
      left: -1000px;
      right: -1000px;
      bottom: -1000px;
      background-image: url('Pattern Master black low gray.png');
      background-repeat: repeat;
      background-size: 1000px auto;
      z-index: 0;
      pointer-events: none;
      opacity: 0.8;
    }
    
    /* Darker overlay for artboard area */
    #desk-pad-modal-canvas-container::after {
      content: '';
      position: absolute;
      top: -1000px;
      left: -1000px;
      right: -1000px;
      bottom: -1000px;
      background: rgba(0, 0, 0, 0.85); /* Very dark overlay */
      z-index: 0;
      pointer-events: none;
    }
    
    /* Canvas size display */
    #canvas-size-display {
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #f4a012;
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      font-weight: bold;
      white-space: nowrap;
      z-index: 1000;
      border: 1px solid #f4a012;
    }
    
    /* Resize handles */
    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #f4a012;
      border: 2px solid #fc0606;
      border-radius: 50%;
      z-index: 1001;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .resize-handle:hover {
      background: #e6950f;
      transform: scale(1.2);
    }
    
    .resize-handle:active {
      background: #d88a0e;
      transform: scale(1.1);
    }
    
    /* Handle positions */
    .resize-handle-nw { top: -6px; left: -6px; cursor: nwse-resize; }
    .resize-handle-ne { top: -6px; right: -6px; cursor: nesw-resize; }
    .resize-handle-sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
    .resize-handle-se { bottom: -6px; right: -6px; cursor: nwse-resize; }
    .resize-handle-n { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
    .resize-handle-s { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
    .resize-handle-e { right: -6px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
    .resize-handle-w { left: -6px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
    
    /* Handle hover effects */
    .resize-handle-n:hover { transform: translateX(-50%) scale(1.2); }
    .resize-handle-s:hover { transform: translateX(-50%) scale(1.2); }
    .resize-handle-e:hover { transform: translateY(-50%) scale(1.2); }
    .resize-handle-w:hover { transform: translateY(-50%) scale(1.2); }
    
    /* Transparent canvas styling */
    #desk-pad-modal-canvas {
      background-image: url('Pattern Master black low gray.png');
      border: 3px solid #000000;
      display: block;
      position: relative;
      z-index: 1;
      box-shadow: 0 0 25px rgba(0, 0, 0, 0.3);
      flex-shrink: 0; /* Prevent canvas from shrinking */
      flex-grow: 0; /* Prevent canvas from growing */
    }
    
    /* Apply background to Fabric.js canvas container */
    #desk-pad-modal-canvas-container .canvas-container {
      background-image: url('Pattern Master black low gray.png');
      background-repeat: repeat;
      background-size: 1000px auto; /* Smaller pattern size */
      z-index: 1 !important; /* Ensure canvas is above artboard overlay */
      flex-shrink: 0; /* Prevent canvas container from shrinking */
      flex-grow: 0; /* Prevent canvas container from growing */
    }
    
    /* Fabric.js canvas container */
    .canvas-container {
      border: none !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* Simple canvas layers */
    .lower-canvas,
    .upper-canvas {
      border: none !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* Canvas boundary overlay - hidden since canvas has its own border */
    #canvas-boundary {
      display: none;
    }
    
    
    
   
    /* Removed duplicate canvas rule that was overriding the border */
    
    #desk-pad-finished-btn {
      background: #f4a012;
      color: #222;
      border: none;
      padding: 12px 32px;
      border-radius: 24px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    #desk-pad-finished-btn:hover {
      background: #e6950f;
      transform: scale(1.05);
    }
    
    /* Morphing animation styles */
    .morphing {
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .morph-to-modal {
      transform: scale(50) translate(-50%, -50%);
      border-radius: 0;
    }
    
    .morph-from-modal {
      transform: scale(0.02) translate(50%, 50%);
      border-radius: 16px;
    }
    
    /* Smoke/Particle animation styles */
    .smoke-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      opacity: 0;
      pointer-events: none;
      z-index: 14999;
      transition: opacity 0.8s ease;
    }
    .smoke-overlay.show {
      opacity: 1;
    }
    .smoke-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #333;
      border-radius: 50%;
      opacity: 0;
      pointer-events: none;
    }
    .smoke-particle.expanding {
      animation: smokeExpand 1.2s ease-out forwards;
    }
    .smoke-particle.contracting {
      animation: smokeContract 0.8s ease-in forwards;
    }
    @keyframes smokeExpand {
      0% { transform: scale(0) translate(0, 0); opacity: 0.8; }
      50% { opacity: 0.6; }
      100% { transform: scale(1) translate(var(--dx), var(--dy)); opacity: 0; }
    }
    @keyframes smokeContract {
      0% { transform: scale(1) translate(var(--dx), var(--dy)); opacity: 0; }
      50% { opacity: 0.6; }
      100% { transform: scale(0) translate(0, 0); opacity: 0.8; }
    }
    #desk-pad-modal-overlay {
      opacity: 0;
      transition: opacity 0.6s ease;
    }
    #desk-pad-modal-overlay.show {
      opacity: 1;
      background: #222; /* Ensure background is solid when shown */
    }
    

    
    /* Add Image Modal Styles */
    .add-image-modal {
      position: fixed;
      top: 60px; /* Below toolbar */
      left: 0; /* Start from left edge */
      width: 480px; /* Cover shortcut menu (80px) + main menu (400px) */
      height: calc(100vh - 60px);
      background: #333;
      border-right: 2px solid #f4a012;
      z-index: 15002;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transform: translateX(-100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .add-image-modal.show {
      transform: translateX(0);
    }
    
    .add-image-header {
      background: #f4a012;
      color: #222;
      padding: 16px 20px;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    
    .add-image-close {
      background: none;
      border: none;
      color: #222;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background 0.2s ease;
    }
    
    .add-image-close:hover {
      background: rgba(0,0,0,0.1);
    }
    
    .add-image-content {
      padding: 20px;
      flex: 1;
      overflow-y: auto;
    }
    
    .menu-section {
      margin-bottom: 24px;
    }
    
    .section-title {
      color: #f4a012;
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 12px;
    }
    
    .menu-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: #444;
      border: none;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 8px;
      width: 100%;
      text-align: left;
      font-size: 14px;
      font-weight: 500;
    }
    
    .menu-item:hover {
      background: #555;
      transform: translateX(4px);
    }
    
    .menu-item:active {
      transform: translateX(2px);
    }
    
    .menu-item-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #f4a012;
    }
    
    /* Canvas container transition when menu is open */
    #desk-pad-modal-canvas-container {
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    #desk-pad-modal-canvas-container.shifted {
      /* No viewport shifting - just let the menu slide over */
    }
    
    /* Recent images grid for the menu */
    .recent-images-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .recent-image-item {
      aspect-ratio: 1;
      background: #444;
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      overflow: hidden;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .recent-image-item:hover {
      border-color: #f4a012;
      transform: scale(1.05);
    }
    
    .recent-image-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    /* DPI Selection Styles */
    .dpi-selection {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .dpi-option {
      background: #333;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
      color: #fff;
    }
    
    .dpi-option:hover {
      border-color: #f4a012;
      background: #3a3a3a;
    }
    
    .dpi-option.active {
      border-color: #f4a012;
      background: #2a2a2a;
      box-shadow: 0 0 10px rgba(244, 160, 18, 0.3);
    }
    
    .dpi-option.locked {
      opacity: 0.5;
      cursor: not-allowed;
      background: #1a1a1a;
      border-color: #555;
    }
    
    .dpi-option.locked:hover {
      border-color: #555;
      background: #1a1a1a;
    }
    
    .dpi-option.locked .dpi-option-header {
      color: #666;
    }
    
    .dpi-option.locked .dpi-option-details {
      color: #555;
    }
    
    .dpi-option.locked .dpi-option-desc {
      color: #444;
    }
    
    .dpi-option-header {
      font-size: 16px;
      font-weight: bold;
      color: #f4a012;
      margin-bottom: 4px;
    }
    
    .dpi-option-details {
      font-size: 12px;
      color: #ccc;
      font-family: monospace;
      margin-bottom: 2px;
    }
    
    .dpi-option-desc {
      font-size: 11px;
      color: #999;
      font-style: italic;
    }
    
    /* Canvas Size Selection Styles */
    .canvas-size-selection select {
      background: #333 !important;
      color: #fff !important;
      border: 1px solid #555 !important;
      border-radius: 4px !important;
      padding: 6px 8px !important;
      font-size: 12px !important;
      width: 100% !important;
      cursor: pointer !important;
    }
    
    .canvas-size-selection select:focus {
      outline: none !important;
      border-color: #f4a012 !important;
      box-shadow: 0 0 0 2px rgba(244, 160, 18, 0.25) !important;
    }
    
    .canvas-size-selection select option {
      background: #333 !important;
      color: #fff !important;
    }

    /* Alignment Toolbar Styles */
    #alignment-toolbar {
      display: none;
      background: #2a2a2a;
      border-top: 1px solid #444;
      padding: 6px 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      position: fixed;
      top: 60px;
      left: 80px; /* Start after the wider shortcut menu */
      right: 0;
      z-index: 15003;
    }

    #alignment-toolbar.show {
      display: block;
    }

    .align-btn {
      background: #444;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 6px 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
      min-width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .align-btn:hover {
      background: #555;
      border-color: #f4a012;
      transform: scale(1.05);
    }

    .align-btn:active {
      transform: scale(0.95);
    }

    .align-btn.active {
      background: #f4a012;
      color: #222;
      border-color: #f4a012;
    }

    #alignment-toggle-btn {
      background: #333;
      color: #f4a012;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #alignment-toggle-btn:hover {
      background: #444;
      border-color: #f4a012;
    }

    #alignment-toggle-btn.active {
      background: #f4a012;
      color: #222;
      border-color: #f4a012;
    }

    #canvas-toggle-btn {
      background: #333;
      color: #f4a012;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #canvas-toggle-btn:hover {
      background: #444;
      border-color: #f4a012;
    }

    #canvas-toggle-btn.active {
      background: #f4a012;
      color: #222;
      border-color: #f4a012;
    }

    #layers-toggle-btn {
      background: #333;
      color: #f4a012;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #layers-toggle-btn:hover {
      background: #444;
      border-color: #f4a012;
    }

    #layers-toggle-btn.active {
      background: #f4a012;
      color: #222;
      border-color: #f4a012;
    }
    
    /* Preview button hover effects */
    #desk-pad-preview-btn {
      transition: all 0.2s ease;
    }
    
    #desk-pad-preview-btn:hover {
      background: #444;
      border-color: #e6950f;
      transform: scale(1.05);
    }
    
    #desk-pad-preview-btn:active {
      transform: scale(0.95);
    }

    /* Canvas Toolbar Styles */
    #canvas-toolbar {
      display: none;
      background: #2a2a2a;
      border-top: 1px solid #444;
      padding: 6px 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      position: fixed;
      top: 60px; /* Same position as alignment toolbar */
      left: 80px; /* Start after the wider shortcut menu */
      right: 0;
      z-index: 15003; /* Same z-index as alignment toolbar */
    }

    #canvas-toolbar.show {
      display: block;
    }

    .alignment-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .alignment-divider {
      width: 1px;
      height: 24px;
      background: #555;
      margin: 0 4px;
    }
  </style>
</head>
<body>
  <!-- Main Interface - Centered Desk Pad Editor Button -->
  <div id="main-interface">
    <div id="desk-pad-button" class="desk-pad-button">
      <div class="button-content">
        <div class="button-text">Desk Pad Editor</div>
        <div class="button-subtitle">Click to open full-screen editor</div>
        <div class="button-preview" id="button-preview"></div>
      </div>
      <div class="button-hover-effect"></div>
    </div>
  </div>
  
  <!-- Desk Pad Modal -->
  <div id="desk-pad-modal-overlay">
    <!-- Shortcut Menu -->
    <div id="shortcut-menu">
      <button class="shortcut-btn" id="shortcut-upload" title="Upload Image">
        üì§
        <div class="shortcut-btn-text">Upload</div>
      </button>
      <button class="shortcut-btn" id="shortcut-recent" title="Recent Images">
        üñºÔ∏è
        <div class="shortcut-btn-text">Recent</div>
      </button>
      <button class="shortcut-btn" id="shortcut-pad-size" title="Pad Size">
        üìè
        <div class="shortcut-btn-text">Pad Size</div>
      </button>
      <button class="shortcut-btn" id="shortcut-add-text" title="Add Text">
        ‚úèÔ∏è
        <div class="shortcut-btn-text">Add Text</div>
      </button>
      <!-- More shortcut buttons can be added here later -->
    </div>
    
    <!-- Recent Images Popup -->
    <div id="recent-images-popup" class="recent-images-popup">
      <div class="recent-images-header">
        <span>Recent Images</span>
        <button id="recent-popup-close" class="recent-popup-close">&times;</button>
      </div>
      <div id="recent-images-popup-grid" class="recent-images-popup-grid">
        <!-- Recent images will be populated here -->
      </div>
    </div>
    
    <!-- Pad Size Popup -->
    <div id="pad-size-popup" class="pad-size-popup">
      <div class="pad-size-header">
        <span>Pad Size</span>
        <button id="pad-size-popup-close" class="pad-size-popup-close">&times;</button>
      </div>
      <div class="pad-size-content">
        <div class="pad-size-option" data-preset="extended">
          <div class="pad-size-name">77:29 ‚Äî EXTENDED</div>
          <div class="pad-size-details">31.5" √ó 11.9" @150dpi</div>
          <div class="pad-size-desc">Standard extended desk pad</div>
        </div>
        <div class="pad-size-option" data-preset="immersive">
          <div class="pad-size-name">43:18 ‚Äî IMMERSIVE</div>
          <div class="pad-size-details">35.4" √ó 14" @150dpi</div>
          <div class="pad-size-desc">Wide immersive experience</div>
        </div>
        <div class="pad-size-option" data-preset="laptop">
          <div class="pad-size-name">61:36 ‚Äî LAPTOP / PLAYMAT</div>
          <div class="pad-size-details">27" √ó 16" @150dpi</div>
          <div class="pad-size-desc">Perfect for laptop desks</div>
        </div>
        <div class="pad-size-option" data-preset="fullsize">
          <div class="pad-size-name">96:41 ‚Äî FULL SIZE</div>
          <div class="pad-size-details">36" √ó 15.37" @150dpi</div>
          <div class="pad-size-desc">Large format desk pad</div>
        </div>
        <div class="pad-size-option" data-preset="supersize">
          <div class="pad-size-name">101:51 ‚Äî SUPER SIZE</div>
          <div class="pad-size-details">48" √ó 24.24" @150dpi</div>
          <div class="pad-size-desc">Extra large workspace</div>
        </div>
      </div>
    </div>
    
    <!-- Add Text Popup -->
    <div id="add-text-popup" class="add-text-popup">
      <div class="add-text-header">
        <span>Add Text</span>
        <button id="add-text-popup-close" class="add-text-popup-close">&times;</button>
      </div>
      <div class="add-text-content">
        <div class="font-category">
          <div class="font-category-title">Popular Fonts</div>
          <div class="font-list">
            <div class="font-option" data-font="Arial">Arial</div>
            <div class="font-option" data-font="Helvetica">Helvetica</div>
            <div class="font-option" data-font="Times New Roman">Times New Roman</div>
            <div class="font-option" data-font="Georgia">Georgia</div>
            <div class="font-option" data-font="Verdana">Verdana</div>
            <div class="font-option" data-font="Tahoma">Tahoma</div>
          </div>
        </div>
        <div class="font-category">
          <div class="font-category-title">Decorative Fonts</div>
          <div class="font-list">
            <div class="font-option" data-font="Impact">Impact</div>
            <div class="font-option" data-font="Comic Sans MS">Comic Sans MS</div>
            <div class="font-option" data-font="Courier New">Courier New</div>
            <div class="font-option" data-font="Lucida Console">Lucida Console</div>
            <div class="font-option" data-font="Trebuchet MS">Trebuchet MS</div>
            <div class="font-option" data-font="Arial Black">Arial Black</div>
          </div>
        </div>
        <div class="font-category">
          <div class="font-category-title">Modern Fonts</div>
          <div class="font-list">
            <div class="font-option" data-font="Segoe UI">Segoe UI</div>
            <div class="font-option" data-font="Calibri">Calibri</div>
            <div class="font-option" data-font="Candara">Candara</div>
            <div class="font-option" data-font="Corbel">Corbel</div>
            <div class="font-option" data-font="Consolas">Consolas</div>
            <div class="font-option" data-font="Cambria">Cambria</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Layers/Properties Menu -->
    <div id="layers-menu">
      <div class="layers-header">
        <span>Layers & Properties</span>
        <button id="layers-close" class="layers-close">&times;</button>
      </div>
      <div class="layers-content">
        <div class="layers-section">
          <div class="layers-section-title">Layers</div>
          <div id="layers-list">
            <!-- Layers will be populated here dynamically -->
          </div>
        </div>
        
        <div class="layers-section">
          <div class="layers-section-title">Properties</div>
          <div id="properties-panel">
            <!-- Properties will be populated here -->
            <div style="color: #ccc; font-size: 12px; font-style: italic;">
              Select an object to view its properties
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div id="desk-pad-modal-toolbar" style="display: flex; align-items: center; justify-content: space-between;">
      <div style="display: flex; align-items: center; gap: 16px;">
        <button id="desk-pad-menu-btn" style="background: none; border: none; color: #f4a012; cursor: pointer; padding: 8px; display: flex; flex-direction: column; gap: 3px;">
          <div style="width: 24px; height: 3px; background: #f4a012; border-radius: 2px;"></div>
          <div style="width: 24px; height: 3px; background: #f4a012; border-radius: 2px;"></div>
          <div style="width: 24px; height: 3px; background: #f4a012; border-radius: 2px;"></div>
        </button>
        <div style="font-size: 20px; font-weight: bold; color: #f4a012;">
          Desk Pad Editor
        </div>
      </div>
      <div style="display: flex; align-items: center; gap: 8px; position: absolute; left: 50%; transform: translateX(-50%);">
        <button id="alignment-toggle-btn" title="Toggle Alignment Tools">
          <span>Transform</span>
          <span id="alignment-toggle-icon">‚ñº</span>
        </button>
        <button id="canvas-toggle-btn" title="Toggle Canvas Tools">
          <span>Canvas</span>
          <span id="canvas-toggle-icon">‚ñº</span>
        </button>
        <button id="layers-toggle-btn" title="Toggle Layers & Properties">
          <span>Layers</span>
          <span id="layers-toggle-icon">‚ñº</span>
        </button>
      </div>
      <div style="display: flex; gap: 10px;">
        <button id="desk-pad-preview-btn" style="background: #333; color: #f4a012; border: 1px solid #f4a012; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px;" title="Preview on Pad">Preview</button>
        <button id="desk-pad-finished-btn">Finished</button>
      </div>
    </div>
    
    <!-- Alignment Toolbar -->
    <div id="alignment-toolbar">
      <div class="alignment-controls">
        <button id="align-top" class="align-btn" title="Align to Top">‚¨ÜÔ∏è</button>
        <button id="align-center" class="align-btn" title="Align to Center">‚èπÔ∏è</button>
        <button id="align-bottom" class="align-btn" title="Align to Bottom">‚¨áÔ∏è</button>
        
        <div class="alignment-divider"></div>
        
        <button id="align-left" class="align-btn" title="Align to Left">‚¨ÖÔ∏è</button>
        <button id="align-right" class="align-btn" title="Align to Right">‚û°Ô∏è</button>
        
        <div class="alignment-divider"></div>
        
        <button id="fill-canvas" class="align-btn" title="Fill Canvas">üñºÔ∏è</button>
        <button id="fit-canvas" class="align-btn" title="Fit to Canvas">üìê</button>
        <button id="center-canvas" class="align-btn" title="Center on Canvas">üéØ</button>
        
        <div class="alignment-divider"></div>
        
        <button id="duplicate-image" class="align-btn" title="Duplicate Image">üìã</button>
        <button id="duplicate-text" class="align-btn" title="Duplicate Text" style="display: none;">üìã</button>
      </div>
    </div>
    
    <!-- Canvas Toolbar -->
    <div id="canvas-toolbar">
      <div style="display: flex; align-items: center; gap: 8px; justify-content: center;">
        <button id="zoom-out-btn" style="background: #444; color: #f4a012; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;" title="Zoom Out (-)">‚àí</button>
        <span id="zoom-level" style="color: #f4a012; font-size: 14px; min-width: 60px; text-align: center;">100%</span>
        <button id="zoom-in-btn" style="background: #444; color: #f4a012; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;" title="Zoom In (+)">+</button>
        <button id="zoom-fit-btn" style="background: #444; color: #f4a012; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;" title="Fit to View (0)">Fit</button>
      </div>
    </div>
    
    <div id="modal-dpi-display">No image selected</div>
    <div id="canvas-size-info" style="background: #333; padding: 10px; margin: 10px 0; border-radius: 5px; font-size: 12px; color: #ccc;">
      <strong>Canvas Size:</strong> 2900 √ó 1093px<br>
      <strong>Aspect Ratio:</strong> 2.655 (77:29)<br>
      <strong>Print Quality:</strong> 100 DPI<br>
      <strong>Print Size:</strong> 11" √ó 29" equivalent<br>
      <small>Images will scale to fit but won't upscale if too small</small>
    </div>
    <div id="desk-pad-modal-canvas-container">
      <!-- Simple canvas container -->
      <canvas id="desk-pad-modal-canvas"></canvas>
      
      <div id="modal-drop-overlay" style="display:none; position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(244,160,18,0.2); color:#222; font-size:2em; align-items:center; justify-content:center; z-index:10; pointer-events:none;">Drop images here</div>
    </div>
  </div>
  
  <!-- Preview Modal -->
  <div id="previewModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:25000; align-items:center; justify-content:center; background:rgba(0,0,0,0.8);">
    <div style="position:relative; background:#222; border-radius:18px; box-shadow:0 8px 36px #0005; padding:20px 20px 8px 20px; max-width:95vw; max-height:90vh; display:flex; flex-direction:column; align-items:center;">
      <canvas id="previewCanvas" style="max-width:90vw; max-height:70vh; border-radius:12px; background:#222; width:100%; height:auto; display:block;"></canvas>
      <button onclick="document.getElementById('previewModal').style.display='none'" style="margin: 20px auto 0 auto; padding: 8px 32px; background: #f4a012; color: #fff; border: none; border-radius: 4px; cursor: pointer;">Close</button>
      <button id="btn-save-preview" style="margin: 8px 0 0 8px; padding: 8px 32px; background: #333; color: #f4a012; border: 1px solid #f4a012; border-radius: 4px; cursor: pointer;">Save Preview</button>
    </div>
  </div>
  
  <!-- Add Image Modal -->
  <div id="add-image-modal" class="add-image-modal">
    <div class="add-image-header">
      <span>Menu</span>
      <button id="add-image-close" class="add-image-close">&times;</button>
    </div>
    <div class="add-image-content">
      <div class="menu-section">
        <div class="section-title">Images</div>
        <button class="menu-item" id="menu-add-image">
          <div class="menu-item-icon">üì∑</div>
          Add Image
        </button>
        <button class="menu-item" id="menu-recent-images">
          <div class="menu-item-icon">üñºÔ∏è</div>
          Recent Images
        </button>
      </div>
      
      <div class="menu-section">
        <div class="section-title">Recent Images</div>
        <div id="recent-images-grid" class="recent-images-grid">
          <!-- Recent images will be populated here -->
        </div>
      </div>
      
      <div class="menu-section">
        <div class="section-title dpi-section-toggle" style="cursor: pointer; user-select: none;">
          <span>Print Quality</span>
          <span id="dpi-lock-indicator" style="float: right; margin-right: 8px; font-size: 12px; color: #f4a012; display: none;">üîí</span>
          <span class="dpi-toggle-icon" style="float: right; transition: transform 0.3s ease;">‚ñº</span>
        </div>
        <div id="current-dpi-display" style="font-size: 12px; color: #ccc; margin-bottom: 8px;">
          100 DPI ‚Ä¢ 2900 √ó 1093px
        </div>
        <div class="dpi-selection dpi-submenu" style="display: none;">
          <div style="font-size: 11px; color: #999; margin-bottom: 8px; font-style: italic;">
            üí° DPI is automatically locked after selection to preserve image quality. Click any option to change (warning will appear).
          </div>
          <button class="dpi-option active" data-dpi="100" data-width="2900" data-height="1093">
            <div class="dpi-option-header">100 DPI</div>
            <div class="dpi-option-details">2900 √ó 1093px</div>
            <div class="dpi-option-desc">Basic quality</div>
          </button>
          <button class="dpi-option" data-dpi="200" data-width="5800" data-height="2186">
            <div class="dpi-option-header">200 DPI</div>
            <div class="dpi-option-details">5800 √ó 2186px</div>
            <div class="dpi-option-desc">Good quality</div>
          </button>
          <button class="dpi-option" data-dpi="300" data-width="8700" data-height="3279">
            <div class="dpi-option-header">300 DPI</div>
            <div class="dpi-option-details">8700 √ó 3279px</div>
            <div class="dpi-option-desc">Professional</div>
          </button>
        </div>
      </div>
      
      <div class="menu-section">
        <div class="section-title">Canvas Size</div>
        <div id="current-canvas-size-display" style="font-size: 12px; color: #ccc; margin-bottom: 8px;">
          77:29 ‚Äî EXTENDED
        </div>
        <div class="canvas-size-selection" style="margin-bottom: 16px;">
          <select id="canvasSizeSelect" class="form-select form-select-sm" style="width: 100%; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 6px 8px; font-size: 12px;">
            <option value="extended">77:29 ‚Äî EXTENDED</option>
            <option value="immersive">43:18 ‚Äî IMMERSIVE</option>
            <option value="laptop">61:36 ‚Äî LAPTOP / PLAYMAT</option>
            <option value="fullsize">96:41 ‚Äî FULL SIZE</option>
            <option value="supersize">101:51 ‚Äî SUPER SIZE</option>
          </select>
        </div>
      </div>
      
    </div>
  </div>
  
  <!-- Smoke Overlay for Animation -->
  <div id="smoke-overlay" class="smoke-overlay"></div>
  

  <script>
    const canvasEl = document.getElementById('c');
    

    
    // Modal artboard management (boundary now handled by wrapper)
    let modalArtboardWidth = 0; // Full workspace width
    let modalArtboardHeight = 0; // Full workspace height
    let modalCanvasWidth = 0; // 77:29 output area width
    let modalCanvasHeight = 0; // 77:29 output area height
    
    // Check if Fabric.js is loaded
    if (typeof fabric === 'undefined') {
      console.error('Fabric.js is not loaded!');
      alert('Fabric.js library failed to load. Please check your internet connection.');
    } else {

      
      // Set global Fabric.js object defaults for better visibility
      fabric.Object.prototype.cornerColor = '#2c3e50'; // Dark blue-gray
      fabric.Object.prototype.cornerStrokeColor = '#ffffff'; // White border
      fabric.Object.prototype.transparentCorners = false;
      fabric.Object.prototype.cornerStyle = 'circle';
      fabric.Object.prototype.cornerSize = 20; // Sweet spot - not too big, not too small
      fabric.Object.prototype.cornerStrokeWidth = 2;
      fabric.Object.prototype.borderColor = '#2c3e50'; // Dark blue-gray selection border
      fabric.Object.prototype.borderScaleFactor = 2;
      fabric.Object.prototype.selectable = true;
      fabric.Object.prototype.evented = true;
      // --- GLOBAL: Remove all default object strokes ---
      fabric.Object.prototype.stroke = 'transparent';
      fabric.Object.prototype.strokeWidth = 0;
      
      // Fix textBaseline errors by setting correct defaults
      fabric.Text.prototype.textBaseline = 'alphabetic';
      fabric.IText.prototype.textBaseline = 'alphabetic';
    }
    
    // Main canvas removed - only using modal canvas now
    let fabricCanvas = null;
    

    


    




    function calculateDPI(imageWidth, imageHeight, canvasWidth, canvasHeight) {
      // Calculate DPI based on the image's original dimensions vs canvas display size
      const dpiX = (imageWidth / canvasWidth) * 96; // 96 DPI is standard screen resolution
      const dpiY = (imageHeight / canvasHeight) * 96;
      return { dpiX: Math.round(dpiX), dpiY: Math.round(dpiY) };
    }

    function calculateOptimalCanvasSize(imageWidth, imageHeight) {
      // Calculate optimal canvas size to fit the image with minimal scaling
      // Maintain 77:29 aspect ratio while maximizing image size
      const aspectRatio = 77 / 29;
      
      // Calculate how the image would fit in the aspect ratio
      const imageAspectRatio = imageWidth / imageHeight;
      
      if (imageAspectRatio > aspectRatio) {
        // Image is wider than target ratio - fit by width
        const finalWidth = imageWidth;
        const finalHeight = Math.round(imageWidth / aspectRatio);
        return { width: finalWidth, height: finalHeight };
      } else {
        // Image is taller than target ratio - fit by height
        const finalHeight = imageHeight;
        const finalWidth = Math.round(imageHeight * aspectRatio);
        return { width: finalWidth, height: finalHeight };
      }
    }



    // Remove old in-canvas crop overlay code and listeners
    // Add modal HTML to the page
    const modalHtml = `
      <!-- Loading overlay - separate from modal -->
      <div id="loading-overlay" style="display:flex;position:fixed;z-index:20001;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.5);flex-direction:column;justify-content:center;align-items:center;">
        <div id="loading-spinner" style="width:60px;height:60px;border:4px solid #333;border-top:4px solid #f4a012;border-radius:50%;animation:spin 1s linear infinite;margin-bottom:20px;"></div>
        <div id="loading-text" style="font-size:18px;font-weight:bold;color:#f4a012;">Preparing image editor...</div>
      </div>
      
      <div id="crop-modal-overlay" style="display:none;position:fixed;z-index:20000;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.85);display:none;flex-direction:column;justify-content:center;align-items:center;">
        <div id="crop-modal-toolbar" style="width:100vw;display:flex;justify-content:space-between;align-items:center;padding:32px 48px 16px 48px;box-sizing:border-box;">
          <div>
            <button id="crop-modal-cancel" style="background:#333;color:#fff;border:none;padding:10px 24px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Cancel</button>
          </div>
          <div>
            <button id="crop-modal-rotate" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Rotate 90¬∞ clockwise">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 4v6h-6"/>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
              </svg>
            </button>
            <button id="crop-modal-flip-h" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Flip horizontally">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3"/>
                <path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/>
                <path d="M12 20v2"/>
                <path d="M12 14v2"/>
                <path d="M12 8v2"/>
                <path d="M12 2v2"/>
              </svg>
            </button>
            <button id="crop-modal-flip-v" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Flip vertically">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 7V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v2"/>
                <path d="M3 17v2a2 2 0 0 0 2 2h14a2 2 0 0 1 2-2v-2"/>
                <path d="M20 12v2"/>
                <path d="M14 12v2"/>
                <path d="M8 12v2"/>
                <path d="M2 12v2"/>
              </svg>
            </button>
            <button id="crop-modal-crop" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Crop image">‚úÇÔ∏è</button>
            <button id="crop-modal-revert" style="background:#666;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Revert to original">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L23 8"/>
                <path d="M21 3v5h-5"/>
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                <path d="M3 21v-5h5"/>
              </svg>
            </button>
            <button id="crop-modal-info" style="background:#444;color:#fff;border:none;padding:10px 16px;border-radius:50%;width:48px;height:48px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;" title="Image Information">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M12 16v-4"/>
                <path d="M12 8h.01"/>
              </svg>
            </button>
            <button id="crop-modal-apply" style="background:#ffe066;color:#222;border:none;padding:10px 24px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">OK</button>
          </div>
        </div>
        <div id="crop-modal-croparea" style="flex:1;display:flex;justify-content:center;align-items:center;width:100vw;">
          <div id="crop-modal-img-container" style="position:relative;display:flex;justify-content:center;align-items:center;background:transparent;">
            <canvas id="crop-modal-canvas" style="display:block;user-select:none;width:90vw;height:90vh;max-width:90vw;max-height:90vh;box-shadow:none;margin:0;background:#222;"></canvas>
            <div id="crop-modal-cropbox" style="position:absolute;border:2px dashed #ffe066 !important;border-radius:8px;box-sizing:border-box;pointer-events:auto;display:none;background:rgba(255, 255, 0, 0.08) !important;z-index:102;"></div>
          </div>
        </div>
        <div id="crop-modal-bottom-buttons" style="display:none;width:100vw;justify-content:center;gap:32px;padding:32px;box-sizing:border-box;">
          <button id="crop-modal-crop-apply" style="background:#ffe066;color:#222;border:none;padding:10px 32px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Apply Crop</button>
          <button id="crop-modal-crop-cancel" style="background:#333;color:#fff;border:none;padding:10px 32px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Cancel Crop</button>
        </div>
        <div id="crop-modal-transform-buttons" style="display:none;width:100vw;justify-content:center;gap:32px;padding:32px;box-sizing:border-box;">
          <button id="crop-modal-transform-apply" style="background:#ffe066;color:#222;border:none;padding:10px 32px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Apply Changes</button>
          <button id="crop-modal-transform-cancel" style="background:#333;color:#fff;border:none;padding:10px 32px;border-radius:24px;font-size:18px;font-weight:bold;cursor:pointer;">Cancel Changes</button>
        </div>
        
        <!-- Image Info Popup -->
        <div id="image-info-popup" style="display:none;position:absolute;z-index:20001;background:#333;border-radius:8px;padding:16px;box-shadow:0 4px 16px rgba(0,0,0,0.4);max-width:280px;width:auto;color:#fff;font-size:14px;line-height:1.4;border:1px solid #444;">
          <div style="margin-bottom:8px;font-weight:bold;color:#ffe066;font-size:13px;text-transform:uppercase;letter-spacing:0.5px;">Image Info</div>
          <div id="image-info-content" style="color:#ccc;">
            <div style="margin-bottom:6px;">
              <span style="color:#999;font-size:12px;">Original:</span><br>
              <span id="info-original-dimensions" style="color:#fff;">Loading...</span>
            </div>
            <div style="margin-bottom:6px;">
              <span style="color:#999;font-size:12px;">Current:</span><br>
              <span id="info-current-dimensions" style="color:#fff;">Loading...</span>
            </div>
            <div style="margin-bottom:6px;">
              <span style="color:#999;font-size:12px;">Print Size (300 DPI):</span><br>
              <span id="info-dpi" style="color:#fff;">Loading...</span>
            </div>
            <div style="margin-bottom:6px;">
              <span style="color:#999;font-size:12px;">File:</span><br>
              <span id="info-file-size" style="color:#fff;">Loading...</span> ‚Ä¢ <span id="info-format" style="color:#fff;">Loading...</span>
            </div>
            <div style="margin-bottom:0;">
              <span style="color:#999;font-size:12px;">Transformations:</span><br>
              <span id="info-transformations" style="color:#fff;">None</span>
            </div>
          </div>
          <div style="position:absolute;bottom:-6px;left:20px;width:12px;height:12px;background:#333;border-left:1px solid #444;border-top:1px solid #444;transform:rotate(45deg);"></div>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const loadingOverlay = document.getElementById('loading-overlay');
    const cropModalOverlay = document.getElementById('crop-modal-overlay');
    const cropModal = document.getElementById('crop-modal');
    const cropModalCanvas = document.getElementById('crop-modal-canvas');
    const cropModalImgContainer = document.getElementById('crop-modal-img-container');
    const cropModalApply = document.getElementById('crop-modal-apply');
    const cropModalCancel = document.getElementById('crop-modal-cancel');
    const cropModalRotate = document.getElementById('crop-modal-rotate');
    const cropModalFlipH = document.getElementById('crop-modal-flip-h');
    const cropModalFlipV = document.getElementById('crop-modal-flip-v');
    const cropModalCrop = document.getElementById('crop-modal-crop');
    const cropModalRevert = document.getElementById('crop-modal-revert');
    const cropModalInfo = document.getElementById('crop-modal-info');
    const cropModalCropApply = document.getElementById('crop-modal-crop-apply');
    const cropModalCropCancel = document.getElementById('crop-modal-crop-cancel');
    const cropModalTransformApply = document.getElementById('crop-modal-transform-apply');
    const cropModalTransformCancel = document.getElementById('crop-modal-transform-cancel');
    const cropModalCropbox = document.getElementById('crop-modal-cropbox');
    const cropModalBottomButtons = document.getElementById('crop-modal-bottom-buttons');
    const cropModalTransformButtons = document.getElementById('crop-modal-transform-buttons');
    const cropModalToolbar = document.getElementById('crop-modal-toolbar');
    
    // Image info popup elements
    const imageInfoPopup = document.getElementById('image-info-popup');

    let modalRotation = 0; // Track rotation in degrees
    let modalFlipH = false; // Track horizontal flip
    let modalFlipV = false; // Track vertical flip
    let workingRotation = 0; // Track the working rotation (persists between modal sessions)
    let workingFlipH = false; // Track the working horizontal flip (persists between modal sessions)
    let workingFlipV = false; // Track the working vertical flip (persists between modal sessions)

    let cropRotation = 0; // Track the rotation when crop button is clicked
    let cropFlipH = false; // Track the horizontal flip when crop button is clicked
    let cropFlipV = false; // Track the vertical flip when crop button is clicked
    let originalImageWidth = 0; // Track original image dimensions
    let originalImageHeight = 0;
    let origFabricImg = null; // Store reference to original image for replacement
    let originalFabricImg = null; // Store reference to the very original image (never changes)
    // Note: veryOriginalImageDataUrl is now stored on each image object as _originalDataUrl
    let modalImageElement = null;
    let cropMode = false; // Track if we're in crop mode
    let transformMode = false; // Track if we're in transform mode (rotate/flip)
    let originalImageDataUrl = null;
    let lastCropBoxState = null;
    let cropBoxAspect = null; // Always freeform aspect ratio




    // Modal open/close helpers
    function updateImageTransform() {
      // This function is no longer needed as transform is removed from modal image
      // cropModalImg.style.transform = transform;

    }

    // --- Update openCropModal to use separate loading overlay ---
    function openCropModal(imgUrl, origImg) {

      
      // Loading overlay is already shown from double-click handler
      // Process everything in background
      setTimeout(() => {
        // Store reference to original image
        origFabricImg = origImg;
        // Store reference to the very original image (update for each new image)
        originalFabricImg = origImg;
        

        
        // Store the original data URL on the image object if not already stored
        if (!origImg._originalDataUrl) {
          origImg._originalDataUrl = imgUrl;
        }
        
        // Reset working transforms for new image (rotation/flip handled in modal only)
        workingRotation = 0;
        workingFlipH = false;
        workingFlipV = false;
        
        // Set modal transforms to match working orientation
        modalRotation = workingRotation;
        modalFlipH = workingFlipH;
        modalFlipV = workingFlipV;

        // Check if we already have a cached lower resolution image for this image
        if (origImg._cachedModalImage && origImg._cachedModalImage.complete) {

          // Use cached lower resolution image
          modalImageElement = origImg._cachedModalImage;
          // Process the image
          setupModalCanvas();
        } else {

          // Create a lower resolution version for the modal
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          
          // Calculate optimal modal size (max 2000px on longest side for performance)
          const maxModalSize = 2000;
          const imgWidth = origImg.width;
          const imgHeight = origImg.height;
          const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
          
          const modalWidth = Math.round(imgWidth * scale);
          const modalHeight = Math.round(imgHeight * scale);
          

          
          // Set canvas size to modal size
          tempCanvas.width = modalWidth;
          tempCanvas.height = modalHeight;
          
          // Draw the resized image normally
          tempCtx.drawImage(origImg._element, 0, 0, modalWidth, modalHeight);
          
          // Create image from the resized canvas
          modalImageElement = new window.Image();
          modalImageElement.onload = function() {

            // Cache this lower resolution image for future use
            origImg._cachedModalImage = modalImageElement;
            origImg._modalScale = scale; // Store the scale factor for later use
            // Process the image
            setupModalCanvas();
          };
          modalImageElement.src = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size
        }
      }, 100); // Small delay to ensure loading overlay is visible
    }
    
    function showModalLoadingState() {
      // Show a simple loading state
      cropModalCanvas.width = 400;
      cropModalCanvas.height = 300;
      cropModalCanvas.style.width = '400px';
      cropModalCanvas.style.height = '300px';
      cropModalImgContainer.style.width = '400px';
      cropModalImgContainer.style.height = '300px';
      
      const ctx = cropModalCanvas.getContext('2d');
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, 400, 300);
      ctx.fillStyle = '#666';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Loading image...', 200, 150);
    }
    
    function setupModalCanvas() {

      
      // Set up canvas and container dimensions to match the image (no stretching)
      const imgWidth = modalImageElement.width;
      const imgHeight = modalImageElement.height;
      const maxW = window.innerWidth * 0.9;
      const maxH = window.innerHeight * 0.9;
      let scale = Math.min(maxW / imgWidth, maxH / imgHeight, 1);
      let displayWidth = imgWidth * scale;
      let displayHeight = imgHeight * scale;



      // Since we're now using a lower resolution version, we can process it more efficiently
      setTimeout(() => {
        // Set canvas dimensions to match the modal image
        cropModalCanvas.width = imgWidth;
        cropModalCanvas.height = imgHeight;
        cropModalCanvas.style.width = displayWidth + 'px';
        cropModalCanvas.style.height = displayHeight + 'px';
        cropModalImgContainer.style.width = displayWidth + 'px';
        cropModalImgContainer.style.height = displayHeight + 'px';

        // Store the modal image dimensions (these are the lower resolution dimensions)
        originalImageWidth = imgWidth;
        originalImageHeight = imgHeight;

        cropModalCanvas.style.marginLeft = '0px';
        cropModalCanvas.style.marginTop = '0px';
        cropModalCanvas.style.transform = '';

        // Draw the image with transforms
        setTimeout(() => {
          drawModalCanvasWithTransforms();
          
          // Show modal after drawing is complete
          setTimeout(() => {
            loadingOverlay.classList.remove('show');
            cropModalOverlay.style.display = 'flex';
          }, 50);
        }, 25);
        

      }, 10);
    }
    
    function preCacheImageForModal(fabricImg) {
      // Pre-cache a lower resolution version for the modal
      if (!fabricImg._cachedModalImage) {

        
        // Create a temporary canvas to resize the image
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        // Calculate optimal modal size (max 2000px on longest side for performance)
        const maxModalSize = 2000;
        const imgWidth = fabricImg.width;
        const imgHeight = fabricImg.height;
        const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
        
        const modalWidth = Math.round(imgWidth * scale);
        const modalHeight = Math.round(imgHeight * scale);
        

        
        // Set canvas size to modal size
        tempCanvas.width = modalWidth;
        tempCanvas.height = modalHeight;
        
        // Draw the resized image
        tempCtx.drawImage(fabricImg._element, 0, 0, modalWidth, modalHeight);
        
        // Create image from the resized canvas
        const cachedImg = new window.Image();
        cachedImg.onload = function() {
          fabricImg._cachedModalImage = cachedImg;
          fabricImg._modalScale = scale; // Store the scale factor for later use

        };
        cachedImg.src = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size
      } else {

      }
    }
      cropModalApply.onclick = function() {
        // Apply rotation and flips to the entire image
        if (modalRotation === 0 && !modalFlipH && !modalFlipV) {
          // No changes - just close modal
          closeCropModal();
          return;
        }
        
        // Call the applyRotation function which handles both rotation and flips
        applyRotation();
      };
      
      // Crop button click handler
      cropModalCrop.onclick = function() {
        enterCropMode();
      };
      
      // Revert button click handler
      cropModalRevert.onclick = function() {
        revertToOriginal();
      };
      
      // Crop apply button click handler
      cropModalCropApply.onclick = function() {
        applyCrop();
      };
      
      // Crop cancel button click handler
      cropModalCropCancel.onclick = function() {
        exitCropMode();
      };
      
      // Transform apply button click handler
      cropModalTransformApply.onclick = function() {
        applyTransform();
      };
      
      // Transform cancel button click handler
      cropModalTransformCancel.onclick = function() {
        cancelTransform();
      };
      let isRotating = false;
      let rotationAnimationFrame = null;
      let isFlipping = false;
      let flipAnimationFrame = null;

      function animateRotation(targetAngle) {
        if (isRotating) return;
        isRotating = true;
        const startAngle = modalRotation;
        const endAngle = targetAngle;
        const duration = 300; // ms
        const startTime = performance.now();

        function step(now) {
          const elapsed = now - startTime;
          let t = Math.min(elapsed / duration, 1);
          // Ease-in-out
          t = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          const currentAngle = startAngle + (endAngle - startAngle) * t;
          modalRotation = currentAngle;
          drawModalCanvasWithTransforms();
          if (t < 1) {
            rotationAnimationFrame = requestAnimationFrame(step);
          } else {
            modalRotation = endAngle % 360;
            drawModalCanvasWithTransforms();
            isRotating = false;
            rotationAnimationFrame = null;
            updateImageTransform();
            if (cropMode) exitCropMode();
            cropModalBottomButtons.style.display = 'none';
          }
        }
        if (rotationAnimationFrame) cancelAnimationFrame(rotationAnimationFrame);
        rotationAnimationFrame = requestAnimationFrame(step);
      }

      function animateFlip(direction, targetFlip) {
        if (isFlipping) return;
        isFlipping = true;
        
        const startFlip = direction === 'horizontal' ? modalFlipH : modalFlipV;
        const endFlip = targetFlip;
        const duration = 300; // ms - quick and smooth
        const startTime = performance.now();

        function step(now) {
          const elapsed = now - startTime;
          let t = Math.min(elapsed / duration, 1);
          
          // Simple ease-in-out
          t = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          
          // Simple fade transition with slight scale
          if (t < 0.5) {
            // First half: fade out original
            const opacity = 1 - (t * 2);
            const scale = 1 - (t * 0.1); // Slight scale down
            cropModalCanvas.style.opacity = opacity;
            cropModalCanvas.style.transform = `scale(${scale})`;
            cropModalCanvas.classList.add('flipping');
          } else {
            // Second half: switch flip state and fade in
            const opacity = (t - 0.5) * 2;
            const scale = 0.9 + (t - 0.5) * 0.2; // Scale back up
            
            // Update flip state at the midpoint
            if (direction === 'horizontal') {
              modalFlipH = endFlip;
            } else {
              modalFlipV = endFlip;
            }
            
            drawModalCanvasWithTransforms();
            cropModalCanvas.style.opacity = opacity;
            cropModalCanvas.style.transform = `scale(${scale})`;
          }
          
          if (t < 1) {
            flipAnimationFrame = requestAnimationFrame(step);
          } else {
            // Reset and finalize
            cropModalCanvas.style.opacity = '';
            cropModalCanvas.style.transform = '';
            cropModalCanvas.classList.remove('flipping');
            isFlipping = false;
            flipAnimationFrame = null;
            
            // Exit crop mode if active
            if (cropMode) exitCropMode();
            cropModalBottomButtons.style.display = 'none';
          }
        }
        
        if (flipAnimationFrame) cancelAnimationFrame(flipAnimationFrame);
        flipAnimationFrame = requestAnimationFrame(step);
      }

      function drawModalCanvasAtAngle(angle) {
        if (!modalImageElement) return;
        const imgWidth = originalImageWidth;
        const imgHeight = originalImageHeight;
        const radians = (angle * Math.PI) / 180;
        // Calculate rotated bounding box
        const cos = Math.abs(Math.cos(radians));
        const sin = Math.abs(Math.sin(radians));
        const rotatedWidth = Math.round(imgWidth * cos + imgHeight * sin);
        const rotatedHeight = Math.round(imgWidth * sin + imgHeight * cos);
        // Fit rotated bounding box in modal, keeping aspect ratio
        const maxW = window.innerWidth * 0.9;
        const maxH = window.innerHeight * 0.9;
        let scale = Math.min(maxW / rotatedWidth, maxH / rotatedHeight, 1);
        // Set canvas and container to rotated bounding box size (not stretched)
        cropModalCanvas.width = rotatedWidth;
        cropModalCanvas.height = rotatedHeight;
        cropModalCanvas.style.width = (rotatedWidth * scale) + 'px';
        cropModalCanvas.style.height = (rotatedHeight * scale) + 'px';
        cropModalImgContainer.style.width = (rotatedWidth * scale) + 'px';
        cropModalImgContainer.style.height = (rotatedHeight * scale) + 'px';
        // Draw image centered and rotated
        const ctx = cropModalCanvas.getContext('2d');
        ctx.clearRect(0, 0, cropModalCanvas.width, cropModalCanvas.height);
        ctx.save();
        ctx.translate(rotatedWidth / 2, rotatedHeight / 2);
        ctx.rotate(radians);
        ctx.drawImage(modalImageElement, -imgWidth / 2, -imgHeight / 2);
        ctx.restore();
      }

      function drawModalCanvasWithTransforms() {
        if (!modalImageElement) return;
        const imgWidth = originalImageWidth;
        const imgHeight = originalImageHeight;
        const radians = (modalRotation * Math.PI) / 180;
        
        // Calculate rotated bounding box
        const cos = Math.abs(Math.cos(radians));
        const sin = Math.abs(Math.sin(radians));
        const rotatedWidth = Math.round(imgWidth * cos + imgHeight * sin);
        const rotatedHeight = Math.round(imgWidth * sin + imgHeight * cos);
        
        // Fit rotated bounding box in modal, keeping aspect ratio
        const maxW = window.innerWidth * 0.9;
        const maxH = window.innerHeight * 0.9;
        let scale = Math.min(maxW / rotatedWidth, maxH / rotatedHeight, 1);
        
        // Set canvas and container to rotated bounding box size (not stretched)
        cropModalCanvas.width = rotatedWidth;
        cropModalCanvas.height = rotatedHeight;
        cropModalCanvas.style.width = (rotatedWidth * scale) + 'px';
        cropModalCanvas.style.height = (rotatedHeight * scale) + 'px';
        cropModalImgContainer.style.width = (rotatedWidth * scale) + 'px';
        cropModalImgContainer.style.height = (rotatedHeight * scale) + 'px';
        
        // Draw image with all transforms
        const ctx = cropModalCanvas.getContext('2d');
        ctx.clearRect(0, 0, cropModalCanvas.width, cropModalCanvas.height);
        ctx.save();
        ctx.translate(rotatedWidth / 2, rotatedHeight / 2);
        ctx.rotate(radians);
        
        // Apply flips
        if (modalFlipH) {
          ctx.scale(-1, 1);
        }
        if (modalFlipV) {
          ctx.scale(1, -1);
        }
        
        ctx.drawImage(modalImageElement, -imgWidth / 2, -imgHeight / 2);
        ctx.restore();
      }

      cropModalRotate.onclick = function() {
        if (isRotating) return;
        const newAngle = (modalRotation + 90) % 360;
        animateRotation(newAngle);
        enterTransformMode();
      };
      
      cropModalFlipH.onclick = function() {
        if (isFlipping) return;
        const newFlipH = !modalFlipH;
        animateFlip('horizontal', newFlipH);
        enterTransformMode();
      };
      
      cropModalFlipV.onclick = function() {
        if (isFlipping) return;
        const newFlipV = !modalFlipV;
        animateFlip('vertical', newFlipV);
        enterTransformMode();
      };
      
      cropModalInfo.onclick = function() {
        showImageInfoPopup();
      };
      
      // Close info popup when clicking outside
      document.addEventListener('click', function(e) {
        const popup = imageInfoPopup;
        const infoButton = document.getElementById('crop-modal-info');
        
        // If popup is visible and click is not on popup or info button, close it
        if (popup.style.display === 'block' && 
            !popup.contains(e.target) && 
            !infoButton.contains(e.target)) {
          popup.style.display = 'none';
        }
      });
      cropModalCancel.onclick = closeCropModal;
      cropModalOverlay.onclick = function(e) { 
        // Only close if clicking the background AND not in crop mode
        // Also check if clicking on any crop handle anywhere on the screen
        const isClickingCropHandle = e.target.classList.contains('resize-handle') || 
                                   e.target.closest('#crop-modal-cropbox');
        if (e.target === cropModalOverlay && !isClickingCropHandle && !cropMode) {
          closeCropModal(); 
        }
      };
      document.onkeydown = function(e) { 
        // Only allow escape to close if not in crop mode
        if (e.key === 'Escape' && !cropMode) {
          closeCropModal(); 
        }
      };
      
      // Global click handler to prevent modal closing when clicking crop handles
      document.addEventListener('click', function(e) {
        if (cropMode) {
          const isClickingCropHandle = e.target.classList.contains('resize-handle') || 
                                     e.target.closest('#crop-modal-cropbox');
          if (isClickingCropHandle) {
            e.stopPropagation(); // Prevent modal from closing
          }
        }
      });
    
    function applyRotation() {
      // Store the image reference before any operations
      const currentOrigFabricImg = origFabricImg;
      const originalImgWidth = currentOrigFabricImg.width;
      const originalImgHeight = currentOrigFabricImg.height;
      const isHighRes = originalImgWidth * originalImgHeight > 10000000; // 10MP threshold
      const loadingText = document.getElementById('loading-text');
      
      // Determine which canvas we're working with
      const targetCanvas = (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex') ? deskPadModalCanvas : fabricCanvas;


      function actuallyApplyRotation() {







        const radians = (modalRotation * Math.PI) / 180;
        const cos = Math.abs(Math.cos(radians));
        const sin = Math.abs(Math.sin(radians));
        const rotatedWidth = Math.round(originalImgWidth * cos + originalImgHeight * sin);
        const rotatedHeight = Math.round(originalImgWidth * sin + originalImgHeight * cos);


        // Create temporary canvas for applying transforms
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = rotatedWidth;
        tempCanvas.height = rotatedHeight;
        tempCtx.save();
        tempCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
        tempCtx.rotate(radians);
        if (modalFlipH) tempCtx.scale(-1, 1);
        if (modalFlipV) tempCtx.scale(1, -1);
        
        // Use the stored image reference to ensure it's valid
        if (currentOrigFabricImg._element && currentOrigFabricImg._element.complete) {
          tempCtx.drawImage(currentOrigFabricImg._element, -originalImgWidth / 2, -originalImgHeight / 2);
          tempCtx.restore();
          
          targetCanvas.remove(currentOrigFabricImg);
          fabric.Image.fromURL(tempCanvas.toDataURL(), newImg => {

            const originalScaleX = currentOrigFabricImg.scaleX;
            const originalScaleY = currentOrigFabricImg.scaleY;
            const newImgWidth = newImg.width;
            const newImgHeight = newImg.height;
            const newScaleX = originalScaleX;
            const newScaleY = originalScaleY;

            newImg.set({
              left: currentOrigFabricImg.left,
              top: currentOrigFabricImg.top,
              originX: currentOrigFabricImg.originX,
              originY: currentOrigFabricImg.originY,
              scaleX: newScaleX,
              scaleY: newScaleY,
              angle: 0,
              flipX: false,
              flipY: false,
              selectable: true,
              hasControls: true,
              hasBorders: true,
              stroke: 'transparent',
              strokeWidth: 0
            });
            targetCanvas.add(newImg);
            targetCanvas.requestRenderAll();
            newImg._originalDataUrl = currentOrigFabricImg._originalDataUrl;
            
            // Update references immediately
            origFabricImg = newImg;
            // Don't update originalFabricImg - it should always remain the very first image
            
            // Pre-cache the new image for modal use
            const maxModalSize = 2000;
            const imgWidth = newImg.width;
            const imgHeight = newImg.height;
            const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
            const modalWidth = Math.round(imgWidth * scale);
            const modalHeight = Math.round(imgHeight * scale);
            
            // Create a temporary canvas for the modal version
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = modalWidth;
            tempCanvas.height = modalHeight;
            
            // Wait for the new image to be fully loaded before creating modal version
            if (newImg._element && newImg._element.complete) {
              tempCtx.drawImage(newImg._element, 0, 0, modalWidth, modalHeight);
              
              // Create and cache the modal image
              const cachedModalImg = new window.Image();
              cachedModalImg.onload = function() {
                newImg._cachedModalImage = cachedModalImg;
                newImg._modalScale = scale;
                
                // Update modal to show the new transformed image
                modalImageElement = cachedModalImg;
                originalImageWidth = modalImageElement.width;
                originalImageHeight = modalImageElement.height;
                modalRotation = 0;
                modalFlipH = false;
                modalFlipV = false;
                drawModalCanvasWithTransforms();
              };
              cachedModalImg.src = tempCanvas.toDataURL('image/jpeg', 0.9);
            } else {
              // If image not ready, wait for it
              newImg._element.onload = function() {
                tempCtx.drawImage(newImg._element, 0, 0, modalWidth, modalHeight);
                
                const cachedModalImg = new window.Image();
                cachedModalImg.onload = function() {
                  newImg._cachedModalImage = cachedModalImg;
                  newImg._modalScale = scale;
                  
                  modalImageElement = cachedModalImg;
                  originalImageWidth = modalImageElement.width;
                  originalImageHeight = modalImageElement.height;
                  modalRotation = 0;
                  modalFlipH = false;
                  modalFlipV = false;
                  drawModalCanvasWithTransforms();
                };
                cachedModalImg.src = tempCanvas.toDataURL('image/jpeg', 0.9);
              };
            }
            
            if (isHighRes) {

              setTimeout(() => {
                loadingOverlay.classList.remove('show');

              }, 500); // Minimum 500ms display time
            }
          });
        } else {
          console.error('Image element is not valid for rotation');
          if (isHighRes) {
  
            setTimeout(() => {
              loadingOverlay.classList.remove('show');

            }, 500); // Minimum 500ms display time
            cropModalOverlay.style.display = 'flex';
          }
        }
      }

      if (isHighRes) {
        // Show semi-transparent loading overlay (keep modal visible)

        loadingOverlay.classList.add('show');
        loadingText.textContent = 'Applying transformations to high-resolution image...';
        
        // Allow browser to paint the spinner before heavy work
        requestAnimationFrame(() => {
          setTimeout(() => {
            actuallyApplyRotation();
          }, 0);
        });
      } else {
        actuallyApplyRotation();
      }
    }
    
    function closeCropModal() {
      cropModalOverlay.style.display = 'none';
      imageInfoPopup.style.display = 'none'; // Close info popup
      loadingOverlay.classList.remove('show'); // Also hide loading overlay
      modalRotation = 0;
      modalFlipH = false;
      modalFlipV = false;
      originalImageWidth = 0;
      originalImageHeight = 0;
      // Don't reset originalFabricImg - keep it for future crops
      cropModalCanvas.src = ''; // Clear canvas source
      cropModalCanvas.style.transform = ''; // Reset any transform effects
      document.onkeydown = null;
      
      // Cancel any ongoing animations
      if (rotationAnimationFrame) {
        cancelAnimationFrame(rotationAnimationFrame);
        rotationAnimationFrame = null;
      }
      if (flipAnimationFrame) {
        cancelAnimationFrame(flipAnimationFrame);
        flipAnimationFrame = null;
      }
      isRotating = false;
      isFlipping = false;
      
      // Reset container and image styles
      // cropModalImgContainer.style.width = ''; // This line is removed
      // cropModalImgContainer.style.height = ''; // This line is removed
      cropModalCanvas.style.transform = '';
      
      // Exit crop mode if active
      if (cropMode) {
        exitCropMode();
      }
      
      // Exit transform mode if active
      if (transformMode) {
        cancelTransform();
      }
      
      // Ensure bottom buttons are hidden
      cropModalBottomButtons.style.display = 'none';
      cropModalTransformButtons.style.display = 'none';
    }
    
    function showImageInfoPopup() {
      if (!origFabricImg) {
        console.error('No image available for info popup');
        return;
      }
      
      // Get original image dimensions from the very original image
      let originalWidth, originalHeight;
      if (originalFabricImg) {
        originalWidth = originalFabricImg.width;
        originalHeight = originalFabricImg.height;
      } else {
        // Fallback to current image if original not available
        originalWidth = origFabricImg.width;
        originalHeight = origFabricImg.height;
      }
      
      // Get current dimensions (after any transformations and scaling)
      const currentWidth = Math.round(origFabricImg.getScaledWidth());
      const currentHeight = Math.round(origFabricImg.getScaledHeight());
      
      // Calculate DPI at 300 DPI print size
      const printWidthInches = currentWidth / 300;
      const printHeightInches = currentHeight / 300;
      const printWidthCm = printWidthInches * 2.54;
      const printHeightCm = printHeightInches * 2.54;
      
      // Get file size from original data URL
      let fileSize = 'Unknown';
      let format = 'Unknown';
      if (origFabricImg._originalDataUrl) {
        const dataUrl = origFabricImg._originalDataUrl;
        const base64Length = dataUrl.length - dataUrl.indexOf(',') - 1;
        const fileSizeBytes = Math.ceil((base64Length * 3) / 4);
        
        if (fileSizeBytes < 1024) {
          fileSize = fileSizeBytes + ' bytes';
        } else if (fileSizeBytes < 1024 * 1024) {
          fileSize = (fileSizeBytes / 1024).toFixed(1) + ' KB';
        } else {
          fileSize = (fileSizeBytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        // Determine format from data URL
        if (dataUrl.includes('data:image/jpeg')) {
          format = 'JPEG';
        } else if (dataUrl.includes('data:image/png')) {
          format = 'PNG';
        } else if (dataUrl.includes('data:image/gif')) {
          format = 'GIF';
        } else if (dataUrl.includes('data:image/webp')) {
          format = 'WebP';
        } else {
          format = 'Unknown';
        }
      }
      
      // Get transformations
      const transformations = [];
      if (workingRotation !== 0) {
        transformations.push(`Rotated ${workingRotation}¬∞`);
      }
      if (workingFlipH) {
        transformations.push('Flipped horizontally');
      }
      if (workingFlipV) {
        transformations.push('Flipped vertically');
      }
      
      const transformationsText = transformations.length > 0 ? transformations.join(', ') : 'None';
      
      // Update popup content
      document.getElementById('info-original-dimensions').textContent = `${originalWidth} √ó ${originalHeight} pixels`;
      document.getElementById('info-current-dimensions').textContent = `${currentWidth} √ó ${currentHeight} pixels`;
      document.getElementById('info-dpi').textContent = `${printWidthInches.toFixed(1)}" √ó ${printHeightInches.toFixed(1)}" (${printWidthCm.toFixed(1)} √ó ${printHeightCm.toFixed(1)} cm)`;
      document.getElementById('info-file-size').textContent = fileSize;
      document.getElementById('info-format').textContent = format;
      document.getElementById('info-transformations').textContent = transformationsText;
      
      // Position popup near the info button
      const infoButton = document.getElementById('crop-modal-info');
      const buttonRect = infoButton.getBoundingClientRect();
      const popup = imageInfoPopup;
      
      // Check if popup is already visible - if so, hide it
      if (popup.style.display === 'block') {
        popup.style.display = 'none';
        return;
      }
      
      // Position popup below the button, centered horizontally
      popup.style.left = (buttonRect.left - 120) + 'px'; // Center under button
      popup.style.top = (buttonRect.bottom + 10) + 'px';
      
      // Show popup
      popup.style.display = 'block';
    }
    
    // --- Crop Mode Functions ---
    
    function enterCropMode() {
      // Don't allow crop mode if we're in transform mode
      if (transformMode) {

        return;
      }
      

      cropMode = true;
      cropBoxAspect = null; // Always freeform aspect ratio
      
      // Capture the current modal state when crop button is clicked
      cropRotation = modalRotation;
      cropFlipH = modalFlipH;
      cropFlipV = modalFlipV;
      

      
      // Show the current working image in the modal for crop mode
      if (origFabricImg) {
        // Use the working orientation (which persists between modal sessions)

        
        // Set modal transforms to match working orientation
        modalRotation = workingRotation;
        modalFlipH = workingFlipH;
        modalFlipV = workingFlipV;
        
        // Use the cached lower resolution image for crop mode
        if (origFabricImg._cachedModalImage && origFabricImg._cachedModalImage.complete) {

          modalImageElement = origFabricImg._cachedModalImage;
          originalImageWidth = modalImageElement.width;
          originalImageHeight = modalImageElement.height;
          
                      // Show the image with its current orientation
            drawModalCanvasWithTransforms();
            
            // Use a small delay to ensure the modal canvas is rendered before calculating crop box size
            setTimeout(() => {
              // Set crop box to 60% of displayed image, centered
              const containerRect = cropModalImgContainer.getBoundingClientRect();
              const imgDisplayWidth = containerRect.width;
              const imgDisplayHeight = containerRect.height;
              let cropBoxWidth = imgDisplayWidth * 0.6;
              let cropBoxHeight = imgDisplayHeight * 0.6;
              

              
              // If crop box is zero or too small, set to a default minimum
              if (!imgDisplayWidth || !imgDisplayHeight || cropBoxWidth < 10 || cropBoxHeight < 10) {
                cropBoxWidth = Math.max(100, imgDisplayWidth || 400);
                cropBoxHeight = Math.max(100, imgDisplayHeight || 300);

              }
              
              // Ensure crop box stays within bounds with handle padding and toolbar gaps
              const handlePadding = 7;
              const toolbarGap = 32 + handlePadding; // Toolbar height + handle padding
              const maxLeft = imgDisplayWidth - cropBoxWidth - handlePadding;
              const maxTop = imgDisplayHeight - cropBoxHeight - toolbarGap;
              const cropBoxLeft = Math.max(handlePadding, Math.min(maxLeft, (imgDisplayWidth - cropBoxWidth) / 2));
              const cropBoxTop = Math.max(toolbarGap, Math.min(maxTop, (imgDisplayHeight - cropBoxHeight) / 2));
              cropModalCropbox.style.left = cropBoxLeft + 'px';
              cropModalCropbox.style.top = cropBoxTop + 'px';
              cropModalCropbox.style.width = cropBoxWidth + 'px';
              cropModalCropbox.style.height = cropBoxHeight + 'px';
              cropModalCropbox.style.transform = 'none';
              

            }, 10);
        } else {

          // Create a lower resolution version for crop mode
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          
          // Calculate optimal modal size (max 2000px on longest side for performance)
          const maxModalSize = 2000;
          const imgWidth = origFabricImg.width;
          const imgHeight = origFabricImg.height;
          const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
          
          const modalWidth = Math.round(imgWidth * scale);
          const modalHeight = Math.round(imgHeight * scale);
          

          
          // Set canvas size to modal size
          tempCanvas.width = modalWidth;
          tempCanvas.height = modalHeight;
          
          // Draw the resized image
          tempCtx.drawImage(origFabricImg._element, 0, 0, modalWidth, modalHeight);
          
          // Create image from the resized canvas
          modalImageElement = new window.Image();
          modalImageElement.onload = function() {

            // Cache this lower resolution image for future use
            origFabricImg._cachedModalImage = modalImageElement;
            origFabricImg._modalScale = scale; // Store the scale factor for later use
            
            originalImageWidth = modalImageElement.width;
            originalImageHeight = modalImageElement.height;
            
            // Show the image with its current orientation
            drawModalCanvasWithTransforms();
            
            // Use a small delay to ensure the modal canvas is rendered before calculating crop box size
            setTimeout(() => {
              // Set crop box to 60% of displayed image, centered
              const containerRect = cropModalImgContainer.getBoundingClientRect();
              const imgDisplayWidth = containerRect.width;
              const imgDisplayHeight = containerRect.height;
              cropBoxWidth = imgDisplayWidth * 0.6;
              cropBoxHeight = imgDisplayHeight * 0.6;
              
              console.log('Crop box initialization (second instance):', {
                imgDisplayWidth,
                imgDisplayHeight,
                initialCropBoxWidth: cropBoxWidth,
                initialCropBoxHeight: cropBoxHeight
              });
              
              // If crop box is zero or too small, set to a default minimum
              if (!imgDisplayWidth || !imgDisplayHeight || cropBoxWidth < 10 || cropBoxHeight < 10) {
                cropBoxWidth = Math.max(100, imgDisplayWidth || 400);
                cropBoxHeight = Math.max(100, imgDisplayHeight || 300);
                console.log('Crop box adjusted to minimum (second instance):', { cropBoxWidth, cropBoxHeight });
              }
              
              // Ensure crop box stays within bounds with handle padding and toolbar gaps
              const handlePadding = 7;
              const toolbarGap = 32 + handlePadding; // Toolbar height + handle padding
              const maxLeft = imgDisplayWidth - cropBoxWidth - handlePadding;
              const maxTop = imgDisplayHeight - cropBoxHeight - toolbarGap;
              const cropBoxLeft = Math.max(handlePadding, Math.min(maxLeft, (imgDisplayWidth - cropBoxWidth) / 2));
              const cropBoxTop = Math.max(toolbarGap, Math.min(maxTop, (imgDisplayHeight - cropBoxHeight) / 2));
              cropModalCropbox.style.left = cropBoxLeft + 'px';
              cropModalCropbox.style.top = cropBoxTop + 'px';
              cropModalCropbox.style.width = cropBoxWidth + 'px';
              cropModalCropbox.style.height = cropBoxHeight + 'px';
              cropModalCropbox.style.transform = 'none';
              
              console.log('Crop box positioned (second instance):', {
                left: cropBoxLeft,
                top: cropBoxTop,
                width: cropBoxWidth,
                height: cropBoxHeight
              });
            }, 10);
          };
          modalImageElement.src = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size
        }
      }

      // Hide top toolbar buttons
      cropModalRotate.style.display = 'none';
      cropModalFlipH.style.display = 'none';
      cropModalFlipV.style.display = 'none';
      cropModalCrop.style.display = 'none';
      cropModalApply.style.display = 'none';
      cropModalCancel.style.display = 'none';
      
      // Show crop box and position it properly (if not restored above)
      cropModalCropbox.style.display = 'block';
      cropModalCropbox.style.pointerEvents = 'auto';
      
      // Show bottom buttons
      cropModalBottomButtons.style.display = 'flex';
      
      // Make crop box draggable and resizable
      makeCropBoxInteractive();
      
      // Ensure crop box is properly initialized after a short delay
      setTimeout(() => {
        const cropRect = cropModalCropbox.getBoundingClientRect();
        if (cropRect.width === 0 || cropRect.height === 0) {

          
          const containerRect = cropModalImgContainer.getBoundingClientRect();
          const imgDisplayWidth = containerRect.width;
          const imgDisplayHeight = containerRect.height;
          let cropBoxWidth = Math.max(100, imgDisplayWidth * 0.6);
          let cropBoxHeight = Math.max(100, imgDisplayHeight * 0.6);
          
          if (!imgDisplayWidth || !imgDisplayHeight) {
            cropBoxWidth = 400;
            cropBoxHeight = 300;
          }
          
          const cropBoxLeft = (imgDisplayWidth - cropBoxWidth) / 2;
          const cropBoxTop = (imgDisplayHeight - cropBoxHeight) / 2;
          
          cropModalCropbox.style.left = cropBoxLeft + 'px';
          cropModalCropbox.style.top = cropBoxTop + 'px';
          cropModalCropbox.style.width = cropBoxWidth + 'px';
          cropModalCropbox.style.height = cropBoxHeight + 'px';
          cropModalCropbox.style.display = 'block';
          cropModalCropbox.style.transform = 'none';
          
          console.log('Crop box fixed:', {
            width: cropBoxWidth,
            height: cropBoxHeight,
            left: cropBoxLeft,
            top: cropBoxTop,
            containerWidth: imgDisplayWidth,
            containerHeight: imgDisplayHeight
          });
        }
      }, 100);
    }
    
    function enterTransformMode() {

      transformMode = true;
      
      // Hide most top toolbar buttons, but keep rotate/flip buttons visible
      cropModalCrop.style.display = 'none';
      cropModalApply.style.display = 'none';
      cropModalCancel.style.display = 'none';
      
      // Keep rotate and flip buttons visible so user can continue transforming
      cropModalRotate.style.display = 'inline-flex';
      cropModalFlipH.style.display = 'inline-flex';
      cropModalFlipV.style.display = 'inline-flex';
      
      // Show transform buttons
      cropModalTransformButtons.style.display = 'flex';
    }
    
    function applyTransform() {

      transformMode = false;
      
      // Apply the current modal transforms to the canvas image
      applyRotation();
      
      // Show all top toolbar buttons
      cropModalRotate.style.display = 'inline-flex';
      cropModalFlipH.style.display = 'inline-flex';
      cropModalFlipV.style.display = 'inline-flex';
      cropModalCrop.style.display = 'inline-flex';
      cropModalApply.style.display = 'inline-block';
      cropModalCancel.style.display = 'inline-block';
      
      // Hide transform buttons
      cropModalTransformButtons.style.display = 'none';
    }
    
    function cancelTransform() {

      transformMode = false;
      
      // Revert to the original image orientation
      if (origFabricImg) {
        modalRotation = origFabricImg.angle || 0;
        modalFlipH = origFabricImg.flipX || false;
        modalFlipV = origFabricImg.flipY || false;
        drawModalCanvasWithTransforms();
      }
      
      // Show top toolbar buttons
      cropModalRotate.style.display = 'inline-flex';
      cropModalFlipH.style.display = 'inline-flex';
      cropModalFlipV.style.display = 'inline-flex';
      cropModalCrop.style.display = 'inline-flex';
      cropModalApply.style.display = 'inline-block';
      cropModalCancel.style.display = 'inline-block';
      
      // Hide transform buttons
      cropModalTransformButtons.style.display = 'none';
    }
    
    function exitCropMode() {

      cropMode = false;
      
      // Show the current image in the modal (with any applied transforms)
      if (origFabricImg) {
        // Use the cached lower resolution image
        if (origFabricImg._cachedModalImage && origFabricImg._cachedModalImage.complete) {

          modalImageElement = origFabricImg._cachedModalImage;
          originalImageWidth = modalImageElement.width;
          originalImageHeight = modalImageElement.height;
          
          // Reset to current image's orientation (not upright)
          modalRotation = origFabricImg.angle || 0;
          modalFlipH = origFabricImg.flipX || false;
          modalFlipV = origFabricImg.flipY || false;
          
          drawModalCanvasWithTransforms();
        } else {

          // Create a lower resolution version
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          
          // Calculate optimal modal size (max 2000px on longest side for performance)
          const maxModalSize = 2000;
          const imgWidth = origFabricImg.width;
          const imgHeight = origFabricImg.height;
          const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
          
          const modalWidth = Math.round(imgWidth * scale);
          const modalHeight = Math.round(imgHeight * scale);
          
          // Set canvas size to modal size
          tempCanvas.width = modalWidth;
          tempCanvas.height = modalHeight;
          
          // Draw the resized image
          tempCtx.drawImage(origFabricImg._element, 0, 0, modalWidth, modalHeight);
          
          // Create image from the resized canvas
          modalImageElement = new window.Image();
          modalImageElement.onload = function() {

            // Cache this lower resolution image for future use
            origFabricImg._cachedModalImage = modalImageElement;
            origFabricImg._modalScale = scale; // Store the scale factor for later use
            
            originalImageWidth = modalImageElement.width;
            originalImageHeight = modalImageElement.height;
            
            // Reset to current image's orientation (not upright)
            modalRotation = origFabricImg.angle || 0;
            modalFlipH = origFabricImg.flipX || false;
            modalFlipV = origFabricImg.flipY || false;
            
            drawModalCanvasWithTransforms();
          };
          modalImageElement.src = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size
        }
      }

      // Show top toolbar buttons
      cropModalRotate.style.display = 'inline-flex';
      cropModalFlipH.style.display = 'inline-flex';
      cropModalFlipV.style.display = 'inline-flex';
      cropModalCrop.style.display = 'inline-flex';
      cropModalApply.style.display = 'inline-block';
      cropModalCancel.style.display = 'inline-block';
      
      // Hide crop box
      cropModalCropbox.style.display = 'none';
      cropModalCropbox.style.pointerEvents = 'none';
      
      // Hide bottom buttons
      cropModalBottomButtons.style.display = 'none';
      
      // Remove crop box event listeners
      removeCropBoxListeners();
    }
    
    function makeCropBoxInteractive() {
      // Add resize handles to crop box
      addResizeHandles();
      // Attach event listeners to handles
      addResizeHandlers();
      // Make crop box draggable
      makeCropBoxDraggable();
    }
    
    function addResizeHandles() {
      // Remove existing handles first
      const existingHandles = cropModalCropbox.querySelectorAll('.resize-handle');
      existingHandles.forEach(handle => handle.remove());
      
      // Add resize handles
      const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'];
      handles.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        handle.style.cssText = `
          position: absolute;
          width: 12px;
          height: 12px;
          background: #ffe066;
          border: 2px solid #fff;
          border-radius: 50%;
          z-index: 102;
          box-sizing: border-box;
        `;
        
        // Position handles
        switch(pos) {
          case 'nw': handle.style.top = '-7px'; handle.style.left = '-7px'; handle.style.cursor = 'nwse-resize'; break;
          case 'ne': handle.style.top = '-7px'; handle.style.right = '-7px'; handle.style.cursor = 'nesw-resize'; break;
          case 'sw': handle.style.bottom = '-7px'; handle.style.left = '-7px'; handle.style.cursor = 'nesw-resize'; break;
          case 'se': handle.style.bottom = '-7px'; handle.style.right = '-7px'; handle.style.cursor = 'nwse-resize'; break;
          case 'n': handle.style.top = '-7px'; handle.style.left = '50%'; handle.style.transform = 'translateX(-50%)'; handle.style.cursor = 'ns-resize'; break;
          case 's': handle.style.bottom = '-7px'; handle.style.left = '50%'; handle.style.transform = 'translateX(-50%)'; handle.style.cursor = 'ns-resize'; break;
          case 'e': handle.style.right = '-7px'; handle.style.top = '50%'; handle.style.transform = 'translateY(-50%)'; handle.style.cursor = 'ew-resize'; break;
          case 'w': handle.style.left = '-7px'; handle.style.top = '50%'; handle.style.transform = 'translateY(-50%)'; handle.style.cursor = 'ew-resize'; break;
        }
        
        cropModalCropbox.appendChild(handle);
      });
    }
    
    function makeCropBoxDraggable() {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      cropModalCropbox.addEventListener('mousedown', function(e) {
        if (e.target.classList.contains('resize-handle')) return;
        isDragging = true;
        const containerRect = cropModalCanvas.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        const rect = cropModalCropbox.getBoundingClientRect();
        startLeft = rect.left - containerRect.left;
        startTop = rect.top - containerRect.top;
        document.body.style.cursor = 'move';
        e.preventDefault();
        
        // Prevent text selection during drag
        document.body.style.userSelect = 'none';
        document.body.style.webkitUserSelect = 'none';
        document.body.style.mozUserSelect = 'none';
        document.body.style.msUserSelect = 'none';

        function onDragMove(e) {
          if (!isDragging) return;
          const containerRect = cropModalCanvas.getBoundingClientRect();
          const mouseX = e.clientX - containerRect.left;
          const mouseY = e.clientY - containerRect.top;
          let newLeft = startLeft + (mouseX - (startX - containerRect.left));
          let newTop = startTop + (mouseY - (startY - containerRect.top));
          
          // Constrain to image boundaries (canvas dimensions)
          newLeft = Math.max(0, Math.min(newLeft, cropModalCanvas.offsetWidth - cropModalCropbox.offsetWidth));
          newTop = Math.max(0, Math.min(newTop, cropModalCanvas.offsetHeight - cropModalCropbox.offsetHeight));
          
          cropModalCropbox.style.left = newLeft + 'px';
          cropModalCropbox.style.top = newTop + 'px';
          cropModalCropbox.style.transform = 'none';
        }

        function onDragUp() {
          if (isDragging) {
            isDragging = false;
            document.body.style.cursor = '';
            
            // Restore text selection
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';
            document.body.style.mozUserSelect = '';
            document.body.style.msUserSelect = '';
            
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragUp);
          }
        }

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragUp);
      });
    }
    
    function addResizeHandlers() {
      const handles = cropModalCropbox.querySelectorAll('.resize-handle');

      handles.forEach(handle => {
        handle.addEventListener('mousedown', function(e) {

          e.stopPropagation();
          const direction = handle.className.split(' ')[1]; // Get direction (nw, ne, etc.)

          startCropResize(e, direction);
        });
      });
    }
    
    function startCropResize(e, direction) {

      let isResizing = true;
      let startX = e.clientX;
      let startY = e.clientY;
      const containerRect = cropModalCanvas.getBoundingClientRect();
      const rect = cropModalCropbox.getBoundingClientRect();
      const imgDisplayWidth = cropModalCanvas.offsetWidth;
      const imgDisplayHeight = cropModalCanvas.offsetHeight;
      let startLeft = rect.left - containerRect.left;
      let startTop = rect.top - containerRect.top;
      let startWidth = rect.width;
      let startHeight = rect.height;
      
      console.log('Crop resize initial state:', {
        containerRect: { width: containerRect.width, height: containerRect.height },
        cropRect: { width: rect.width, height: rect.height, left: rect.left, top: rect.top },
        startLeft, startTop, startWidth, startHeight
      });
      
      // Prevent text selection during resize
      document.body.style.userSelect = 'none';
      document.body.style.webkitUserSelect = 'none';
      document.body.style.mozUserSelect = 'none';
      document.body.style.msUserSelect = 'none';

      function onResizeMove(e) {
        if (!isResizing) return;

        const containerRect = cropModalCanvas.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const mouseY = e.clientY - containerRect.top;
        let newLeft = startLeft;
        let newTop = startTop;
        let newWidth = startWidth;
        let newHeight = startHeight;
        // Apply resize based on direction
        if (direction.includes('e')) {
          newWidth = Math.max(50, startWidth + (mouseX - (startX - containerRect.left)));
        }
        if (direction.includes('w')) {
          const maxDelta = startWidth - 50;
          const delta = Math.min(mouseX - (startX - containerRect.left), maxDelta);
          newLeft = startLeft + delta;
          newWidth = startWidth - delta;
        }
        if (direction.includes('s')) {
          newHeight = Math.max(50, startHeight + (mouseY - (startY - containerRect.top)));
        }
        if (direction.includes('n')) {
          const maxDelta = startHeight - 50;
          const delta = Math.min(mouseY - (startY - containerRect.top), maxDelta);
          newTop = startTop + delta;
          newHeight = startHeight - delta;
        }
        // Constrain to image boundaries with smooth edge clamping
        const handlePadding = 7; // Half the handle size (12px / 2)
        
        // Only clamp the edge being dragged, not the entire box
        if (direction.includes('w')) {
          // Dragging left edge - clamp to image left boundary
          newLeft = Math.max(0, newLeft);
        }
        if (direction.includes('e')) {
          // Dragging right edge - clamp to image right boundary
          if (newLeft + newWidth > imgDisplayWidth) {
            newWidth = imgDisplayWidth - newLeft;
          }
        }
        if (direction.includes('n')) {
          // Dragging top edge - clamp to image top boundary
          newTop = Math.max(0, newTop);
        }
        if (direction.includes('s')) {
          // Dragging bottom edge - clamp to image bottom boundary
          if (newTop + newHeight > imgDisplayHeight) {
            newHeight = imgDisplayHeight - newTop;
          }
        }
        // Enforce minimum size
        newWidth = Math.max(50, newWidth);
        newHeight = Math.max(50, newHeight);
        cropModalCropbox.style.left = newLeft + 'px';
        cropModalCropbox.style.top = newTop + 'px';
        cropModalCropbox.style.width = newWidth + 'px';
        cropModalCropbox.style.height = newHeight + 'px';
        cropModalCropbox.style.transform = 'none';
      }

      function onResizeUp() {
        if (isResizing) {
          isResizing = false;
          
          // Restore text selection
          document.body.style.userSelect = '';
          document.body.style.webkitUserSelect = '';
          document.body.style.mozUserSelect = '';
          document.body.style.msUserSelect = '';
          
          document.removeEventListener('mousemove', onResizeMove);
          document.removeEventListener('mouseup', onResizeUp);
        }
      }

      document.addEventListener('mousemove', onResizeMove);
      document.addEventListener('mouseup', onResizeUp);
    }
    
    function removeCropBoxListeners() {
      // Remove all resize handles
      const cropBox = document.getElementById('crop-modal-cropbox');
      if (cropBox) {
        const handles = cropBox.querySelectorAll('.resize-handle');
        handles.forEach(handle => handle.remove());
      }
    }
    
    function revertToOriginal() {
      if (!origFabricImg || !origFabricImg._originalDataUrl) return;
      

      
      // Load the very original image for this specific image
              fabric.Image.fromURL(origFabricImg._originalDataUrl, newImg => {

          // Place at same center as current image
          newImg.set({
          left: origFabricImg.left,
          top: origFabricImg.top,
          originX: origFabricImg.originX,
          originY: origFabricImg.originY,
          scaleX: origFabricImg.scaleX,
          scaleY: origFabricImg.scaleY,
          angle: 0, // Reset to upright
          flipX: false, // Reset flips
          flipY: false,
          selectable: true,
          hasControls: true,
          hasBorders: true,
          stroke: 'transparent',
          strokeWidth: 0
        });
        
        // Replace the current image
        fabricCanvas.remove(origFabricImg);
        fabricCanvas.add(newImg);
        fabricCanvas.requestRenderAll();
        
        // Copy the original data URL to the new image (it's the same as the original)
        newImg._originalDataUrl = origFabricImg._originalDataUrl;
        
        // Update references
        origFabricImg = newImg;
        // Don't update originalFabricImg - it should always remain the very first image
        
        // Reset working orientation to upright
        workingRotation = 0;
        workingFlipH = false;
        workingFlipV = false;
        
        // Update modal to show the reverted image
        modalImageElement = new window.Image();
        modalImageElement.onload = function() {
          originalImageWidth = modalImageElement.width;
          originalImageHeight = modalImageElement.height;
          
          // Reset modal transforms to upright
          modalRotation = 0;
          modalFlipH = false;
          modalFlipV = false;
          
          drawModalCanvasWithTransforms();
        };
        modalImageElement.src = origFabricImg._originalDataUrl;
      });
    }
    
        function applyCrop() {
      if (!origFabricImg) return;
      
      const imgWidth = origFabricImg.width;
      const imgHeight = origFabricImg.height;
      const isHighRes = imgWidth * imgHeight > 10000000; // 10MP threshold
      const loadingText = document.getElementById('loading-text');

      // 1) Read the crop box + canvas size while they're still in the DOM
      const containerRect = cropModalImgContainer.getBoundingClientRect();
      const canvasRect = cropModalCanvas.getBoundingClientRect();
      const cropRect = cropModalCropbox.getBoundingClientRect();
      
      console.log('Pre-hide measurements:', {
        containerRect: { width: containerRect.width, height: containerRect.height },
        canvasRect: { width: canvasRect.width, height: canvasRect.height },
        cropRect: { width: cropRect.width, height: cropRect.height }
      });

      // 2) Show semi-transparent loading overlay (keep modal visible)

      console.log('Crop - Loading overlay z-index:', getComputedStyle(loadingOverlay).zIndex);
      console.log('Crop - Crop modal z-index:', getComputedStyle(cropModalOverlay).zIndex);
      loadingOverlay.classList.add('show');

      console.log('Crop - Loading overlay opacity after show:', getComputedStyle(loadingOverlay).opacity);
      
      if (isHighRes) {
        loadingText.textContent = 'Cropping high-resolution image...';
      } else {
        loadingText.textContent = 'Cropping image...';
      }

      // 3) Allow browser to paint the spinner before heavy work
      requestAnimationFrame(() => {
        // Even another rAF can help ensure paint
        requestAnimationFrame(() => {
          actuallyApplyCrop(containerRect, canvasRect, cropRect)
            .catch(err => {
              console.error('Crop failed:', err);
              alert('Crop failed: ' + err.message);
            })
            .finally(() => {
              // 4) Hide spinner only (leave modal visible) - with minimum display time

              setTimeout(() => {
                loadingOverlay.classList.remove('show');

              }, 500); // Minimum 500ms display time
            });
        });
      });
    }

    function actuallyApplyCrop(containerRect, canvasRect, cropRect) {
      // Check if crop box is valid using the pre-computed rects
      const cropWidth = cropRect.width;
      const cropHeight = cropRect.height;
      
      console.log('Crop box check:', {
        canvasRect: { width: canvasRect.width, height: canvasRect.height },
        containerRect: { width: containerRect.width, height: containerRect.height },
        cropRect: { width: cropRect.width, height: cropRect.height }
      });
      
      if (cropWidth === 0 || cropHeight === 0) {
        throw new Error('Crop area is zero-sized. Please resize the crop box before applying.');
      }

      // Calculate crop coordinates for the high-resolution original image
      // The modal canvas shows a scaled version, so we need to convert back to original coordinates
      const modalScale = origFabricImg._modalScale || 1;
      const originalImgWidth = origFabricImg.width;
      const originalImgHeight = origFabricImg.height;
      
      // Calculate the scale from modal canvas to original image
      const modalToOriginalScaleX = originalImgWidth / cropModalCanvas.width;
      const modalToOriginalScaleY = originalImgHeight / cropModalCanvas.height;
      
      // Convert crop coordinates from modal canvas to original image
      const scaleX = cropModalCanvas.width / canvasRect.width;
      const scaleY = cropModalCanvas.height / canvasRect.height;
      const modalSx = (cropRect.left - canvasRect.left) * scaleX;
      const modalSy = (cropRect.top - canvasRect.top) * scaleY;
      const modalSw = cropRect.width * scaleX;
      const modalSh = cropRect.height * scaleY;
      
      // Convert to original image coordinates
      const originalSx = modalSx * modalToOriginalScaleX;
      const originalSy = modalSy * modalToOriginalScaleY;
      const originalSw = modalSw * modalToOriginalScaleX;
      const originalSh = modalSh * modalToOriginalScaleY;

      console.log('Crop coordinates:', { 
        modal: { sx: modalSx, sy: modalSy, sw: modalSw, sh: modalSh },
        original: { sx: originalSx, sy: originalSy, sw: originalSw, sh: originalSh },
        originalImageSize: { width: originalImgWidth, height: originalImgHeight },
        modalScale: modalScale
      });

      // Create a temporary canvas for the high-resolution crop
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = originalSw;
      tempCanvas.height = originalSh;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Draw from the high-resolution original image
      if (origFabricImg._element && origFabricImg._element.complete) {
        tempCtx.drawImage(origFabricImg._element, originalSx, originalSy, originalSw, originalSh, 0, 0, originalSw, originalSh);
      } else {
        throw new Error('Original image element is not ready for cropping');
      }

      // Convert to Fabric.Image
      return new Promise((resolve, reject) => {
        fabric.Image.fromURL(tempCanvas.toDataURL(), newImg => {

          try {
            // Preserve original transform, then replace
            newImg.set({
              left: origFabricImg.left,
              top: origFabricImg.top,
              originX: origFabricImg.originX,
              originY: origFabricImg.originY,
              scaleX: origFabricImg.scaleX,
              scaleY: origFabricImg.scaleY,
              angle: origFabricImg.angle || 0, // Preserve current rotation
              flipX: origFabricImg.flipX || false, // Preserve current flip states
              flipY: origFabricImg.flipY || false,
              selectable: true,
              hasControls: true,
              hasBorders: true,
              stroke: 'transparent',
              strokeWidth: 0
            });

            // Copy original data URL
            newImg._originalDataUrl = origFabricImg._originalDataUrl;

            // Determine which canvas we're working with
            const targetCanvas = (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex') ? deskPadModalCanvas : fabricCanvas;

            
            // Replace the image
            targetCanvas.remove(origFabricImg);
            targetCanvas.add(newImg);
            targetCanvas.requestRenderAll();

            // Update references
            origFabricImg = newImg;
            // Don't update originalFabricImg - it should always remain the very first image
            

            // Reset working transforms since the cropped image is now in natural orientation
            workingRotation = 0;
            workingFlipH = false;
            workingFlipV = false;


            // Pre-cache the new image for modal use
            const maxModalSize = 2000;
            const imgWidth = newImg.width;
            const imgHeight = newImg.height;
            const scale = Math.min(maxModalSize / imgWidth, maxModalSize / imgHeight, 1);
            const modalWidth = Math.round(imgWidth * scale);
            const modalHeight = Math.round(imgHeight * scale);

            // Create a temporary canvas for the modal version
            const modalCanvas = document.createElement('canvas');
            const modalCtx = modalCanvas.getContext('2d');
            modalCanvas.width = modalWidth;
            modalCanvas.height = modalHeight;

            // Wait for the new image to be fully loaded before creating modal version
            if (newImg._element && newImg._element.complete) {
              modalCtx.drawImage(newImg._element, 0, 0, modalWidth, modalHeight);
              
              // Create and cache the modal image
              const cachedModalImg = new window.Image();
              cachedModalImg.onload = function() {
                newImg._cachedModalImage = cachedModalImg;
                newImg._modalScale = scale;
                
                // Update modal to show the new cropped image
                modalImageElement = cachedModalImg;
                originalImageWidth = modalImageElement.width;
                originalImageHeight = modalImageElement.height;
                
                exitCropMode();
                modalRotation = 0;
                modalFlipH = false;
                modalFlipV = false;
                drawModalCanvasWithTransforms();
                
                resolve();
              };
              cachedModalImg.src = modalCanvas.toDataURL('image/jpeg', 0.9);
            } else {
              // If image not ready, wait for it
              newImg._element.onload = function() {
                modalCtx.drawImage(newImg._element, 0, 0, modalWidth, modalHeight);
                
                const cachedModalImg = new window.Image();
                cachedModalImg.onload = function() {
                  newImg._cachedModalImage = cachedModalImg;
                  newImg._modalScale = scale;
                  
                  modalImageElement = cachedModalImg;
                  originalImageWidth = modalImageElement.width;
                  originalImageHeight = modalImageElement.height;
                  
                  exitCropMode();
                  modalRotation = 0;
                  modalFlipH = false;
                  modalFlipV = false;
                  drawModalCanvasWithTransforms();
                  
                  resolve();
                };
                cachedModalImg.src = modalCanvas.toDataURL('image/jpeg', 0.9);
              };
            }
          } catch (error) {
            reject(error);
          }
        }, { crossOrigin: 'anonymous' });
      });
    }

    // Double-click to open modal cropper
    if (fabricCanvas) {
      fabricCanvas.on('mouse:dblclick', function(opt) {
        const target = opt.target;
        if (target && target.type === 'image') {
                  // Check image size before showing loading overlay
        const isHighRes = target.width * target.height > 10000000; // 10MP threshold
        
        // Show loading overlay immediately with appropriate message
        loadingOverlay.classList.add('show');
        const loadingText = document.getElementById('loading-text');
        
        if (isHighRes) {
          loadingText.textContent = 'High-resolution image detected - this may take a moment...';
        } else {
          loadingText.textContent = 'Preparing image editor...';
        }
          
          // Use requestAnimationFrame to ensure UI is responsive, then get data URL
          requestAnimationFrame(() => {
            // Use a worker or setTimeout to make toDataURL truly non-blocking
            setTimeout(() => {
              const imgUrl = target.toDataURL();
              openCropModal(imgUrl, target);
            }, 50); // Small delay to ensure UI responsiveness
          });
        }
      });
    }



    function addImageToFabric(url, index = 0) {
      if (!fabricCanvas) {
        console.error('Fabric canvas is not available');
        return;
      }

      fabric.Image.fromURL(url, img => {


        
        // Auto-detect optimal canvas size on first upload
        if (!autoDetectionPerformed) {
          const optimalSize = calculateOptimalCanvasSize(img.width, img.height);
          targetCanvasWidth = optimalSize.width;
          targetCanvasHeight = optimalSize.height;
          resizeCanvas(optimalSize.width, optimalSize.height);
          
          targetDpiDisplay.innerHTML = `
            <strong>Canvas Auto-Adjusted:</strong><br>
            New size: ${optimalSize.width} √ó ${optimalSize.height}px<br>
            Dynamic sizing based on image<br>
            Aspect ratio: 77:29 maintained
          `;
          
          autoDetectionPerformed = true;
          
          // Wait for canvas resize to complete, then add image
          setTimeout(() => {
            addImageToCanvas(img, index);
          }, 200);
          return;
        }
        
        // If not first image, add directly
        addImageToCanvas(img, index);
      }, { crossOrigin: 'anonymous' });
    }

    function addImageToCanvas(img, index = 0) {
      // Use target canvas dimensions (the actual canvas size we want)
      const canvasW = targetCanvasWidth;
      const canvasH = targetCanvasHeight;

      
      const scale = Math.min(
        canvasW / img.width,
        canvasH / img.height,
        1  // Don't scale up - only scale down to fit
      );

      
      // Calculate position for multiple images (center within artboard area)
      const extendedCanvasWidth = fabricCanvas.getWidth();
      const extendedCanvasHeight = fabricCanvas.getHeight();
      const artboardLeft = (extendedCanvasWidth - artboardWidth) / 2;
      const artboardTop = (extendedCanvasHeight - artboardHeight) / 2;
      
      let left, top;
      if (index === 0) {
        // First image goes to center of artboard
        left = artboardLeft + (artboardWidth / 2);
        top = artboardTop + (artboardHeight / 2);
      } else {
        // Subsequent images get offset positions within artboard
        const offset = 50; // pixels between images
        const imagesPerRow = 3; // max images per row
        const row = Math.floor(index / imagesPerRow);
        const col = index % imagesPerRow;
        
        left = artboardLeft + (artboardWidth / 4) + (col * offset);
        top = artboardTop + (artboardHeight / 4) + (row * offset);
      }
      
      img.set({
        left: left,
        top: top,
        originX: 'center',
        originY: 'center',
        scaleX: scale,
        scaleY: scale,
        selectable: true,
        hasControls: true,
        hasBorders: true,
        stroke: 'transparent',
        strokeWidth: 0
      });
      


      
      // Update DPI display (use current canvas dimensions)
      updateDPIDisplay(img.width, img.height, canvasW, canvasH, scale);
      
      // Only clear canvas for first image (auto-detection)
      if (index === 0 && !autoDetectionPerformed) {
        fabricCanvas.clear();
      }
      
      fabricCanvas.add(img);
      fabricCanvas.requestRenderAll();
      
      

      
      // Pre-cache the image for modal use
      preCacheImageForModal(img);
      
      // Add to session images for recent images feature
      const imageDataUrl = img.toDataURL();
      if (!sessionImages.includes(imageDataUrl)) {
        sessionImages.push(imageDataUrl);

      }
      
      // Add double-click event for cropping
      img.on('mousedblclick', function() {

        // Check image size before showing loading overlay
        const isHighRes = img.width * img.height > 10000000; // 10MP threshold
        
        // Show loading overlay immediately with appropriate message
        loadingOverlay.classList.add('show');
        const loadingText = document.getElementById('loading-text');
        
        if (isHighRes) {
          loadingText.textContent = 'High-resolution image detected - this may take a moment...';
        } else {
          loadingText.textContent = 'Preparing image editor...';
        }
        
        // Use requestAnimationFrame to ensure UI is responsive, then get data URL
        requestAnimationFrame(() => {
          // Use a worker or setTimeout to make toDataURL truly non-blocking
          setTimeout(() => {
            const imgUrl = img.toDataURL();
            openCropModal(imgUrl, img);
          }, 50); // Small delay to ensure UI responsiveness
        });
      });
      
      // Alternative: Add to canvas level
      fabricCanvas.on('mouse:dblclick', function(options) {
        if (options.target === img) {

          // Check image size before showing loading overlay
          const isHighRes = img.width * img.height > 10000000; // 10MP threshold
          
          // Show loading overlay immediately with appropriate message
          loadingOverlay.classList.add('show');
          const loadingText = document.getElementById('loading-text');
          
          if (isHighRes) {
            loadingText.textContent = 'High-resolution image detected - this may take a moment...';
          } else {
            loadingText.textContent = 'Preparing image editor...';
          }
          
          // Use requestAnimationFrame to ensure UI is responsive, then get data URL
          requestAnimationFrame(() => {
            // Use a worker or setTimeout to make toDataURL truly non-blocking
            setTimeout(() => {
              const imgUrl = img.toDataURL();
              openCropModal(imgUrl, img);
            }, 50); // Small delay to ensure UI responsiveness
          });
        }
      });
      

    }



    // Desk Pad Editor functionality
    let deskPadModalCanvas = null;
    let deskPadButton = document.getElementById('desk-pad-button');
    let deskPadModalOverlay = document.getElementById('desk-pad-modal-overlay');
    let deskPadModalCanvasEl = document.getElementById('desk-pad-modal-canvas');
    let deskPadFinishedBtn = document.getElementById('desk-pad-finished-btn');
    let deskPadMenuBtn = document.getElementById('desk-pad-menu-btn');
    let buttonPreview = document.getElementById('button-preview');
    
    // Add Image Modal elements (now universal menu)
    let addImageModal = document.getElementById('add-image-modal');
    let addImageClose = document.getElementById('add-image-close');

    let recentImagesGrid = document.getElementById('recent-images-grid');
    let deskPadModalCanvasContainer = document.getElementById('desk-pad-modal-canvas-container');
    let menuAddImage = document.getElementById('menu-add-image');
    let menuRecentImages = document.getElementById('menu-recent-images');
    
    // Track recent images
    let recentImages = [];
    
    // Track all images used in this session
    let sessionImages = [];
    
    // Modal drag and drop elements
    let modalDropOverlay = document.getElementById('modal-drop-overlay');
    
    // Track if modal auto-detection has been performed
    let modalAutoDetectionPerformed = false;
    let modalTargetCanvasWidth = 4305;
    let modalTargetCanvasHeight = 1620;
    
    // Modal DPI display element
    let modalDpiDisplay = document.getElementById('modal-dpi-display');
    
    // DPI selection variables
    let currentDPI = 100; // Default to 100 DPI for better performance
    let currentCanvasWidth = 2900; // Default 100 DPI width (77:29 aspect ratio)
    let currentCanvasHeight = 1093; // Default 100 DPI height (77:29 aspect ratio)
    let dpiLocked = false; // Track if DPI is locked after auto-detection
    
    // --- Aspect Ratio Presets (Base dimensions at 150 DPI for editing) ---
    const aspectPresets = {
      extended:    { w: 4725, h: 1785, aspect: 77/29, name: '77:29 ‚Äî EXTENDED', proof: 'proof_extended.png' },    // 31.5" x 11.9" @150dpi
      immersive:   { w: 5310, h: 2220, aspect: 43/18, name: '43:18 ‚Äî IMMERSIVE', proof: 'proof_immersive.png' },   // 35.4" x 14" @150dpi
      laptop:      { w: 3815, h: 2250, aspect: 61/36, name: '61:36 ‚Äî LAPTOP / PLAYMAT', proof: 'proof_laptop.png' },      // 27" x 16" @150dpi
      fullsize:    { w: 5400, h: 2306, aspect: 96/41, name: '96:41 ‚Äî FULL SIZE', proof: 'proof_fullsize.png' },    // 36" x 15.37" @150dpi
      supersize:   { w: 7200, h: 3636, aspect: 101/51, name: '101:51 ‚Äî SUPER SIZE', proof: 'proof_supersize.png' }   // 48" x 24.24" @150dpi
    };
    
    // Smart DPI management - edit at screen resolution, export at print resolution
    const EDIT_DPI = 150;  // DPI for editing (smooth UX)
    const EXPORT_DPI = 300; // DPI for final export (print quality)
    let currentPreset = 'extended';
    
    // Initialize handle sizes for current DPI after variables are defined
    updateHandleSizes(currentDPI);
    
    // Function to load image asynchronously
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }
    
    // Function to generate preview with pad overlay
    async function generatePreview() {


      console.log('Canvas objects:', deskPadModalCanvas ? deskPadModalCanvas.getObjects().length : 'no canvas');
      
      if (!deskPadModalCanvas || deskPadModalCanvas.getObjects().length === 0) {
        alert('No content to preview. Please add some images or text first.');
        return;
      }

      const preset = aspectPresets[currentPreset];
      if (!preset) {
        alert('No preset found for current aspect ratio.');
        return;
      }

      // Get and load the proof PNG
      let proofImg;
      try {
        proofImg = await loadImage(preset.proof);
      } catch (err) {
        console.error('Could not load proof overlay image:', err);
        alert('Could not load preview overlay. Please check if the proof image files are available.');
        return;
      }

      // Hide selection handles for clean preview
      const prevActive = deskPadModalCanvas.getActiveObject();
      deskPadModalCanvas.discardActiveObject();
      deskPadModalCanvas.renderAll();

      // Generate user image PNG
      const w = proofImg.width, h = proofImg.height;
      const temp = document.createElement('canvas');
      temp.width = w; temp.height = h;
      const tctx = temp.getContext('2d');

      const userAR = deskPadModalCanvas.getWidth() / deskPadModalCanvas.getHeight();
      const proofAR = w / h;
      let drawW, drawH, drawX, drawY;
      if (userAR > proofAR) {
        drawH = h;
        drawW = h * userAR;
        drawX = (w - drawW) / 2;
        drawY = 0;
      } else {
        drawW = w;
        drawH = w / userAR;
        drawX = 0;
        drawY = (h - drawH) / 2;
      }
      tctx.drawImage(deskPadModalCanvas.lowerCanvasEl, drawX, drawY, drawW, drawH);

      const userImgURL = temp.toDataURL('image/png');
      let userImg;
      try {
        userImg = await loadImage(userImgURL);
      } catch (err) {
        console.error('Could not generate user image for preview:', err);
        alert('Could not generate preview image.');
        return;
      }

      // Create the composite preview
      const workCanvas = document.createElement('canvas');
      workCanvas.width = w; workCanvas.height = h;
      const ctx = workCanvas.getContext('2d');
      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(userImg, 0, 0, w, h);

      // Use composite operations instead of getImageData to avoid tainted canvas issues
      // First, draw the proof image as a mask
      ctx.save();
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(proofImg, 0, 0, w, h);
      ctx.restore();

      // Overlay proof PNG multiple times with different blend/opacity
      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = "overlay";
      ctx.drawImage(proofImg, 0, 0, w, h);
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = "overlay";
      ctx.drawImage(proofImg, 0, 0, w, h);
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = "overlay";
      ctx.drawImage(proofImg, 0, 0, w, h);
      ctx.restore();

      // Update the preview canvas and show modal
      const previewCanvas = document.getElementById('previewCanvas');
      if (previewCanvas) {
        previewCanvas.width = w;
        previewCanvas.height = h;
        const pctx = previewCanvas.getContext('2d');
        pctx.drawImage(workCanvas, 0, 0, w, h);
        
        // Show the preview modal
        const previewModal = document.getElementById('previewModal');

        previewModal.style.display = 'flex';

      }

      // Restore active object
      if (prevActive) {
        deskPadModalCanvas.setActiveObject(prevActive);
        deskPadModalCanvas.renderAll();
      }
    }
    
    // Save preview functionality
    document.getElementById('btn-save-preview').addEventListener('click', function() {
      const previewCanvas = document.getElementById('previewCanvas');
      if (previewCanvas) {
        const link = document.createElement('a');
        link.download = `preview_${currentPreset}_${Date.now()}.png`;
        link.href = previewCanvas.toDataURL('image/png');
        link.click();
      }
    });
    
    // Function to auto-detect appropriate DPI based on image resolution
    function autoDetectDPI(imageWidth, imageHeight) {
      const imagePixels = imageWidth * imageHeight;

      
      // Calculate what DPI this image would be at the current canvas size
      const preset = aspectPresets[currentPreset];
      const canvasWidth = preset.w;
      const canvasHeight = preset.h;
      
      // Calculate DPI if this image filled the canvas
      const dpiIfFilled = Math.min(
        imageWidth / (canvasWidth / 150), // Width-based DPI
        imageHeight / (canvasHeight / 150) // Height-based DPI
      );
      

      
      // Smart DPI selection based on image quality
      if (dpiIfFilled >= 300) {

        return 300;
      } else if (dpiIfFilled >= 200) {

        return 200;
      } else if (dpiIfFilled >= 150) {

        return 150;
      } else {

        return 100;
      }
    }
    
    // Function to lock DPI options (gray out non-selected options)
    function lockDPIOptions(selectedDPI) {

      dpiLocked = true;
      
      const dpiOptions = document.querySelectorAll('.dpi-option');
      dpiOptions.forEach(option => {
        const optionDPI = parseInt(option.dataset.dpi);
        if (optionDPI !== selectedDPI) {
          option.classList.add('locked');
        } else {
          option.classList.remove('locked');
        }
      });
      
      // Show lock indicator
      const lockIndicator = document.getElementById('dpi-lock-indicator');
      if (lockIndicator) {
        lockIndicator.style.display = 'inline';
      }
    }
    
    // Function to unlock DPI options
    function unlockDPIOptions() {

      dpiLocked = false;
      
      const dpiOptions = document.querySelectorAll('.dpi-option');
      dpiOptions.forEach(option => {
        option.classList.remove('locked');
      });
      
      // Hide lock indicator
      const lockIndicator = document.getElementById('dpi-lock-indicator');
      if (lockIndicator) {
        lockIndicator.style.display = 'none';
      }
    }
    
    // Function to show DPI change warning
    function showDPIChangeWarning(callback) {
      const warningMessage = `‚ö†Ô∏è Warning: Changing DPI will clear the canvas.\n\n` +
                           `All existing images will be removed to ensure proper functionality with the new DPI settings.\n\n` +
                           `You can re-add your images after the DPI change.\n\n` +
                           `Are you sure you want to continue?`;
      
      if (confirm(warningMessage)) {
        callback();
      }
    }
    
    // Function to update transform handle sizes based on DPI
    function updateHandleSizes(dpi) {

      
      // Calculate handle size based on DPI
      let handleSize, strokeWidth, borderScale;
      
      switch(dpi) {
        case 100:
          handleSize = 30;
          strokeWidth = 2;
          borderScale = 2;
          break;
        case 200:
          handleSize = 55; // Double the size for 200 DPI
          strokeWidth = 3;
          borderScale = 3;
          break;
        case 300:
          handleSize = 80; // Double again for 300 DPI
          strokeWidth = 4;
          borderScale = 4;
          break;
        default:
          handleSize = 20;
          strokeWidth = 2;
          borderScale = 2;
      }
      
      // Update global Fabric.js settings
      fabric.Object.prototype.cornerSize = handleSize;
      fabric.Object.prototype.cornerStrokeWidth = strokeWidth;
      fabric.Object.prototype.borderScaleFactor = borderScale;
      
      // Update existing objects on the canvas
      if (deskPadModalCanvas) {
        const objects = deskPadModalCanvas.getObjects();
        objects.forEach(obj => {
          obj.set({
            cornerSize: handleSize,
            cornerStrokeWidth: strokeWidth,
            borderScaleFactor: borderScale
          });
        });
        deskPadModalCanvas.requestRenderAll();

      }
      

    }
    
    // Function to force update all existing objects with current handle sizes
    function forceUpdateAllHandles() {
      if (deskPadModalCanvas) {
        const objects = deskPadModalCanvas.getObjects();
        const handleSize = fabric.Object.prototype.cornerSize;
        const strokeWidth = fabric.Object.prototype.cornerStrokeWidth;
        const borderScale = fabric.Object.prototype.borderScaleFactor;
        
        objects.forEach(obj => {
          obj.set({
            cornerSize: handleSize,
            cornerStrokeWidth: strokeWidth,
            borderScaleFactor: borderScale
          });
        });
        deskPadModalCanvas.requestRenderAll();

      }
    }
    
    // --- Aspect Ratio Preset Functions ---
    function applyAspectPreset(presetKey) {
      const preset = aspectPresets[presetKey];
      if (!preset) return;
      

      currentPreset = presetKey;
      
      // Calculate canvas dimensions based on current DPI
      // Base dimensions are at 150 DPI, so scale relative to 150 DPI
      const dpiScale = currentDPI / 150;
      const canvasWidth = Math.round(preset.w * dpiScale);
      const canvasHeight = Math.round(preset.h * dpiScale);
      
      // Performance warning for very large canvases
      const totalPixels = canvasWidth * canvasHeight;
      if (totalPixels > 10000000) { // 10 million pixels
        console.warn(`‚ö†Ô∏è Large canvas detected: ${canvasWidth} √ó ${canvasHeight} = ${(totalPixels/1000000).toFixed(1)}M pixels`);
        console.warn(`üí° Consider using a smaller aspect ratio or lower DPI for better performance`);
      }
      
      // Update global variables
      currentCanvasWidth = canvasWidth;
      currentCanvasHeight = canvasHeight;
      
      // Update the current canvas size display
      const currentCanvasSizeDisplay = document.getElementById('current-canvas-size-display');
      if (currentCanvasSizeDisplay) {
        currentCanvasSizeDisplay.textContent = preset.name;
      }
      
      // Update the current DPI display in the menu to show new canvas dimensions
      const currentDpiDisplay = document.getElementById('current-dpi-display');
      if (currentDpiDisplay) {
        const exportWidth = Math.round(canvasWidth * (EXPORT_DPI / currentDPI));
        const exportHeight = Math.round(canvasHeight * (EXPORT_DPI / currentDPI));
        currentDpiDisplay.textContent = `${currentDPI} DPI ‚Ä¢ ${canvasWidth} √ó ${canvasHeight}px (Export: ${exportWidth} √ó ${exportHeight}px @ ${EXPORT_DPI} DPI)`;
      }
      
      // Update canvas size info display
      const canvasSizeInfo = document.getElementById('canvas-size-info');
      if (canvasSizeInfo) {
        const aspectRatio = (canvasWidth / canvasHeight).toFixed(3);
        const printWidth = (canvasWidth / currentDPI * 25.4).toFixed(1);
        const printHeight = (canvasHeight / currentDPI * 25.4).toFixed(1);
        
        canvasSizeInfo.innerHTML = `
          <strong>Canvas Size:</strong> ${canvasWidth} √ó ${canvasHeight}px<br>
          <strong>Aspect Ratio:</strong> ${aspectRatio} (${preset.aspect.toFixed(2)}:1)<br>
          <strong>Print Quality:</strong> ${currentDPI} DPI<br>
          <strong>Print Size:</strong> ${printWidth}cm √ó ${printHeight}cm<br>
          <small>Images will scale to fit but won't upscale if too small</small>
        `;
      }
      
      // If canvas exists, resize it
      if (deskPadModalCanvas) {
        // Store existing objects before resize
        const existingObjects = deskPadModalCanvas.getObjects().filter(obj => obj.type !== 'rect'); // Exclude test rectangles
        const oldWidth = deskPadModalCanvas.getWidth();
        const oldHeight = deskPadModalCanvas.getHeight();
        

        
                // Resize canvas
        deskPadModalCanvas.setWidth(canvasWidth);
        deskPadModalCanvas.setHeight(canvasHeight);
        
        // Ensure snapping settings are preserved after resize with DPI scaling
        const scaledSnapThreshold = Math.round(30 * dpiScale);
        const scaledSnapAngle = Math.round(30 * dpiScale);
        
        deskPadModalCanvas.set({
          snapAngle: scaledSnapAngle,
          snapThreshold: scaledSnapThreshold
        });
        
        // Force recalculation of transform controls
        deskPadModalCanvas.calcOffset();
        deskPadModalCanvas.requestRenderAll();
        
        // Reset zoom to fit the new canvas size
        setTimeout(() => {
          canvasZoomFit();
          
          // Simple function to center all objects in the canvas
          setTimeout(() => {
            centerAllObjectsInCanvas();
          }, 100);
        }, 200);
      }
    }
    
    // Function to update canvas resolution based on DPI selection
    function updateCanvasResolution(dpi, width, height) {

      
      // Update global variables
      currentDPI = dpi;
      currentCanvasWidth = width;
      currentCanvasHeight = height;
      
      // Update the current DPI display in the menu
      const currentDpiDisplay = document.getElementById('current-dpi-display');
      if (currentDpiDisplay) {
        currentDpiDisplay.textContent = `${dpi} DPI ‚Ä¢ ${width} √ó ${height}px`;
      }
      
      // Update transform handle sizes based on DPI
      updateHandleSizes(dpi);
      
      // Reset zoom to fit the new canvas size
      setTimeout(() => {
        canvasZoomFit();
        
        // Center objects after zoom
        setTimeout(() => {
          centerAllObjectsInCanvas();
        }, 100);
      }, 200);
      
      // Update canvas size info display
      const canvasSizeInfo = document.getElementById('canvas-size-info');
      if (canvasSizeInfo) {
        canvasSizeInfo.innerHTML = `
          <strong>Canvas Size:</strong> ${width} √ó ${height}px<br>
          <strong>Aspect Ratio:</strong> ${(width/height).toFixed(3)} (77:29)<br>
          <strong>Print Quality:</strong> ${dpi} DPI<br>
          <strong>Print Size:</strong> 11" √ó 29"<br>
          <small>Images will scale to fit but won't upscale if too small</small>
        `;
      }
      
      // If canvas exists, resize it
      if (deskPadModalCanvas) {
        // Resize canvas
        deskPadModalCanvas.setWidth(width);
        deskPadModalCanvas.setHeight(height);
        
        // Ensure snapping settings are preserved after resize with DPI scaling
        const dpiScale = currentDPI / 100;
        const scaledSnapThreshold = Math.round(30 * dpiScale); // Increased from 15 to 30
        const scaledSnapAngle = Math.round(30 * dpiScale); // Increased from 15 to 30
        
        deskPadModalCanvas.set({
          snapAngle: scaledSnapAngle,
          snapThreshold: scaledSnapThreshold,
          snapAngleThreshold: scaledSnapAngle
        });
        
        console.log('Canvas snapping settings restored after DPI change:', {
          snapAngle: deskPadModalCanvas.snapAngle,
          snapThreshold: deskPadModalCanvas.snapThreshold,
          snapAngleThreshold: deskPadModalCanvas.snapAngleThreshold,
          dpiScale: dpiScale,
          baseThreshold: 30
        });
        
        // Clear canvas completely - much simpler than trying to preserve objects
        deskPadModalCanvas.clear();
        
        // Update stored dimensions
        modalCanvasWidth = width;
        modalCanvasHeight = height;
        
        // Force Fabric.js to recalculate offsets after resize
        deskPadModalCanvas.calcOffset();
        


      }
    }
    
    function updateModalDPIDisplay(imageWidth, imageHeight, canvasWidth, canvasHeight, scale) {
      const dpi = calculateDPI(imageWidth, imageHeight, canvasWidth, canvasHeight);
      const scaledWidth = Math.round(imageWidth * scale);
      const scaledHeight = Math.round(imageHeight * scale);
      
      modalDpiDisplay.innerHTML = `
        <strong>Modal Image DPI Info:</strong><br>
        Original: ${imageWidth} √ó ${imageHeight}px<br>
        Scaled: ${scaledWidth} √ó ${scaledHeight}px<br>
        DPI: ${dpi.dpiX} √ó ${dpi.dpiY}<br>
        Scale: ${(scale * 100).toFixed(1)}%
      `;
    }
    

    

    


    // Initialize simple desk pad modal canvas
    function initResizableDeskPadModalCanvas() {
      
      if (!deskPadModalCanvas) {
        try {
          // Initialize with the current aspect ratio preset
          applyAspectPreset(currentPreset);
          
          // Use current DPI-based dimensions from the preset
          let canvasWidth = currentCanvasWidth;
          let canvasHeight = currentCanvasHeight;
          

          
          // Create canvas with CSS background and snapping
          const dpiScale = currentDPI / 100;
          const scaledSnapThreshold = Math.round(30 * dpiScale); // Increased from 15 to 30
          const scaledSnapAngle = Math.round(30 * dpiScale); // Increased from 15 to 30
          
          deskPadModalCanvas = new fabric.Canvas('desk-pad-modal-canvas', {
            width: canvasWidth,
            height: canvasHeight,
            selection: true,
            snapAngle: scaledSnapAngle,
            snapThreshold: scaledSnapThreshold,
            snapAngleThreshold: scaledSnapAngle,
            // Performance optimizations for large canvases
            enableRetinaScaling: false, // Disable retina scaling for better performance
            renderOnAddRemove: false, // Don't render on every add/remove
            skipTargetFind: false, // Keep target finding for interactions
            preserveObjectStacking: true, // Maintain object order
            // Reduce rendering frequency for better performance
            skipOffscreen: true, // Skip rendering objects outside viewport
            // Optimize for large canvases
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'high',
            // Enable text editing
            textEditing: true
          });
          
          // Set custom control colors for better visibility on white background
          deskPadModalCanvas.set({
            transparentCorners: false,
            cornerColor: '#2c3e50', // Dark blue-gray
            cornerStrokeColor: '#ffffff', // White border
            cornerSize: 12,
            cornerStyle: 'circle',
            borderColor: '#2c3e50', // Dark blue-gray border
            borderScaleFactor: 2
          });
          

          
          // Canvas is working - no need for raw click logging
          

          
          // Store dimensions
          modalArtboardWidth = canvasWidth;
          modalArtboardHeight = canvasHeight;
          modalCanvasWidth = canvasWidth;
          modalCanvasHeight = canvasHeight;
          
          // Update size display with initial values
          updateCanvasSizeDisplay(canvasWidth, canvasHeight);
          

          
          // Selection events - using Fabric.js built-in selection border system
          deskPadModalCanvas.on('selection:created', function(opt) {
            updateAlignmentToolbar();
            updatePropertiesPanelFromSelection(opt.selected[0]);
          });
          
          deskPadModalCanvas.on('selection:updated', function(opt) {
            updateAlignmentToolbar();
            updatePropertiesPanelFromSelection(opt.selected[0]);
          });
          
          deskPadModalCanvas.on('selection:cleared', function(opt) {
            updateAlignmentToolbar();
            updatePropertiesPanelFromSelection(null);
          });
          
          deskPadModalCanvas.on('object:moving', function(opt) {
            // Simple border snapping (reduced logging for performance)
            if (opt.target) {
              applySimpleSnapping(opt.target);
            }
          });
          
          deskPadModalCanvas.on('object:modified', function(opt) {

          });
          
          // Add text editing event listeners
          deskPadModalCanvas.on('text:editing:entered', function(opt) {

          });
          
          deskPadModalCanvas.on('text:editing:exited', function(opt) {

          });
          
          // Border rectangle removed - canvas is now clean without internal border
          
          // Canvas is ready for images

  
          
          // Force update any existing objects with current handle sizes
          setTimeout(() => {
            forceUpdateAllHandles();
          }, 100);
          

          
          // Add zoom functionality
          setupCanvasZoomAndPan(deskPadModalCanvas);
          
          // Initialize zoom display and fit canvas to view
          const zoomDisplay = document.getElementById('zoom-level');
          if (zoomDisplay) {
            zoomDisplay.textContent = '100%';
          }
          
          // Automatically fit canvas to viewport on initialization
          setTimeout(() => {
            canvasZoomFit();
          }, 100);
          
          // Setup simple snapping
          setupCanvasSnapping();
          
          // Ensure all objects have current DPI-based snapping settings
          updateAllObjectsSnappingSettings();
          
          // Add keyboard shortcuts for canvas viewport zooming
          document.addEventListener('keydown', function(e) {
            if (e.ctrlKey) {
              if (e.key === '+' || e.key === '=') {
                e.preventDefault();
                canvasZoomIn();
              } else if (e.key === '-') {
                e.preventDefault();
                canvasZoomOut();
              }
            }
          });
          
          // Add double-click event listener
          deskPadModalCanvas.on('mouse:dblclick', function(opt) {
            const target = opt.target;

            if (target && target.type === 'image') {
              const isHighRes = target.width * target.height > 10000000;
              
              loadingOverlay.classList.add('show');
              const loadingText = document.getElementById('loading-text');
              
              if (isHighRes) {
                loadingText.textContent = 'High-resolution image detected - this may take a moment...';
              } else {
                loadingText.textContent = 'Preparing image editor...';
              }
              
              requestAnimationFrame(() => {
                setTimeout(() => {
                  const imgUrl = target.toDataURL();
                  openCropModal(imgUrl, target);
                }, 50);
              });
            } else if (target && target.type === 'i-text') {
              // Handle text editing via modal

              showTextEditorModal(target);
            }
          });
          

          
        } catch (err) {
          console.error('Failed to initialize resizable desk pad modal canvas:', err);
          alert('Failed to initialize the full-screen editor. Please try again.');
        }
      } else {

      }
    }

    // Text Editor Modal Functions
    let editingTextObj = null;

    function showTextEditorModal(obj) {
      // Create modal if not exists
      let modal = document.getElementById('textEditorModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'textEditorModal';
        modal.className = 'editor-overlay';
        modal.style.cssText = 'position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:999999; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center;';
        modal.innerHTML = `
          <div style="background:#333; color:#fff; border-radius:8px; padding:1.5rem; width:760px; max-width:90vw; max-height:80vh; overflow-y:auto; border:2px solid #f4a012; box-shadow:0 8px 25px rgba(0,0,0,0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <h3 style="margin: 0; color: #f4a012; font-size: 18px;">Edit Text</h3>
              <button id="textModalClose" style="background: none; border: none; color: #f4a012; cursor: pointer; font-size: 20px; padding: 0;">√ó</button>
            </div>
            <div id="textPreview" style="min-height: 30px; max-height: 120px; padding: 8px; border: 1px solid #555; border-radius: 4px; background: #444; text-align: center; font-size: 12px; color: #ccc; margin-bottom: 1rem; overflow-y: auto; word-wrap: break-word;">
              <span style="color: #888;">Preview...</span>
            </div>
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; color: #f4a012; font-weight: bold; font-size: 14px;">Text:</label>
              <textarea id="textInput" placeholder="Enter text..." style="resize: none; overflow: hidden; min-height: 35px; max-height: 30vh; width: 100%; border: 1px solid #555; padding: 8px; border-radius: 4px; background: #444; color: #fff; font-size: 14px;"></textarea>
            </div>
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; color: #f4a012; font-weight: bold; font-size: 14px;">Font:</label>
              <select id="modalFont" style="width: 100%; padding: 8px; border: 1px solid #555; border-radius: 4px; background: #444; color: #fff; font-size: 14px;">
                <option value="Arial">Arial</option>
                <option value="Helvetica">Helvetica</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Georgia">Georgia</option>
                <option value="Verdana">Verdana</option>
                <option value="Impact">Impact</option>
                <option value="Comic Sans MS">Comic Sans MS</option>
                <option value="Courier New">Courier New</option>
                <option value="Lucida Console">Lucida Console</option>
                <option value="Tahoma">Tahoma</option>
                <option value="Trebuchet MS">Trebuchet MS</option>
                <option value="Arial Black">Arial Black</option>
                <option value="Bookman Old Style">Bookman Old Style</option>
                <option value="Garamond">Garamond</option>
                <option value="Palatino">Palatino</option>
                <option value="Century Gothic">Century Gothic</option>
                <option value="Avant Garde">Avant Garde</option>
                <option value="Brush Script MT">Brush Script MT</option>
                <option value="Lucida Handwriting">Lucida Handwriting</option>
              </select>
            </div>
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; color: #f4a012; font-weight: bold; font-size: 14px;">Size:</label>
              <input type="number" id="modalFontSize" min="8" max="500" value="45" placeholder="Font Size" style="width: 100%; padding: 8px; border: 1px solid #555; border-radius: 4px; background: #444; color: #fff; font-size: 14px;">
            </div>
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; color: #f4a012; font-weight: bold; font-size: 14px;">Color:</label>
              <input type="color" id="modalFontColor" value="#ffffff" title="Text Color" style="width: 100%; height: 35px; border: 1px solid #555; border-radius: 4px;">
            </div>
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; color: #f4a012; font-weight: bold; font-size: 14px;">Style:</label>
              <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <button id="modalBold" style="padding: 6px 12px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 4px; cursor: pointer; font-size: 12px;">Bold</button>
                <button id="modalItalic" style="padding: 6px 12px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 4px; cursor: pointer; font-size: 12px;">Italic</button>
                <button id="modalUnderline" style="padding: 6px 12px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 4px; cursor: pointer; font-size: 12px;">Underline</button>
              </div>
            </div>
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; color: #f4a012; font-weight: bold; font-size: 14px;">Alignment:</label>
              <div style="display: flex; gap: 0.5rem;">
                <button id="modalAlignLeft" style="padding: 6px 12px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 4px; cursor: pointer; font-size: 12px;">Left</button>
                <button id="modalAlignCenter" style="padding: 6px 12px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 4px; cursor: pointer; font-size: 12px;">Center</button>
                <button id="modalAlignRight" style="padding: 6px 12px; border: 1px solid #555; background: #444; color: #ccc; border-radius: 4px; cursor: pointer; font-size: 12px;">Right</button>
              </div>
            </div>
            <div style="text-align: center; margin-top: 1.5rem;">
              <button id="modalApply" style="padding: 8px 16px; margin-right: 0.75rem; border: none; background: #f4a012; color: white; border-radius: 4px; cursor: pointer; font-size: 14px;">Apply</button>
              <button id="modalCancel" style="padding: 8px 16px; border: 1px solid #555; background: #444; color: #fff; border-radius: 4px; cursor: pointer; font-size: 14px;">Cancel</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }
      
      // Set values
      const textInput = modal.querySelector('#textInput');
      const fontSel = modal.querySelector('#modalFont');
      const fontSize = modal.querySelector('#modalFontSize');
      const fontColor = modal.querySelector('#modalFontColor');
      let bold = false, italic = false, underline = false, align = 'center';
      
      if (obj) {
        textInput.value = obj.text;
        fontSel.value = obj.fontFamily;
        fontSize.value = obj.fontSize;
        fontColor.value = obj.fill;
        bold = obj.fontWeight === 'bold';
        italic = obj.fontStyle === 'italic';
        underline = !!obj.underline;
        align = obj.textAlign || 'center';
        editingTextObj = obj;
      } else {
        textInput.value = '';
        fontSel.value = 'Arial';
        fontSize.value = 45;
        fontColor.value = '#ffffff';
        bold = italic = underline = false;
        align = 'center';
        editingTextObj = null;
      }
      
      // Button states
      function updateBtnStates() {
        const boldBtn = modal.querySelector('#modalBold');
        const italicBtn = modal.querySelector('#modalItalic');
        const underlineBtn = modal.querySelector('#modalUnderline');
        const leftBtn = modal.querySelector('#modalAlignLeft');
        const centerBtn = modal.querySelector('#modalAlignCenter');
        const rightBtn = modal.querySelector('#modalAlignRight');
        
        // Update bold button
        boldBtn.style.background = bold ? '#f4a012' : '#444';
        boldBtn.style.color = bold ? '#fff' : '#ccc';
        boldBtn.style.borderColor = bold ? '#f4a012' : '#555';
        
        // Update italic button
        italicBtn.style.background = italic ? '#f4a012' : '#444';
        italicBtn.style.color = italic ? '#fff' : '#ccc';
        italicBtn.style.borderColor = italic ? '#f4a012' : '#555';
        
        // Update underline button
        underlineBtn.style.background = underline ? '#f4a012' : '#444';
        underlineBtn.style.color = underline ? '#fff' : '#ccc';
        underlineBtn.style.borderColor = underline ? '#f4a012' : '#555';
        
        // Update alignment buttons
        leftBtn.style.background = align === 'left' ? '#f4a012' : '#444';
        leftBtn.style.color = align === 'left' ? '#fff' : '#ccc';
        leftBtn.style.borderColor = align === 'left' ? '#f4a012' : '#555';
        
        centerBtn.style.background = align === 'center' ? '#f4a012' : '#444';
        centerBtn.style.color = align === 'center' ? '#fff' : '#ccc';
        centerBtn.style.borderColor = align === 'center' ? '#f4a012' : '#555';
        
        rightBtn.style.background = align === 'right' ? '#f4a012' : '#444';
        rightBtn.style.color = align === 'right' ? '#fff' : '#ccc';
        rightBtn.style.borderColor = align === 'right' ? '#f4a012' : '#555';
      }
      updateBtnStates();
      
      // Button events
      modal.querySelector('#modalBold').onclick = () => { bold = !bold; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalItalic').onclick = () => { italic = !italic; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalUnderline').onclick = () => { underline = !underline; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalAlignLeft').onclick = () => { align = 'left'; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalAlignCenter').onclick = () => { align = 'center'; updateBtnStates(); updateTextPreview(); };
      modal.querySelector('#modalAlignRight').onclick = () => { align = 'right'; updateBtnStates(); updateTextPreview(); };
      
      // Apply
      modal.querySelector('#modalApply').onclick = function() {
        const opts = {
          fontFamily: fontSel.value,
          fontSize: parseInt(fontSize.value, 10),
          fill: fontColor.value,
          fontWeight: bold ? 'bold' : 'normal',
          fontStyle: italic ? 'italic' : 'normal',
          underline: underline,
          textAlign: align
        };
        
        if (editingTextObj) {
          // For existing text, preserve position and only update text properties
          editingTextObj.set({ ...opts, text: textInput.value });
          deskPadModalCanvas.requestRenderAll();
        } else {
          // For new text, set position to center
          const newTextOpts = {
            ...opts,
            left: deskPadModalCanvas.getWidth() / 2,
            top: deskPadModalCanvas.getHeight() / 2,
            originX: 'center',
            originY: 'center',
            textBaseline: 'alphabetic', // Fix for CanvasTextBaseline error
            selectable: true,
            evented: true,
            editable: false
          };
          const t = new fabric.IText(textInput.value, newTextOpts);
          deskPadModalCanvas.add(t).setActiveObject(t);
          deskPadModalCanvas.requestRenderAll();
        }
        closeTextEditorModal();
      };
      
      modal.querySelector('#modalCancel').onclick = closeTextEditorModal;
      
      // Close button functionality
      modal.querySelector('#textModalClose').onclick = closeTextEditorModal;
      
      // Auto-expand textarea functionality
      function autoExpandTextarea() {
        textInput.style.height = 'auto';
        const scrollHeight = textInput.scrollHeight;
        const maxHeight = Math.min(window.innerHeight * 0.5, 300);
        textInput.style.height = Math.min(scrollHeight, maxHeight) + 'px';
      }
      
      // Update text preview functionality
      function updateTextPreview() {
        const preview = modal.querySelector('#textPreview');
        const text = textInput.value.trim();
        
        if (!text) {
          preview.innerHTML = '<span style="color: #888;">Preview...</span>';
          preview.style.height = '30px';
          return;
        }
        
        const previewText = document.createElement('div');
        // Handle line breaks by converting \n to <br> tags
        const processedText = text.replace(/\n/g, '<br>');
        previewText.innerHTML = text.length > 200 ? processedText.substring(0, 200) + '...' : processedText;
        previewText.style.fontFamily = fontSel.value;
        previewText.style.fontSize = Math.min(parseInt(fontSize.value), 18) + 'px';
        previewText.style.color = fontColor.value;
        previewText.style.fontWeight = bold ? 'bold' : 'normal';
        previewText.style.fontStyle = italic ? 'italic' : 'normal';
        previewText.style.textDecoration = underline ? 'underline' : 'none';
        previewText.style.textAlign = align;
        previewText.style.display = 'block';
        previewText.style.width = '100%';
        previewText.style.overflow = 'hidden';
        previewText.style.wordWrap = 'break-word';
        previewText.style.lineHeight = '1.4';
        
        preview.innerHTML = '';
        preview.appendChild(previewText);
        
        // Adjust preview height based on content
        const previewHeight = Math.min(Math.max(previewText.scrollHeight + 16, 30), 120);
        preview.style.height = previewHeight + 'px';
      }
      
      // Add event listeners for auto-expand and preview
      textInput.addEventListener('input', () => {
        autoExpandTextarea();
        updateTextPreview();
      });
      textInput.addEventListener('keydown', autoExpandTextarea);
      
      // Add event listeners for formatting changes
      fontSel.addEventListener('change', updateTextPreview);
      fontSize.addEventListener('input', updateTextPreview);
      fontColor.addEventListener('input', updateTextPreview);
      
      // Initial expand and preview
      setTimeout(() => {
        autoExpandTextarea();
        updateTextPreview();
      }, 10);
      
      modal.style.display = 'flex';
      textInput.focus();
    }
    
    function closeTextEditorModal() {
      const modal = document.getElementById('textEditorModal');
      if (modal) modal.style.display = 'none';
      editingTextObj = null;
    }

    // Font selection menu
    function showFontSelectionMenu() {
      // Create font selection popup if not exists
      let fontPopup = document.getElementById('font-selection-popup');
      if (!fontPopup) {
        fontPopup = document.createElement('div');
        fontPopup.id = 'font-selection-popup';
        fontPopup.className = 'shortcut-popup';
        fontPopup.style.cssText = 'position: absolute; left: 90px; top: 0; background: #333; border-radius: 8px; padding: 15px; min-width: 300px; max-width: 400px; max-height: 80vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: none;';
        
        // Font list with categories
        const fonts = [
          { category: 'Sans Serif', fonts: ['Arial', 'Helvetica', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Arial Black'] },
          { category: 'Serif', fonts: ['Times New Roman', 'Georgia', 'Garamond', 'Bookman Old Style', 'Palatino'] },
          { category: 'Display', fonts: ['Impact', 'Comic Sans MS', 'Brush Script MT', 'Lucida Handwriting'] },
          { category: 'Monospace', fonts: ['Courier New', 'Lucida Console'] }
        ];
        
        let fontOptionsHTML = '';
        fonts.forEach(category => {
          fontOptionsHTML += `<div class="font-category" style="margin-bottom: 15px;">
            <h4 style="color: #f4a012; margin-bottom: 8px; font-size: 14px; border-bottom: 1px solid #555; padding-bottom: 4px;">${category.category}</h4>`;
          
          category.fonts.forEach(font => {
            fontOptionsHTML += `
              <div class="font-option" data-font="${font}" style="
                padding: 8px 12px; 
                border: 1px solid #555; 
                border-radius: 4px; 
                background: #444; 
                cursor: pointer; 
                transition: all 0.2s;
                font-family: '${font}', sans-serif;
                margin-bottom: 5px;
              ">
                <div class="font-preview" style="
                  font-size: 16px; 
                  font-weight: bold; 
                  color: #fff; 
                  margin-bottom: 2px;
                  font-family: '${font}', sans-serif;
                ">${font}</div>
                <div class="font-sample" style="
                  font-size: 11px; 
                  color: #ccc;
                  font-family: '${font}', sans-serif;
                ">Sample text</div>
              </div>`;
          });
          
          fontOptionsHTML += `</div>`;
        });
        
        fontPopup.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="color: #f4a012; margin: 0; font-size: 16px;">Select Font</h3>
            <button id="font-popup-close" style="background: none; border: none; color: #f4a012; cursor: pointer; font-size: 18px; padding: 0;">√ó</button>
          </div>
          ${fontOptionsHTML}
        `;
        
        // Add to shortcut menu container
        const shortcutMenu = document.getElementById('shortcut-menu');
        if (shortcutMenu) {
          shortcutMenu.appendChild(fontPopup);
        } else {
          document.body.appendChild(fontPopup);
        }
        
        // Add click handlers for font options
        const fontOptions = fontPopup.querySelectorAll('.font-option');
        fontOptions.forEach(option => {
          option.addEventListener('click', function() {
            const selectedFont = this.dataset.font;
            hideFontSelectionMenu();
            addTextToCanvasWithFont(selectedFont);
          });
          
          // Hover effects
          option.addEventListener('mouseenter', function() {
            this.style.borderColor = '#f4a012';
            this.style.background = '#555';
          });
          
          option.addEventListener('mouseleave', function() {
            this.style.borderColor = '#555';
            this.style.background = '#444';
          });
        });
        
        // Close button
        fontPopup.querySelector('#font-popup-close').addEventListener('click', hideFontSelectionMenu);
      }
      
      // Show popup
      fontPopup.style.display = 'block';
    }
    
    function hideFontSelectionMenu() {
      const fontPopup = document.getElementById('font-selection-popup');
      if (fontPopup) {
        fontPopup.style.display = 'none';
      }
    }
    
    function closeFontSelectionMenu() {
      const fontModal = document.getElementById('fontSelectionModal');
      if (fontModal) {
        fontModal.style.display = 'none';
      }
    }
    
    // Add text to canvas with selected font
    function addTextToCanvasWithFont(fontFamily) {
      if (!deskPadModalCanvas) {
        console.error('Modal canvas not initialized');
        return;
      }
      
      // Calculate font size as 60% of canvas width
      const canvasWidth = deskPadModalCanvas.getWidth();
      const defaultFontSize = Math.floor(canvasWidth * 0.6 / 10); // 60% of width, divided by ~10 for reasonable text size
      
      // Create text object with selected font and large size
      const text = new fabric.IText('Double-click to edit', {
        left: deskPadModalCanvas.getWidth() / 2,
        top: deskPadModalCanvas.getHeight() / 2,
        fontFamily: fontFamily,
        fontSize: defaultFontSize,
        fill: '#ffffff',
        stroke: '#000000',
        strokeWidth: 1,
        originX: 'center',
        originY: 'center',
        textBaseline: 'alphabetic', // Fix for CanvasTextBaseline error
        selectable: true,
        evented: true,
        editable: false // We'll handle editing via modal
      });
      
      // Add to canvas
      deskPadModalCanvas.add(text);
      deskPadModalCanvas.setActiveObject(text);
      deskPadModalCanvas.requestRenderAll();
      

    }

    // Initialize shortcut menu functionality
    function initShortcutMenu() {

      
      const shortcutUpload = document.getElementById('shortcut-upload');
      const shortcutRecent = document.getElementById('shortcut-recent');
      const shortcutPadSize = document.getElementById('shortcut-pad-size');
      const shortcutAddText = document.getElementById('shortcut-add-text');
      const recentPopup = document.getElementById('recent-images-popup');
      const recentPopupClose = document.getElementById('recent-popup-close');
      const padSizePopup = document.getElementById('pad-size-popup');
      const padSizePopupClose = document.getElementById('pad-size-popup-close');
      const addTextPopup = document.getElementById('add-text-popup');
      const addTextPopupClose = document.getElementById('add-text-popup-close');
      
      if (shortcutUpload) {
        shortcutUpload.addEventListener('click', function() {

          // Open file dialog directly (same as menu upload button)
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = 'image/*';
          fileInput.multiple = true;
          fileInput.style.display = 'none';
          document.body.appendChild(fileInput);
          
          fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
              handleModalFileUpload(e.target.files);
            }
            document.body.removeChild(fileInput);
          });
          
          fileInput.click();
        });
      }
      
      if (shortcutRecent) {
        shortcutRecent.addEventListener('click', function() {

          const recentPopup = document.getElementById('recent-images-popup');
          
          if (recentPopup && recentPopup.classList.contains('show')) {
            // Popup is open, close it
            hideRecentImagesPopup();
          } else {
            // Popup is closed, open it
            showRecentImagesPopup();
          }
        });
      }
      
      if (recentPopupClose) {
        recentPopupClose.addEventListener('click', function() {

          hideRecentImagesPopup();
        });
      }
      
      if (shortcutPadSize) {
        shortcutPadSize.addEventListener('click', function() {

          const padSizePopup = document.getElementById('pad-size-popup');
          
          if (padSizePopup && padSizePopup.classList.contains('show')) {
            // Popup is open, close it
            hidePadSizePopup();
          } else {
            // Popup is closed, open it
            showPadSizePopup();
          }
        });
      }
      
      if (padSizePopupClose) {
        padSizePopupClose.addEventListener('click', function() {

          hidePadSizePopup();
        });
      }
      
      if (shortcutAddText) {
        shortcutAddText.addEventListener('click', function() {

          // Show font selection menu first
          showFontSelectionMenu();
        });
      }
      
      if (addTextPopupClose) {
        addTextPopupClose.addEventListener('click', function() {

          hideAddTextPopup();
        });
      }
      
      // Close popup when clicking outside
      document.addEventListener('click', function(e) {
        if (recentPopup && recentPopup.classList.contains('show')) {
          if (!recentPopup.contains(e.target) && !shortcutRecent.contains(e.target)) {
            hideRecentImagesPopup();
          }
        }
        if (padSizePopup && padSizePopup.classList.contains('show')) {
          if (!padSizePopup.contains(e.target) && !shortcutPadSize.contains(e.target)) {
            hidePadSizePopup();
          }
        }
        if (addTextPopup && addTextPopup.classList.contains('show')) {
          if (!addTextPopup.contains(e.target) && !shortcutAddText.contains(e.target)) {
            hideAddTextPopup();
          }
        }
        
        // Close font selection popup when clicking outside
        const fontPopup = document.getElementById('font-selection-popup');
        if (fontPopup && fontPopup.style.display === 'block') {
          if (!fontPopup.contains(e.target) && !shortcutAddText.contains(e.target)) {
            hideFontSelectionMenu();
          }
        }
      });

      // Close popup when drag and drop occurs
      document.addEventListener('drop', function(e) {
        if (recentPopup && recentPopup.classList.contains('show')) {
          hideRecentImagesPopup();
        }
        if (padSizePopup && padSizePopup.classList.contains('show')) {
          hidePadSizePopup();
        }
        if (addTextPopup && addTextPopup.classList.contains('show')) {
          hideAddTextPopup();
        }
        
        // Close font selection popup when drag and drop occurs
        const fontPopup = document.getElementById('font-selection-popup');
        if (fontPopup && fontPopup.style.display === 'block') {
          hideFontSelectionMenu();
        }
      });
      

    }

    // Show pad size popup
    function showPadSizePopup() {
      const padSizePopup = document.getElementById('pad-size-popup');
      
      if (padSizePopup) {
        // Update active state
        updatePadSizeActiveState();
        
        // Show popup
        padSizePopup.classList.add('show');
      }
    }

    // Hide pad size popup
    function hidePadSizePopup() {
      const padSizePopup = document.getElementById('pad-size-popup');
      if (padSizePopup) {
        padSizePopup.classList.remove('show');
      }
    }

    // Update active state in pad size popup
    function updatePadSizeActiveState() {
      const padSizeOptions = document.querySelectorAll('.pad-size-option');
      padSizeOptions.forEach(option => {
        option.classList.remove('active');
        if (option.dataset.preset === currentPreset) {
          option.classList.add('active');
        }
      });
    }

    // Setup pad size option event listeners
    function setupPadSizeEventListeners() {
      const padSizeOptions = document.querySelectorAll('.pad-size-option');
      padSizeOptions.forEach(option => {
        option.addEventListener('click', function() {
          const selectedPreset = this.dataset.preset;

          
          // Apply the selected preset
          applyAspectPreset(selectedPreset);
          
          // Close the popup
          hidePadSizePopup();
        });
      });
    }

    // Show add text popup
    function showAddTextPopup() {
      const addTextPopup = document.getElementById('add-text-popup');
      
      if (addTextPopup) {
        // Show popup
        addTextPopup.classList.add('show');
      }
    }

    // Hide add text popup
    function hideAddTextPopup() {
      const addTextPopup = document.getElementById('add-text-popup');
      if (addTextPopup) {
        addTextPopup.classList.remove('show');
      }
    }

    // Setup font option event listeners
    function setupFontEventListeners() {
      const fontOptions = document.querySelectorAll('.font-option');
      fontOptions.forEach(option => {
        option.addEventListener('click', function() {
          const selectedFont = this.dataset.font;

          
          // Add text to canvas with selected font
          addTextToCanvas(selectedFont);
          
          // Close the popup
          hideAddTextPopup();
        });
      });
    }

    // Add text to canvas with specified font
    function addTextToCanvas(fontFamily) {
      if (!deskPadModalCanvas) {
        console.error('Modal canvas not initialized');
        return;
      }
      
      // Create text object with large default size (60% of canvas width)
      const canvasWidth = deskPadModalCanvas.getWidth();
      const defaultFontSize = Math.floor(canvasWidth * 0.6 / 10); // 60% of width, divided by ~10 for reasonable text size
      
      const text = new fabric.IText('Double-click to edit', {
        left: deskPadModalCanvas.getWidth() / 2,
        top: deskPadModalCanvas.getHeight() / 2,
        fontFamily: fontFamily,
        fontSize: defaultFontSize,
        fill: '#ffffff',
        stroke: '#000000',
        strokeWidth: 1,
        originX: 'center',
        originY: 'center',
        textBaseline: 'alphabetic', // Fix for CanvasTextBaseline error
        selectable: true,
        evented: true,
        editable: false // We'll handle editing via modal
      });
      
      // Add to canvas
      deskPadModalCanvas.add(text);
      deskPadModalCanvas.setActiveObject(text);
      deskPadModalCanvas.requestRenderAll();
      

    }

    // Show recent images popup
    function showRecentImagesPopup() {
      const recentPopup = document.getElementById('recent-images-popup');
      const recentPopupGrid = document.getElementById('recent-images-popup-grid');
      
      if (recentPopup && recentPopupGrid) {
        // Populate recent images
        populateRecentImagesPopup();
        
        // Show popup
        recentPopup.classList.add('show');
      }
    }

    // Hide recent images popup
    function hideRecentImagesPopup() {
      const recentPopup = document.getElementById('recent-images-popup');
      if (recentPopup) {
        recentPopup.classList.remove('show');
      }
    }

    // Populate recent images in popup
    function populateRecentImagesPopup() {
      const recentPopupGrid = document.getElementById('recent-images-popup-grid');
      
      if (!recentPopupGrid) return;
      
      // Clear existing content
      recentPopupGrid.innerHTML = '';
      
      // Get recent images (use the existing recentImages array)
      if (recentImages && recentImages.length > 0) {
        recentImages.forEach((imageData, index) => {
          const imageItem = document.createElement('div');
          imageItem.className = 'recent-image-item';
          imageItem.title = imageData.name || `Image ${index + 1}`;
          
          imageItem.innerHTML = `
            <img src="${imageData.url}" alt="${imageData.name || 'Recent image'}" class="recent-image-thumbnail">
            <div class="recent-image-name">${imageData.name || `Image ${index + 1}`}</div>
          `;
          
          // Add click handler to add image to canvas
          imageItem.addEventListener('click', function() {

            addImageToModalCanvas(imageData.url, imageData.name, 0);
            hideRecentImagesPopup();
          });
          
          recentPopupGrid.appendChild(imageItem);
        });
      } else {
        // Show empty state
        const emptyState = document.createElement('div');
        emptyState.style.cssText = 'grid-column: 1 / -1; text-align: center; color: #666; padding: 20px; font-size: 12px;';
        emptyState.textContent = 'No recent images';
        recentPopupGrid.appendChild(emptyState);
      }
    }

    // Auto-snap all images to current canvas edges
    function autoSnapAllImagesToEdges() {
      if (!deskPadModalCanvas) return;
      
      const allObjects = deskPadModalCanvas.getObjects();

      
      allObjects.forEach(obj => {
        if (obj.type === 'image') {

          applySimpleSnapping(obj);
        }
      });
      
      deskPadModalCanvas.requestRenderAll();
    }

    // Update canvas with current DPI-based snapping settings
    function updateAllObjectsSnappingSettings() {
      if (!deskPadModalCanvas) return;
      
      const dpiScale = currentDPI / 100;
      const scaledSnapThreshold = Math.round(30 * dpiScale); // Increased from 15 to 30
      const scaledSnapAngle = Math.round(30 * dpiScale); // Increased from 15 to 30
      
      const objects = deskPadModalCanvas.getObjects();

      
      // Update canvas-level snapping settings (these are the only ones that matter)
      deskPadModalCanvas.set({
        snapAngle: scaledSnapAngle,
        snapThreshold: scaledSnapThreshold,
        snapAngleThreshold: scaledSnapAngle
      });
      
      // Force a render to ensure settings are applied
      deskPadModalCanvas.requestRenderAll();
      

    }

    // Adaptive throttling for snapping - only throttle on very large canvases
    let lastSnapTime = 0;
    
    // Precise snapping that works with Fabric's selection border system
    function applySimpleSnapping(obj) {
      const canvas = deskPadModalCanvas;
      
      // Only throttle on very large canvases (>15M pixels) for better performance
      const totalPixels = canvas.getWidth() * canvas.getHeight();
      
      if (totalPixels > 15000000) { // 15 million pixels
        const now = Date.now();
        if (now - lastSnapTime < 8) { // ~120fps throttling only for large canvases
          return;
        }
        lastSnapTime = now;
      }
      const canvasWidth = canvas.getWidth();
      const canvasHeight = canvas.getHeight();
      
      // Scale snapping threshold with DPI to maintain consistent user experience
      // Base threshold is 25 pixels at 100 DPI, scales proportionally (increased from 10)
      const baseThreshold = 25;
      const dpiScale = currentDPI / 100;
      const snapThreshold = Math.round(baseThreshold * dpiScale);
      
      // Get object dimensions (accounting for scaling)
      const halfW = obj.getScaledWidth() / 2;
      const halfH = obj.getScaledHeight() / 2;
      
      // Calculate object edges (since objects are center-origin)
      const left = obj.left - halfW;
      const top = obj.top - halfH;
      const right = obj.left + halfW;
      const bottom = obj.top + halfH;
      
      let snapped = false;
      
      // Snap left edge to canvas left (pixel-perfect)
      if (Math.abs(left - 0) < snapThreshold) {
        obj.set('left', Math.round(halfW));
        snapped = true;
      }
      
      // Snap right edge to canvas right (pixel-perfect)
      if (Math.abs(right - canvasWidth) < snapThreshold) {
        obj.set('left', Math.round(canvasWidth - halfW));
        snapped = true;
      }
      
      // Snap top edge to canvas top (pixel-perfect)
      if (Math.abs(top - 0) < snapThreshold) {
        obj.set('top', Math.round(halfH));
        snapped = true;
      }
      
      // Snap bottom edge to canvas bottom (pixel-perfect)
      if (Math.abs(bottom - canvasHeight) < snapThreshold) {
        obj.set('top', Math.round(canvasHeight - halfH));
        snapped = true;
      }
      
      // Force integer positioning to avoid sub-pixel rendering
      if (snapped) {
        obj.set({
          left: Math.round(obj.left),
          top: Math.round(obj.top)
        });
        canvas.requestRenderAll();
      }
    }
    
    // Wrapper-based zoom functions (Photoshop-style Ctrl +/-)
    // store the "1√ó" size once, so you can reset or compute relative zooms
    let baseRect = null;
    let currentScale = 1;
    let fitToScreenScale = 1; // Store the scale that fits the canvas to screen

    function resizeCanvasDom(factor) {
      // factor: 1.0 = 100%, 1.2 = 120%, 0.8 = 80%, etc.
      const canvas = deskPadModalCanvas;
      const wrapper = canvas.wrapperEl;
      
      if (!baseRect) {
        baseRect = wrapper.getBoundingClientRect(); // original dimensions
      }
      
      wrapper.style.transformOrigin = 'center center';
      
      // Check if layers menu is open and combine transforms
      const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
      const layersMenuOpen = canvasContainer && canvasContainer.classList.contains('with-layers-menu');
      
      if (layersMenuOpen) {
        // Combine zoom scale with layers menu scale (0.85)
        const combinedScale = factor * 0.85;
        wrapper.style.transform = `scale(${combinedScale})`;
        console.log('Canvas wrapper scaled to:', factor, 'with layers menu scale (0.85) =', combinedScale, 'at', currentDPI, 'DPI');
      } else {
        // Normal zoom only
        wrapper.style.transform = `scale(${factor})`;

      }

      // update your UI with percentage relative to fit-to-screen scale
      const zoomDisplay = document.getElementById('zoom-level');
      if (zoomDisplay) {
        // Calculate percentage relative to fit-to-screen scale
        // When factor = fitToScreenScale, it should show 100%
        const relativePercentage = Math.round((factor / fitToScreenScale) * 100);
        const clampedPercentage = Math.max(10, Math.min(300, relativePercentage)); // Cap at 300%, min 10%
        zoomDisplay.textContent = `${clampedPercentage}%`;
      }
      
      // you do NOT need to call canvas.setZoom or canvas.viewportTransform here
    }

    function canvasZoomIn() {
      currentScale = Math.min(3, currentScale * 1.2); // Cap at 300%
      resizeCanvasDom(currentScale);
    }

    function canvasZoomOut() {
      currentScale = Math.max(0.1, currentScale / 1.2); // Allow much lower zoom (10% of fit-to-screen)
      resizeCanvasDom(currentScale);
    }

    function canvasZoomFit() {
      // Calculate scale to fit canvas in viewport
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight - 60; // Account for toolbar
      const canvasWidth = deskPadModalCanvas.getWidth();
      const canvasHeight = deskPadModalCanvas.getHeight();
      
      // Calculate scale factors to fit in viewport with padding
      const scaleX = (viewportWidth * 0.9) / canvasWidth; // 90% of viewport width
      const scaleY = (viewportHeight * 0.9) / canvasHeight; // 90% of viewport height
      
      // Use the smaller scale to ensure canvas fits completely
      const fitScale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 100%
      
      console.log('Canvas zoom fit calculation:', {
        viewport: { width: viewportWidth, height: viewportHeight },
        canvas: { width: canvasWidth, height: canvasHeight },
        scaleFactors: { scaleX: scaleX.toFixed(3), scaleY: scaleY.toFixed(3) },
        finalScale: fitScale.toFixed(3),
        aspectRatio: (canvasWidth / canvasHeight).toFixed(3)
      });
      
      // Store the fit-to-screen scale for percentage calculations
      fitToScreenScale = fitScale;
      currentScale = fitScale;
      resizeCanvasDom(currentScale);
      

    }
    
    // Function to center all objects in the canvas using the same logic as the align-center button
    function centerAllObjectsInCanvas() {
      if (!deskPadModalCanvas) return;
      
      const canvas = deskPadModalCanvas;
      const canvasWidth = canvas.getWidth();
      const canvasHeight = canvas.getHeight();
      
      const objects = canvas.getObjects().filter(obj => obj.type !== 'rect');
      
      objects.forEach(obj => {
        if (obj.type === 'image' || obj.type === 'text' || obj.type === 'group') {
          // Get object dimensions
          const scaledWidth = obj.getScaledWidth();
          const scaledHeight = obj.getScaledHeight();
          
          // Get object origin points
          const originX = obj.originX || 'left';
          const originY = obj.originY || 'top';
          
          let newLeft, newTop;
          
          // Horizontal centering (same logic as align-center button)
          if (originX === 'center') {
            newLeft = canvasWidth / 2;
          } else if (originX === 'right') {
            newLeft = canvasWidth - scaledWidth / 2;
          } else {
            newLeft = (canvasWidth - scaledWidth) / 2;
          }
          
          // Vertical centering (same logic as align-center button)
          if (originY === 'center') {
            newTop = canvasHeight / 2;
          } else if (originY === 'bottom') {
            newTop = canvasHeight - scaledHeight / 2;
          } else {
            newTop = (canvasHeight - scaledHeight) / 2;
          }
          
          // Set position
          obj.set({ left: newLeft, top: newTop });
          obj.setCoords();
          
          console.log('Centered object using align-center logic:', {
            type: obj.type,
            position: { left: newLeft, top: newTop },
            origin: { x: originX, y: originY },
            canvasSize: { width: canvasWidth, height: canvasHeight }
          });
        }
      });
      
      canvas.requestRenderAll();
    }
    
    // Fabric.js built-in snap settings (keeping for reference)
    function setupCanvasSnapping() {

    }

    // Update canvas size display
    function updateCanvasSizeDisplay(width, height) {
      const widthSpan = document.getElementById('canvas-width');
      const heightSpan = document.getElementById('canvas-height');
      if (widthSpan && heightSpan) {
        widthSpan.textContent = Math.round(width);
        heightSpan.textContent = Math.round(height);
      }
      
      // Also update any size info display
      const sizeInfoElement = document.getElementById('canvas-size-info');
      if (sizeInfoElement) {
        const aspectRatio = width / height;
        const is77to29 = Math.abs(aspectRatio - (77/29)) < 0.01;
        
        sizeInfoElement.innerHTML = `
          <strong>Canvas Size:</strong> ${Math.round(width)} √ó ${Math.round(height)}px<br>
          <strong>Aspect Ratio:</strong> ${aspectRatio.toFixed(3)} ${is77to29 ? '(77:29)' : ''}<br>
          <strong>Size Range:</strong> 1080p to 4K equivalent<br>
          <small>Images will scale to fit but won't upscale if too small</small>
        `;
      }
    }
    
    // Setup canvas resize handles
    function setupCanvasResizeHandles() {
      // Only target resize handles that are specifically for canvas resizing
      // Use a more specific selector to avoid conflicts with crop modal handles
      const handles = document.querySelectorAll('.canvas-resize-handle');
      handles.forEach(handle => {
        handle.addEventListener('mousedown', startResize);
      });
    }
    
    // Start resize operation
    function startResize(e) {
      // Check if we're in the crop modal context - if so, don't interfere
      if (e.target.closest('#crop-modal-cropbox') || e.target.closest('#crop-modal')) {
        return; // Let the crop modal handle its own resize
      }
      
      e.preventDefault();
      e.stopPropagation();
      
      const direction = e.target.dataset.direction;
      const startX = e.clientX;
      const startY = e.clientY;
      const startWidth = deskPadModalCanvas.getWidth();
      const startHeight = deskPadModalCanvas.getHeight();
      const aspectRatio = 77 / 29;
      

      
      function onMouseMove(e) {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        let newWidth = startWidth;
        let newHeight = startHeight;
        
        // Check if direction is defined before using it
        if (direction) {
          // Calculate new dimensions based on direction while maintaining aspect ratio
          if (direction.includes('e')) {
            newWidth = startWidth + deltaX;
          }
          if (direction.includes('w')) {
            newWidth = startWidth - deltaX;
          }
          if (direction.includes('s')) {
            newHeight = startHeight + deltaY;
          }
          if (direction.includes('n')) {
            newHeight = startHeight - deltaY;
          }
        } else {
          // Fallback: resize based on mouse movement without direction constraints
          newWidth = startWidth + deltaX;
          newHeight = startHeight + deltaY;
        }
        
        // Maintain aspect ratio
        if (direction && (direction.includes('e') || direction.includes('w'))) {
          newHeight = newWidth / aspectRatio;
        } else if (direction && (direction.includes('s') || direction.includes('n'))) {
          newWidth = newHeight * aspectRatio;
        } else {
          // For fallback case, maintain aspect ratio based on which dimension changed more
          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            newHeight = newWidth / aspectRatio;
          } else {
            newWidth = newHeight * aspectRatio;
          }
        }
        
        // Apply minimum and maximum constraints
        // Minimum: 1080p equivalent (1920x1080 scaled to 77:29 ratio)
        // Maximum: 4K equivalent (3840x2160 scaled to 77:29 ratio)
        const minWidth = 960; // Reasonable minimum for display
        const maxWidth = 2560; // Reasonable maximum for display
        const minHeight = Math.round(minWidth / aspectRatio); // ‚âà 361px
        const maxHeight = Math.round(maxWidth / aspectRatio); // ‚âà 964px
        
        newWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
        newHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));
        
        // Recalculate to maintain aspect ratio after constraints
        if (newWidth / newHeight > aspectRatio) {
          newHeight = newWidth / aspectRatio;
        } else {
          newWidth = newHeight * aspectRatio;
        }
        
        // Update canvas dimensions
        deskPadModalCanvas.setDimensions({
          width: newWidth,
          height: newHeight
        });
        
        // Update stored dimensions
        modalArtboardWidth = newWidth;
        modalArtboardHeight = newHeight;
        modalCanvasWidth = newWidth;
        modalCanvasHeight = newHeight;
        
        // Border rectangle removed - no longer updating during resize
        
                  // Update size display
          updateCanvasSizeDisplay(newWidth, newHeight);
          
          // Log the size constraints for debugging
          console.log('Canvas resize constraints:', {
            minWidth: 1920, // 1080p equivalent
            maxWidth: 3840, // 4K equivalent
            minHeight: Math.round(1920 / aspectRatio),
            maxHeight: Math.round(3840 / aspectRatio),
            currentWidth: newWidth,
            currentHeight: newHeight,
            aspectRatio: aspectRatio
          });
        
        // Re-render canvas
        deskPadModalCanvas.requestRenderAll();
        
        // Center objects after manual resize
        centerAllObjectsInCanvas();
      }
      
      function onMouseUp() {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        
        // Auto-snap all images to new canvas edges after manual resize
        autoSnapAllImagesToEdges();

      }
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    }
    
    // Fit canvas to viewport using wrapper scaling
    function fitCanvasToViewport() {
      if (!deskPadModalCanvas) return;
      
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight - 60;
      const canvasWidth = deskPadModalCanvas.getWidth();
      const canvasHeight = deskPadModalCanvas.getHeight();
      
      // Calculate zoom to fit canvas in viewport with padding
      const scaleX = (viewportWidth * 0.8) / canvasWidth;
      const scaleY = (viewportHeight * 0.8) / canvasHeight;
      const scale = Math.min(scaleX, scaleY, 1); // Don't zoom in beyond 100%
      
      // Use wrapper scaling instead of Fabric viewport zoom
      currentScale = scale;
      resizeCanvasDom(scale);
    }

    // Setup zoom and pan functionality for any canvas
    // This function provides Photoshop-style viewport zoom and pan for any Fabric.js canvas
    // Parameters:
    // - canvas: The Fabric.js canvas instance to add zoom/pan to
    function setupCanvasZoomAndPan(canvas) {
      if (!canvas) return;
      
      let isPanning = false;
      let lastPosX = 0;
      let lastPosY = 0;
      

      

      
      // Keyboard shortcuts (only for modal canvas to avoid conflicts)
      if (canvas === deskPadModalCanvas) {
        document.addEventListener('keydown', function(e) {
          if (!canvas) return;
          
          switch(e.key) {
            case '=':
            case '+':
              e.preventDefault();
              canvasZoomIn();
              break;
            case '-':
              e.preventDefault();
              canvasZoomOut();
              break;
            case '0':
              e.preventDefault();
              canvasZoomFit();
              break;
          }
        });
      }
      

      
      // Ensure canvas is always ready for object interaction
      canvas.selection = true;
      canvas.preserveObjectStacking = true;
      
      // Add zoom button event listeners (only for modal canvas)
      if (canvas === deskPadModalCanvas) {
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomFitBtn = document.getElementById('zoom-fit-btn');
        const zoomLevelSpan = document.getElementById('zoom-level');
        
        if (zoomInBtn) {
          zoomInBtn.addEventListener('click', function() {
            canvasZoomIn();
          });
        }
        
        if (zoomOutBtn) {
          zoomOutBtn.addEventListener('click', function() {
            canvasZoomOut();
          });
        }
        
        if (zoomFitBtn) {
          zoomFitBtn.addEventListener('click', function() {
            canvasZoomFit();
          });
        }
        
        // Zoom controls initialized successfully

      }
      
      // Test zoom functionality
      console.log('Initial zoom test - canvas zoom level:', canvas.getZoom());

      
      // Add zoom status check function for debugging
      window.checkZoomStatus = function() {
        const zoom = canvas.getZoom();
        const zoomPercentage = Math.round(zoom * 100);
        
        console.log('Zoom status check:', {
          canvas: !!canvas,
          zoom: zoom,
          zoomPercentage: zoomPercentage + '%',
          viewportTransform: canvas.viewportTransform
        });
      };
      

      

      



      

    }

    // Center view on safe area - let Flexbox handle centering
    function centerViewOnSafeArea() {
      if (!deskPadModalCanvas) return;
      
      // Reset zoom to 1
      deskPadModalCanvas.setZoom(1);
      deskPadModalCanvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
      
      // Reset CSS scaling
      const wrapper = deskPadModalCanvas.wrapperEl;
      wrapper.style.transformOrigin = 'center center';
      wrapper.style.transform = 'scale(1)';
      
      deskPadModalCanvas.requestRenderAll();
      

    }

    // Placeholder for snap-to-safe-area
    function setupSnapToSafeArea() {
      // TODO: Implement snapping logic for objects to stay within the safe area
    }
    
    // Canvas view is now fixed - no dynamic updates needed
    // Removed updateCanvasView function
    

    

    


    // Canvas boundary is now handled by the wrapper approach with CSS


    // Window resize no longer affects canvas size - canvas is fixed
    // Removed resize event listener to prevent dynamic sizing
    
    // Add keyboard support for deleting objects in modal canvas
    window.addEventListener('keydown', function(e) {
      if (e.key === 'Delete' || e.key === 'Backspace') {
        // Check if modal canvas is active
        if (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex') {
          const activeObject = deskPadModalCanvas.getActiveObject();
          if (activeObject) {
            deskPadModalCanvas.remove(activeObject);
            deskPadModalCanvas.requestRenderAll();

            
            // Check if canvas is empty and reset auto-detection if needed
            if (deskPadModalCanvas.getObjects().length === 0) {

              modalAutoDetectionPerformed = false;
              modalTargetCanvasWidth = 4305;
              modalTargetCanvasHeight = 1620;
              
              // Reset DPI display
              modalDpiDisplay.innerHTML = 'No image selected';
              modalDpiDisplay.classList.remove('show');
              

            }
          }
        }
      }
      
      // Toggle background pattern with 'P' key
      if (e.key === 'p' || e.key === 'P') {
        if (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex') {
          const container = document.getElementById('desk-pad-modal-canvas-container');
          container.classList.toggle('no-pattern');

        }
      }
      
      // Toggle border visibility with 'B' key
      if (e.key === 'b' || e.key === 'B') {
        if (deskPadModalCanvas && deskPadModalOverlay.style.display === 'flex' && deskPadModalCanvas.borderRect) {
          deskPadModalCanvas.borderRect.visible = !deskPadModalCanvas.borderRect.visible;
          deskPadModalCanvas.requestRenderAll();

        }
      }
    });
    


    let smokeOverlay = document.getElementById('smoke-overlay');
    
    // Create smoke particles
    function createSmokeParticles(centerX, centerY, count = 50) {
      const particles = [];
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'smoke-particle';
        // Random direction and distance
        const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
        const distance = 300 + Math.random() * 200;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        // Position at center
        particle.style.left = centerX + 'px';
        particle.style.top = centerY + 'px';
        particle.style.setProperty('--dx', dx + 'px');
        particle.style.setProperty('--dy', dy + 'px');
        smokeOverlay.appendChild(particle);
        particles.push(particle);
      }
      return particles;
    }
    
    // Open desk pad modal with smoke animation
    deskPadButton.addEventListener('click', function() {

      
      const buttonRect = deskPadButton.getBoundingClientRect();
      const centerX = buttonRect.left + buttonRect.width / 2;
      const centerY = buttonRect.top + buttonRect.height / 2;
      
      smokeOverlay.classList.add('show');
      const particles = createSmokeParticles(centerX, centerY, 60);
      
      setTimeout(() => { 
        particles.forEach(p => p.classList.add('expanding')); 
      }, 50);
      
      setTimeout(() => {

        deskPadModalOverlay.style.display = 'flex';
        deskPadModalOverlay.classList.add('show');
        document.body.classList.add('modal-open');
        
        // Canvas boundary is now handled by the wrapper approach
        
        // Turn off background pattern by default
        const container = document.getElementById('desk-pad-modal-canvas-container');
        container.classList.add('no-pattern');
        

        initResizableDeskPadModalCanvas();
        initShortcutMenu();
        setupPadSizeEventListeners();
        setupFontEventListeners();
        
        setTimeout(() => { 
          smokeOverlay.classList.remove('show'); 
          particles.forEach(p => p.remove()); 
        }, 300);
      }, 800);
    });
    
    // Preview button functionality
    let deskPadPreviewBtn = document.getElementById('desk-pad-preview-btn');
    
    deskPadPreviewBtn.addEventListener('click', function() {

      generatePreview();
    });
    
    // Close desk pad modal with smoke animation
    deskPadFinishedBtn.addEventListener('click', function() {
      // Don't copy objects back to main canvas - keep modal independent
      
      // Create preview image for button
      if (deskPadModalCanvas) {
        const previewDataUrl = deskPadModalCanvas.toDataURL({ 
          format: 'png', 
          quality: 0.8, 
          multiplier: 0.3 
        });
        buttonPreview.style.backgroundImage = `url(${previewDataUrl})`;
        buttonPreview.classList.add('show');
      }
      
      const buttonRect = deskPadButton.getBoundingClientRect();
      const centerX = buttonRect.left + buttonRect.width / 2;
      const centerY = buttonRect.top + buttonRect.height / 2;
      
      // Start smoke animation while modal is still visible
      smokeOverlay.classList.add('show');
      const particles = createSmokeParticles(centerX, centerY, 60);
      setTimeout(() => { particles.forEach(p => p.classList.add('contracting')); }, 50);

              // Hide modal only after smoke animation is done
        setTimeout(() => {
          deskPadModalOverlay.classList.remove('show');
          deskPadModalOverlay.style.display = 'none';
          document.body.classList.remove('modal-open');
          
          // Canvas boundary is now handled by the wrapper approach
          
          smokeOverlay.classList.remove('show');
          particles.forEach(p => p.remove());
          
          // Reset modal canvas to default for next session
          resetModalCanvasToDefault();
        }, 800);
    });

    // Add Image Modal Functions
    function openAddImageModal() {



      
      if (!addImageModal) {
        console.error('addImageModal is null!');
        return;
      }
      
      if (!deskPadModalCanvasContainer) {
        console.error('deskPadModalCanvasContainer is null!');
        return;
      }
      
      updateRecentImages();
      addImageModal.classList.add('show');
      deskPadModalCanvasContainer.classList.add('shifted');

    }
    
    function closeAddImageModal() {

      addImageModal.classList.remove('show');
      deskPadModalCanvasContainer.classList.remove('shifted');
    }
    
    function updateRecentImages() {

      
      // Clear current grid
      recentImagesGrid.innerHTML = '';
      
      if (sessionImages.length === 0) {
        recentImagesGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">No images used yet</div>';
        return;
      }
      
      // Add recent images to grid (show most recent first)
      sessionImages.slice().reverse().forEach((imageData, index) => {
        const imageItem = document.createElement('div');
        imageItem.className = 'recent-image-item';
        imageItem.title = `Recent image ${index + 1}`;
        
        const img = document.createElement('img');
        // Create a thumbnail version for the grid
        const tempImg = new Image();
        tempImg.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 120; // Increased from 80
          canvas.height = 120; // Increased from 80
          
          // Enable image smoothing for better quality
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          // Draw the image centered and scaled to fit
          const scale = Math.min(120 / tempImg.width, 120 / tempImg.height);
          const scaledWidth = tempImg.width * scale;
          const scaledHeight = tempImg.height * scale;
          const x = (120 - scaledWidth) / 2;
          const y = (120 - scaledHeight) / 2;
          
          ctx.drawImage(tempImg, x, y, scaledWidth, scaledHeight);
          img.src = canvas.toDataURL('image/png', 1.0); // PNG with full quality
        };
        tempImg.src = imageData;
        img.alt = `Recent image ${index + 1}`;
        
        imageItem.appendChild(img);
        
        // Add click handler to add this image to modal canvas
        imageItem.addEventListener('click', () => {
          // Show loading overlay for recent image selection
          loadingOverlay.classList.add('show');
          const loadingText = document.getElementById('loading-text');
          loadingText.textContent = 'Adding recent image to modal canvas...';
          
          addImageToModalCanvas(imageData);
          closeAddImageModal();
          
          // Hide loading overlay after a short delay
          setTimeout(() => {
            loadingOverlay.classList.remove('show');
          }, 500);
        });
        
        recentImagesGrid.appendChild(imageItem);
      });
    }
    
    function addImageToModalCanvas(imageDataUrl, imageName = null, index = 0) {
      if (!deskPadModalCanvas) {
        console.error('Modal canvas not initialized');
        return;
      }
      

      
      // Check if image already exists in recent images
      const existingIndex = recentImages.findIndex(img => img.url === imageDataUrl);
      let imageData;
      
      if (existingIndex !== -1) {
        // Image already exists, move it to the front (most recent)
        imageData = recentImages.splice(existingIndex, 1)[0];
        recentImages.unshift(imageData);

      } else {
        // Add new image to recent images array
        imageData = {
          url: imageDataUrl,
          name: imageName || `Image ${recentImages.length + 1}`,
          timestamp: Date.now()
        };
        
        // Add to beginning of array (most recent first)
        recentImages.unshift(imageData);
        
        // Keep only the last 20 images
        if (recentImages.length > 20) {
          recentImages = recentImages.slice(0, 20);
        }
        

      }
      

      
      fabric.Image.fromURL(imageDataUrl, (img) => {


        
        // Auto-detect DPI for first image BEFORE adjusting canvas area
        if (index === 0 && !modalAutoDetectionPerformed) {

          // Auto-detect appropriate DPI based on image resolution
          const suggestedDPI = autoDetectDPI(img.width, img.height);

          if (suggestedDPI > currentDPI) {
            // User chose a lower DPI than recommended (image is high-res)
            showQualityWarning(
              `Your image is high-res! You could use a higher DPI (e.g. ${suggestedDPI}) for sharper print quality.`,
              img.width, img.height
            );
          } else if (suggestedDPI < currentDPI) {
            // User chose a higher DPI than recommended (image is low-res)
            showQualityWarning(
              `Your image is low-res for ${currentDPI} DPI. Print export may look blurry. Recommended: ${suggestedDPI} DPI or use a higher-res image.`,
              img.width, img.height
            );
          }
          // Never override user DPI choice, just warn
          modalAutoDetectionPerformed = true;
        }
        
        // Set up canvas area based on first image (but keep artboard stable)
        if (!modalAutoDetectionPerformed) {
          // Keep the artboard dimensions stable - don't change them
          // Only adjust the canvas area (77:29 output area) based on the image
          
          // Calculate optimal canvas size for this image while maintaining 77:29 ratio
          const aspectRatio = 77 / 29;
          const imageAspectRatio = img.width / img.height;
          
          let optimalCanvasWidth, optimalCanvasHeight;
          
          if (imageAspectRatio > aspectRatio) {
            // Image is wider than 77:29 - fit by height
            optimalCanvasHeight = Math.min(modalCanvasHeight, img.height);
            optimalCanvasWidth = optimalCanvasHeight * aspectRatio;
          } else {
            // Image is taller than 77:29 - fit by width
            optimalCanvasWidth = Math.min(modalCanvasWidth, img.width);
            optimalCanvasHeight = optimalCanvasWidth / aspectRatio;
          }
          
          // Update only the canvas area dimensions, not the artboard
          modalCanvasWidth = optimalCanvasWidth;
          modalCanvasHeight = optimalCanvasHeight;
          
          console.log('Modal canvas area adjusted for first image:', {
            original: { width: img.width, height: img.height },
            artboard: { width: modalArtboardWidth, height: modalArtboardHeight },
            canvas: { width: modalCanvasWidth, height: modalCanvasHeight }
          });
          
          // Canvas boundary is now handled by the wrapper approach
          
          modalAutoDetectionPerformed = true;
          


          
          // Show canvas area info
          modalDpiDisplay.innerHTML = `
            <strong>Canvas Area Adjusted:</strong><br>
            Artboard: ${modalArtboardWidth} √ó ${modalArtboardHeight}px (stable)<br>
            Canvas area: ${modalCanvasWidth} √ó ${modalCanvasHeight}px (77:29)<br>
            Orange border shows final output area<br>
            Images outside border won't appear in final output
          `;
          
          // Add image immediately (no need to wait for resize)
          addImageToModalCanvasInternal(img, index);
          return;
        }
        
        // If not first image, add directly
        addImageToModalCanvasInternal(img, index);
      }, { crossOrigin: 'anonymous' });
    }

    function addImageToModalCanvasInternal(img, index = 0) {
      // Use safe area dimensions for positioning (canvas is now safe area size)
      const safeAreaWidth = deskPadModalCanvas.getWidth();
      const safeAreaHeight = deskPadModalCanvas.getHeight();

      
      // Smart image scaling that preserves quality
      const canvasWidth = safeAreaWidth;
      const canvasHeight = safeAreaHeight;
      const imageWidth = img.width;
      const imageHeight = img.height;
      
      // Calculate optimal scale using smart scaling function
      const scaling = calculateOptimalImageScale(imageWidth, imageHeight, canvasWidth, canvasHeight);
      let scale = scaling.scale;
      
      // Quality warning for poor scaling
      if (scaling.quality.includes('poor') || scaling.quality.includes('upscaled')) {
        console.warn(`‚ö†Ô∏è Image quality warning: ${scaling.quality}`);
        console.warn(`üí° Consider using a higher resolution image for better quality`);
      }
      
      console.log('Smart image scaling:', {
        imageSize: `${imageWidth}x${imageHeight}`,
        canvasSize: `${canvasWidth}x${canvasHeight}`,
        finalScale: scale.toFixed(3),
        quality: scaling.quality,
        finalSize: `${scaling.finalWidth}x${scaling.finalHeight}`
      });
      
      let left, top;
      if (index === 0) {
        // First image goes to center of the safe area
        left = safeAreaWidth / 2;
        top = safeAreaHeight / 2;
      } else {
        // Subsequent images also go to center of safe area (stacked)
        // Add a small offset to prevent perfect overlap
        const offset = 20; // pixels between images
        left = (safeAreaWidth / 2) + (index * offset);
        top = (safeAreaHeight / 2) + (index * offset);
      }
      
      img.set({
        left: left,
        top: top,
        originX: 'center',
        originY: 'center',
        scaleX: scale,
        scaleY: scale,
        selectable: true,
        hasControls: true,
        hasBorders: true,
        evented: true,
        lockMovementX: false,
        lockMovementY: false,
        lockRotation: false,
        lockScalingX: false,
        lockScalingY: false,
        // Custom control colors for better visibility
        transparentCorners: false,
        cornerColor: '#2c3e50',
        cornerStrokeColor: '#ffffff',
        cornerSize: fabric.Object.prototype.cornerSize,
        cornerStrokeWidth: fabric.Object.prototype.cornerStrokeWidth,
        cornerStyle: 'circle',
        borderColor: '#2c3e50',
        borderScaleFactor: fabric.Object.prototype.borderScaleFactor,
        stroke: 'transparent',
        strokeWidth: 0
      });
      

      


      
      // Update DPI display for this image (but don't auto-show)
      updateModalDPIDisplay(img.width, img.height, modalCanvasWidth, modalCanvasHeight, scale);
      
      // Show quality warning if image is being upscaled
      if (scaling.quality.includes('poor') || scaling.quality.includes('upscaled')) {
        showQualityWarning(scaling.quality, imageWidth, imageHeight);
      }
      
      deskPadModalCanvas.add(img);
      deskPadModalCanvas.setActiveObject(img); // Select the new image
      
      // Create a layer for this image
      const imageName = img.name || `Image ${layers.length + 1}`;
      const layer = createLayer(imageName, 'Image', img);
      
      // Ensure new image has current DPI-based snapping settings
      updateAllObjectsSnappingSettings();
      
      // Ensure the image is fully interactive
      img.selectable = true;
      img.evented = true;
      img.hasControls = true;
      img.hasBorders = true;
      
      // Ensure canvas is in the correct state for interaction
      deskPadModalCanvas.selection = true;
      deskPadModalCanvas.preserveObjectStacking = true;
      
      // Debug: Check canvas interaction state
      console.log('Canvas interaction state:', {
        selection: deskPadModalCanvas.selection,
        skipTargetFind: deskPadModalCanvas.skipTargetFind,
        preserveObjectStacking: deskPadModalCanvas.preserveObjectStacking,
        imageSelectable: img.selectable,
        imageEvented: img.evented,
        imageHasControls: img.hasControls,
        imageHasBorders: img.hasBorders
      });
      
      deskPadModalCanvas.requestRenderAll();
      
      // Debug: Check if image is visible

      console.log('Canvas objects count:', deskPadModalCanvas.getObjects().length);
      console.log('Active object:', deskPadModalCanvas.getActiveObject());

      
      // Force a render and check if image is in the right place
      setTimeout(() => {
        const objects = deskPadModalCanvas.getObjects();
        if (objects.length > 0) {
          const lastObject = objects[objects.length - 1];
          console.log('Last object on canvas:', {
            type: lastObject.type,
            left: lastObject.left,
            top: lastObject.top,
            width: lastObject.width,
            height: lastObject.height,
            scaleX: lastObject.scaleX,
            scaleY: lastObject.scaleY,
            visible: lastObject.visible
          });
        }
      }, 100);
      
      // Add to session images for recent images grid
      const imageDataUrl = img.toDataURL();
      if (!sessionImages.includes(imageDataUrl)) {
        sessionImages.push(imageDataUrl);

      }
      

      
      // Track image processing completion for loading overlay
      // This will be called by the upload functions to signal when all images are done
      if (window.modalImageProcessingComplete) {
        window.modalImageProcessingComplete();
      }
    }
    
    function handleModalFileUpload(files) {

      
      // Debug loading overlay




      
      // Show loading overlay for modal file upload
      loadingOverlay.classList.add('show');

      console.log('Loading overlay opacity after show:', getComputedStyle(loadingOverlay).opacity);
      
      const loadingText = document.getElementById('loading-text');
      loadingText.textContent = `Processing ${files.length} image${files.length > 1 ? 's' : ''} for modal canvas...`;
      
      // Process each image file
      let processedCount = 0;
      const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
      
      if (imageFiles.length === 0) {
        alert('Please select at least one image file.');
        loadingOverlay.classList.remove('show');
        return;
      }
      
      // Set up completion callback for loading overlay
      window.modalImageProcessingComplete = () => {
        processedCount++;
        
        // Update loading text
        loadingText.textContent = `Processing modal image ${processedCount} of ${imageFiles.length}...`;
        
        // Hide loading overlay when all images are processed
        if (processedCount === imageFiles.length) {
          // Use a longer delay for high-resolution images to ensure all processing is complete
          const delay = 1000; // Longer delay to ensure all processing is complete
          
          setTimeout(() => {
            if (loadingOverlay.classList.contains('show')) {

              loadingOverlay.classList.remove('show');
            }
            // Clean up the callback
            window.modalImageProcessingComplete = null;
          }, delay);
        }
      };
      
      imageFiles.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          addImageToModalCanvas(e.target.result, file.name, index);
        };
        reader.readAsDataURL(file);
      });
    }
    
    // Add Image Modal Event Listeners - moved to DOMContentLoaded
    function setupModalEventListeners() {
      
      if (deskPadMenuBtn) {
        deskPadMenuBtn.addEventListener('click', (e) => {

          
          // Check if modal is already open
          if (addImageModal && addImageModal.classList.contains('show')) {
            // Modal is open, so close it
            closeAddImageModal();
          } else {
            // Modal is closed, so open it
            openAddImageModal();
          }
        });

      } else {
        console.error('deskPadMenuBtn is null!');
      }
      
      if (addImageClose) {
        addImageClose.addEventListener('click', closeAddImageModal);

      } else {
        console.error('addImageClose is null!');
      }
      

      
      // Menu item event listeners
      if (menuAddImage) {
        menuAddImage.addEventListener('click', () => {
          // Open file dialog directly
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = 'image/*';
          fileInput.multiple = true;
          fileInput.style.display = 'none';
          document.body.appendChild(fileInput);
          
          fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
              handleModalFileUpload(e.target.files);
              closeAddImageModal();
            }
            document.body.removeChild(fileInput);
          });
          
          fileInput.click();
        });

      } else {
        console.error('menuAddImage is null!');
      }
      
      if (menuRecentImages) {
        menuRecentImages.addEventListener('click', () => {
          // This could expand the recent images section or show a larger view

        });

      } else {
        console.error('menuRecentImages is null!');
      }
      
      // DPI selection event listeners
      const dpiOptions = document.querySelectorAll('.dpi-option');
      dpiOptions.forEach(option => {
        option.addEventListener('click', () => {
          const dpi = parseInt(option.dataset.dpi);
          const width = parseInt(option.dataset.width);
          const height = parseInt(option.dataset.height);
          
          // Check if DPI is locked and this is a different option
          if (dpiLocked && dpi !== currentDPI) {
            showDPIChangeWarning(() => {
              // User confirmed - unlock and change DPI
              unlockDPIOptions();
              
              // Update active state
              dpiOptions.forEach(opt => opt.classList.remove('active'));
              option.classList.add('active');
              
              // Update canvas resolution
              updateCanvasResolution(dpi, width, height);
            });
          } else {
            // Normal DPI change (not locked or same DPI)
            // Update active state
            dpiOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');
            
            // Update canvas resolution
            updateCanvasResolution(dpi, width, height);
            
            // Lock DPI options after manual selection
            lockDPIOptions(dpi);
          }
        });
      });

      
      // Canvas size selection event listener
      const canvasSizeSelect = document.getElementById('canvasSizeSelect');
      if (canvasSizeSelect) {
        canvasSizeSelect.addEventListener('change', function(e) {
          const selectedPreset = e.target.value;

          applyAspectPreset(selectedPreset);
        });
  
      } else {
        console.error('canvasSizeSelect is null!');
      }
      
      // DPI submenu toggle functionality
      const dpiSectionToggle = document.querySelector('.dpi-section-toggle');
      const dpiSubmenu = document.querySelector('.dpi-submenu');
      const dpiToggleIcon = document.querySelector('.dpi-toggle-icon');
      
      if (dpiSectionToggle && dpiSubmenu && dpiToggleIcon) {
        dpiSectionToggle.addEventListener('click', () => {
          const isVisible = dpiSubmenu.style.display !== 'none';
          
          if (isVisible) {
            // Hide submenu
            dpiSubmenu.style.display = 'none';
            dpiToggleIcon.style.transform = 'rotate(0deg)';
          } else {
            // Show submenu
            dpiSubmenu.style.display = 'block';
            dpiToggleIcon.style.transform = 'rotate(180deg)';
          }
        });
  
      }
      
      // Close panel with Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && addImageModal && addImageModal.classList.contains('show')) {
          closeAddImageModal();
        }
      });

    }
    
    // Call setup function when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupModalEventListeners);
    } else {
      setupModalEventListeners();
    }
    
    // Modal Canvas Drag and Drop Support
    deskPadModalCanvasContainer.addEventListener('dragover', e => {
      e.preventDefault();
      e.stopPropagation();
      modalDropOverlay.style.display = 'flex';
    });
    
    deskPadModalCanvasContainer.addEventListener('dragleave', e => {
      e.preventDefault();
      e.stopPropagation();
      modalDropOverlay.style.display = 'none';
    });
    
    deskPadModalCanvasContainer.addEventListener('drop', e => {
      e.preventDefault();
      e.stopPropagation();
      modalDropOverlay.style.display = 'none';
      
      const files = Array.from(e.dataTransfer.files);
      const imageFiles = files.filter(file => file.type.startsWith('image/'));
      
      if (imageFiles.length === 0) {
        alert('Please drop at least one image file.');
        return;
      }
      

      
      // Close recent images popup if it's open
      const recentPopup = document.getElementById('recent-images-popup');
      if (recentPopup && recentPopup.classList.contains('show')) {
        hideRecentImagesPopup();
      }
      
      // Show loading overlay for modal drag and drop



      
      loadingOverlay.classList.add('show');

      console.log('Drag drop - Loading overlay opacity after show:', getComputedStyle(loadingOverlay).opacity);
      
      const loadingText = document.getElementById('loading-text');
      loadingText.textContent = `Processing ${imageFiles.length} dropped image${imageFiles.length > 1 ? 's' : ''} for modal canvas...`;
      
      // Process each image file
      let processedCount = 0;
      
      // Set up completion callback for loading overlay
      window.modalImageProcessingComplete = () => {
        processedCount++;
        
        // Update loading text
        loadingText.textContent = `Processing dropped modal image ${processedCount} of ${imageFiles.length}...`;
        
        // Hide loading overlay when all images are processed
        if (processedCount === imageFiles.length) {
          // Use a longer delay for high-resolution images to ensure all processing is complete
          const delay = 1000; // Longer delay to ensure all processing is complete
          
          setTimeout(() => {
            if (loadingOverlay.classList.contains('show')) {

              loadingOverlay.classList.remove('show');
            }
            // Clean up the callback
            window.modalImageProcessingComplete = null;
          }, delay);
        }
      };
      
      imageFiles.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = ev => {
          addImageToModalCanvas(ev.target.result, file.name, index);
        };
        reader.readAsDataURL(file);
      });
    });

    function resetModalCanvasToDefault() {
      if (!deskPadModalCanvas) return;
      
      // Show loading overlay for modal canvas reset
      loadingOverlay.classList.add('show');
      const loadingText = document.getElementById('loading-text');
      loadingText.textContent = 'Resetting modal canvas...';
      
      // Clean up all properties buttons
      const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
      const propertiesButtons = canvasContainer.querySelectorAll('.image-properties-btn');
      propertiesButtons.forEach(btn => btn.remove());
      
      // Reset modal canvas to default size (responsive to container)
      const container = document.getElementById('desk-pad-modal-canvas-container');
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      
      // Calculate artboard size using 95% of container space
      const maxArtboardWidth = containerWidth * 0.95;
      const maxArtboardHeight = containerHeight * 0.95;
      
      // Canvas is 77:29 aspect ratio, sized to fill 85% of artboard area
      const aspectRatio = 77 / 29;
      
      // Calculate canvas size to fill 85% of artboard while maintaining 77:29 ratio
      let canvasWidth, canvasHeight;
      
      // Try fitting by width first (most common case)
      canvasWidth = maxArtboardWidth * 0.85;
      canvasHeight = canvasWidth / aspectRatio;
      
      // If height exceeds artboard, fit by height instead
      if (canvasHeight > maxArtboardHeight * 0.85) {
        canvasHeight = maxArtboardHeight * 0.85;
        canvasWidth = canvasHeight * aspectRatio;
      }
      
      // Artboard uses the calculated maximum size
      const artboardWidth = maxArtboardWidth;
      const artboardHeight = maxArtboardHeight;
      
      // Resize modal canvas back to default
      deskPadModalCanvas.setDimensions({
        width: artboardWidth,
        height: artboardHeight
      });
      
      // Update stored dimensions
      modalArtboardWidth = artboardWidth;
      modalArtboardHeight = artboardHeight;
      modalCanvasWidth = canvasWidth;
      modalCanvasHeight = canvasHeight;
      
      // Canvas view is now fixed - no dynamic updates needed
      
      // Reset auto-detection flag
      modalAutoDetectionPerformed = false;
      
      // Reset DPI display
      modalDpiDisplay.innerHTML = 'No image selected';
      modalDpiDisplay.classList.remove('show');
      
      // Unlock DPI options when canvas is reset
      unlockDPIOptions();
      
      // Reset the current DPI display
      const currentDpiDisplay = document.getElementById('current-dpi-display');
      if (currentDpiDisplay) {
        const exportWidth = Math.round(2900 * (EXPORT_DPI / 100));
        const exportHeight = Math.round(1093 * (EXPORT_DPI / 100));
        currentDpiDisplay.textContent = `100 DPI ‚Ä¢ 2900 √ó 1093px (Export: ${exportWidth} √ó ${exportHeight}px @ ${EXPORT_DPI} DPI)`;
      }
      
      // Reset handle sizes to default (100 DPI)
      updateHandleSizes(100);
      



      
      // Hide loading overlay after a short delay
      setTimeout(() => {
        loadingOverlay.classList.remove('show');
      }, 300);
    }

    // Set global default for all images to have no stroke
    fabric.Image.prototype.stroke = 'transparent';
    fabric.Image.prototype.strokeWidth = 0;

    // Function to show quality warning for upscaled images
    function showQualityWarning(quality, originalWidth, originalHeight) {
      const warningDiv = document.createElement('div');
      warningDiv.className = 'quality-warning';
      warningDiv.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 1001;
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        max-width: 300px;
        animation: slideInRight 0.3s ease;
      `;
      
      warningDiv.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 8px;">
          <span style="font-size: 18px; margin-right: 8px;">‚ö†Ô∏è</span>
          <strong>Image Quality Warning</strong>
        </div>
        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 8px;">
          ${quality}
        </div>
        <div style="font-size: 11px; opacity: 0.8;">
          Original: ${originalWidth} √ó ${originalHeight}px
        </div>
        <div style="font-size: 11px; opacity: 0.8; margin-top: 4px;">
          üí° Use a higher resolution image for better quality
        </div>
      `;
      
      // Add close button
      const closeBtn = document.createElement('button');
      closeBtn.textContent = '√ó';
      closeBtn.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
        opacity: 0.8;
      `;
      closeBtn.onclick = () => warningDiv.remove();
      warningDiv.appendChild(closeBtn);
      
      document.body.appendChild(warningDiv);
      
      // Auto-remove after 8 seconds
      setTimeout(() => {
        if (warningDiv.parentNode) {
          warningDiv.style.animation = 'slideOutRight 0.3s ease';
          setTimeout(() => warningDiv.remove(), 300);
        }
      }, 8000);
    }

    // Function to calculate optimal image scale that preserves quality
    function calculateOptimalImageScale(imageWidth, imageHeight, targetWidth, targetHeight) {
      // Calculate scale factors for width and height
      const scaleX = targetWidth / imageWidth;
      const scaleY = targetHeight / imageHeight;
      
      // Use the smaller scale to fit image within target (maintains aspect ratio)
      const scale = Math.min(scaleX, scaleY);
      
      // Calculate final dimensions
      const finalWidth = Math.round(imageWidth * scale);
      const finalHeight = Math.round(imageHeight * scale);
      
      // Quality assessment
      let quality = 'excellent';
      if (scale > 1.5) {
        quality = 'poor (upscaled)';
      } else if (scale > 1.2) {
        quality = 'fair (slightly upscaled)';
      } else if (scale < 0.5) {
        quality = 'excellent (downscaled)';
      } else if (scale < 0.8) {
        quality = 'good (downscaled)';
      }
      
      console.log('Optimal image scaling:', {
        original: `${imageWidth} √ó ${imageHeight}`,
        target: `${targetWidth} √ó ${targetHeight}`,
        scale: scale.toFixed(2),
        final: `${finalWidth} √ó ${finalHeight}`,
        quality: quality
      });
      
      return { scale, finalWidth, finalHeight, quality };
    }

    // Smart export function - edit at screen resolution, export at print resolution
    function exportAtHighRes() {

      
      // Get the current canvas
      const canvas = deskPadModalCanvas;
      if (!canvas) {
        console.error('Canvas not found');
        return;
      }
      
      // Create a temporary canvas for high-res export
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      
      // Calculate export dimensions at EXPORT_DPI (300 DPI for print quality)
      const dpiScale = EXPORT_DPI / currentDPI;
      const exportWidth = Math.round(canvas.getWidth() * dpiScale);
      const exportHeight = Math.round(canvas.getHeight() * dpiScale);
      
      // Analyze image quality for export
      const objects = canvas.getObjects();
      let qualityReport = [];
      
      objects.forEach((obj, index) => {
        if (obj.type === 'image') {
          const originalWidth = obj.width;
          const originalHeight = obj.height;
          const scaledWidth = obj.getScaledWidth();
          const scaledHeight = obj.getScaledHeight();
          
          // Calculate what the image will be at export resolution
          const exportImageWidth = Math.round(scaledWidth * dpiScale);
          const exportImageHeight = Math.round(scaledHeight * dpiScale);
          
          const scaling = calculateOptimalImageScale(originalWidth, originalHeight, exportImageWidth, exportImageHeight);
          
          qualityReport.push({
            image: index + 1,
            original: `${originalWidth} √ó ${originalHeight}`,
            export: `${exportImageWidth} √ó ${exportImageHeight}`,
            quality: scaling.quality
          });
        }
      });
      
      console.log('Smart Export:', {
        edit: `${canvas.getWidth()} √ó ${canvas.getHeight()} @ ${currentDPI} DPI (smooth editing)`,
        export: `${exportWidth} √ó ${exportHeight} @ ${EXPORT_DPI} DPI (print quality)`,
        scale: dpiScale,
        qualityReport: qualityReport
      });
      
      // Set the temporary canvas size
      tempCanvas.width = exportWidth;
      tempCanvas.height = exportHeight;
      
      // Scale the context to match the export resolution
      tempCtx.scale(dpiScale, dpiScale);
      
      // Draw the current canvas content to the temporary canvas
      tempCtx.drawImage(canvas.getElement(), 0, 0);
      
      // Convert to blob and download
      tempCanvas.toBlob((blob) => {
        if (blob) {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `deskpad-export-${exportWidth}x${exportHeight}-${EXPORT_DPI}dpi.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

        }
      }, 'image/png');
    }

    // Add export button to UI
    function addExportButton() {
      const exportBtn = document.createElement('button');
      exportBtn.textContent = 'üì§ Export Print-Ready (300 DPI)';
      exportBtn.className = 'export-btn';
      exportBtn.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        padding: 12px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        transition: all 0.3s ease;
      `;
      
      exportBtn.addEventListener('mouseenter', () => {
        exportBtn.style.transform = 'translateY(-2px)';
        exportBtn.style.boxShadow = '0 6px 20px rgba(0,0,0,0.3)';
      });
      
      exportBtn.addEventListener('mouseleave', () => {
        exportBtn.style.transform = 'translateY(0)';
        exportBtn.style.boxShadow = '0 4px 15px rgba(0,0,0,0.2)';
      });
      
      exportBtn.addEventListener('click', () => {
        exportBtn.textContent = '‚è≥ Processing...';
        exportBtn.disabled = true;
        
        setTimeout(() => {
          exportAtHighRes();
          exportBtn.textContent = 'üì§ Export Print-Ready (300 DPI)';
          exportBtn.disabled = false;
        }, 100);
      });
      
      document.body.appendChild(exportBtn);
    }

    // Initialize export button when page loads
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(addExportButton, 1000); // Add after other UI elements load
    });
    


    // Alignment toolbar toggle
    const alignmentToggleBtn = document.getElementById('alignment-toggle-btn');
    const alignmentToolbar = document.getElementById('alignment-toolbar');
    const alignmentToggleIcon = document.getElementById('alignment-toggle-icon');
    const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');

    if (alignmentToggleBtn && alignmentToolbar) {
      alignmentToggleBtn.addEventListener('click', () => {
        const isVisible = alignmentToolbar.classList.contains('show');
        
        if (isVisible) {
          alignmentToolbar.classList.remove('show');
          alignmentToggleBtn.classList.remove('active');
          alignmentToggleIcon.textContent = '‚ñº';
          if (canvasContainer) {
            canvasContainer.classList.remove('with-alignment-toolbar');
          }
        } else {
          // Close canvas toolbar first
          canvasToolbar.classList.remove('show');
          canvasToggleBtn.classList.remove('active');
          canvasToggleIcon.textContent = '‚ñº';
          
          // Open alignment toolbar
          alignmentToolbar.classList.add('show');
          alignmentToggleBtn.classList.add('active');
          alignmentToggleIcon.textContent = '‚ñ≤';
          if (canvasContainer) {
            canvasContainer.classList.add('with-alignment-toolbar');
          }
        }
      });

    }

    // Canvas toolbar toggle
    const canvasToggleBtn = document.getElementById('canvas-toggle-btn');
    const canvasToolbar = document.getElementById('canvas-toolbar');
    const canvasToggleIcon = document.getElementById('canvas-toggle-icon');

    if (canvasToggleBtn && canvasToolbar) {
      canvasToggleBtn.addEventListener('click', () => {
        const isVisible = canvasToolbar.classList.contains('show');
        
        if (isVisible) {
          canvasToolbar.classList.remove('show');
          canvasToggleBtn.classList.remove('active');
          canvasToggleIcon.textContent = '‚ñº';
          if (canvasContainer) {
            canvasContainer.classList.remove('with-alignment-toolbar');
          }
        } else {
          // Close alignment toolbar first
          alignmentToolbar.classList.remove('show');
          alignmentToggleBtn.classList.remove('active');
          alignmentToggleIcon.textContent = '‚ñº';
          if (canvasContainer) {
            canvasContainer.classList.remove('with-alignment-toolbar');
          }
          
          // Open canvas toolbar
          canvasToolbar.classList.add('show');
          canvasToggleBtn.classList.add('active');
          canvasToggleIcon.textContent = '‚ñ≤';
          if (canvasContainer) {
            canvasContainer.classList.add('with-alignment-toolbar');
          }
        }
      });

    }

    // Layers menu toggle
    const layersToggleBtn = document.getElementById('layers-toggle-btn');
    const layersMenu = document.getElementById('layers-menu');
    const layersToggleIcon = document.getElementById('layers-toggle-icon');
    const layersCloseBtn = document.getElementById('layers-close');

    if (layersToggleBtn && layersMenu) {
      layersToggleBtn.addEventListener('click', () => {
        const isVisible = layersMenu.classList.contains('show');

        
        if (isVisible) {

          layersMenu.classList.remove('show');
          layersToggleBtn.classList.remove('active');
          layersToggleIcon.textContent = '‚ñº';
          // Remove canvas adjustment
          if (canvasContainer) {
            canvasContainer.classList.remove('with-layers-menu');

            
            // Update the canvas transform to remove layers menu scale
            if (typeof resizeCanvasDom === 'function') {
              resizeCanvasDom(currentScale);
            }
            

          }
          if (alignmentToolbar) {
            alignmentToolbar.classList.remove('with-layers-menu');
          }
          if (canvasToolbar) {
            canvasToolbar.classList.remove('with-layers-menu');
          }
        } else {

          // Close other toolbars first
          alignmentToolbar.classList.remove('show');
          alignmentToggleBtn.classList.remove('active');
          alignmentToggleIcon.textContent = '‚ñº';
          if (canvasContainer) {
            canvasContainer.classList.remove('with-alignment-toolbar');
          }
          
          canvasToolbar.classList.remove('show');
          canvasToggleBtn.classList.remove('active');
          canvasToggleIcon.textContent = '‚ñº';
          
          // Open layers menu
          layersMenu.classList.add('show');
          layersToggleBtn.classList.add('active');
          layersToggleIcon.textContent = '‚ñ≤';
          // Add canvas adjustment
          if (canvasContainer) {

            canvasContainer.classList.add('with-layers-menu');

            
            // Force a reflow to ensure styles are applied
            canvasContainer.offsetHeight;
            
            // Update the canvas transform to include layers menu scale
            if (typeof resizeCanvasDom === 'function') {
              resizeCanvasDom(currentScale);
            }
            

          }
          if (alignmentToolbar) {
            alignmentToolbar.classList.add('with-layers-menu');
          }
          if (canvasToolbar) {
            canvasToolbar.classList.add('with-layers-menu');
          }
        }
      });

    }

    // Layers menu close button
    if (layersCloseBtn && layersMenu) {
      layersCloseBtn.addEventListener('click', () => {

        layersMenu.classList.remove('show');
        layersToggleBtn.classList.remove('active');
        layersToggleIcon.textContent = '‚ñº';
        // Remove canvas adjustment
        if (canvasContainer) {
          console.log('Removing with-layers-menu class from canvas container (close button)');
          canvasContainer.classList.remove('with-layers-menu');

        }
        if (alignmentToolbar) {
          alignmentToolbar.classList.remove('with-layers-menu');
        }
        if (canvasToolbar) {
          canvasToolbar.classList.remove('with-layers-menu');
        }
      });

    }

    // Layer Management System
    let layers = [];
    let activeLayerId = null;
    let draggedLayer = null;
    let dragStartY = 0;

    // Initialize layer management
    function initializeLayerManagement() {
      updateLayersList();
      setupLayerDragAndDrop();
    }

    // Create a new layer
    function createLayer(name, type, object = null) {
      const layer = {
        id: 'layer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: name,
        type: type,
        visible: true,
        locked: false,
        object: object,
        order: layers.length
      };
      
      layers.push(layer);
      updateLayersList();
      return layer;
    }

    // Update the layers list display
    function updateLayersList() {
      const layersList = document.getElementById('layers-list');
      if (!layersList) return;

      // Don't update if we're currently dragging
      if (draggedLayer) return;

      layersList.innerHTML = '';

      // Sort layers by order (top to bottom)
      const sortedLayers = [...layers].sort((a, b) => b.order - a.order);

      sortedLayers.forEach((layer, index) => {
        const layerElement = createLayerElement(layer, index);
        layersList.appendChild(layerElement);
      });

      // Add background layer if no layers exist
      if (layers.length === 0) {
        const backgroundLayer = createLayer('Background', 'Canvas');
        backgroundLayer.order = -1; // Always at bottom
      }
    }

    // Create a layer element
    function createLayerElement(layer, index) {
      const layerDiv = document.createElement('div');
      layerDiv.className = 'layer-item';
      layerDiv.dataset.layerId = layer.id;
      
      if (layer.id === activeLayerId) {
        layerDiv.classList.add('active');
      }
      if (layer.locked) {
        layerDiv.classList.add('locked');
      }
      if (!layer.visible) {
        layerDiv.classList.add('hidden');
      }

      layerDiv.innerHTML = `
        <div class="layer-item-header">
          <div class="layer-info">
            <div class="layer-name">${layer.name}</div>
            <div class="layer-type">${layer.type}</div>
          </div>
          <div class="layer-controls">
            <button class="layer-control-btn visibility-btn" title="${layer.visible ? 'Hide' : 'Show'} layer">
              ${layer.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'}
            </button>
            <button class="layer-control-btn lock-btn" title="${layer.locked ? 'Unlock' : 'Lock'} layer">
              ${layer.locked ? 'üîí' : 'üîì'}
            </button>
            <button class="layer-control-btn delete-btn" title="Delete layer">üóëÔ∏è</button>
          </div>
        </div>
        <div class="layer-properties">
          ${getLayerProperties(layer)}
        </div>
      `;

      // Add event listeners
      const visibilityBtn = layerDiv.querySelector('.visibility-btn');
      const lockBtn = layerDiv.querySelector('.lock-btn');
      const deleteBtn = layerDiv.querySelector('.delete-btn');
      const dragHandle = layerDiv.querySelector('.layer-drag-handle');

      visibilityBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleLayerVisibility(layer.id);
      });

      lockBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleLayerLock(layer.id);
      });

      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteLayer(layer.id);
      });

      // Layer selection
      layerDiv.addEventListener('click', () => {
        selectLayer(layer.id);
      });

      return layerDiv;
    }

    // Get layer properties string
    function getLayerProperties(layer) {
      if (layer.object) {
        const obj = layer.object;
        if (obj.type === 'image') {
          return 'Image layer';
        } else if (obj.type === 'text') {
          return `${obj.text.length} characters`;
        }
      }
      return 'Layer properties';
    }

    // Update properties panel with detailed information
    function updatePropertiesPanel(layer) {
      const propertiesPanel = document.getElementById('properties-panel');
      if (!propertiesPanel) return;

      if (!layer || !layer.object) {
        propertiesPanel.innerHTML = `
          <div style="color: #ccc; font-size: 12px; font-style: italic;">
            Select an object to view its properties
          </div>
        `;
        return;
      }

      const obj = layer.object;
      let propertiesHTML = '';

      if (obj.type === 'image') {
        const width = Math.round(obj.width * obj.scaleX);
        const height = Math.round(obj.height * obj.scaleY);
        const originalWidth = Math.round(obj.width);
        const originalHeight = Math.round(obj.height);
        const scaleX = Math.round(obj.scaleX * 100);
        const scaleY = Math.round(obj.scaleY * 100);
        const angle = Math.round(obj.angle || 0);
        const left = Math.round(obj.left || 0);
        const top = Math.round(obj.top || 0);

        propertiesHTML = `
          <div style="color: #f4a012; font-size: 14px; font-weight: bold; margin-bottom: 12px;">
            Image Properties
          </div>
          <div style="font-size: 12px; color: #ccc; line-height: 1.6;">
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Display Size:</span><br>
              <span style="color: #fff; font-weight: bold;">${width} √ó ${height}px</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Original Size:</span><br>
              <span style="color: #fff;">${originalWidth} √ó ${originalHeight}px</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Scale:</span><br>
              <span style="color: #fff;">${scaleX}% √ó ${scaleY}%</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Rotation:</span><br>
              <span style="color: #fff;">${angle}¬∞</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Position:</span><br>
              <span style="color: #fff;">X: ${left}px, Y: ${top}px</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Layer:</span><br>
              <span style="color: #fff;">${layer.name}</span>
            </div>
          </div>
        `;
      } else if (obj.type === 'text') {
        const fontSize = Math.round(obj.fontSize || 16);
        const fontFamily = obj.fontFamily || 'Arial';
        const textLength = obj.text.length;
        const left = Math.round(obj.left || 0);
        const top = Math.round(obj.top || 0);
        const angle = Math.round(obj.angle || 0);

        propertiesHTML = `
          <div style="color: #f4a012; font-size: 14px; font-weight: bold; margin-bottom: 12px;">
            Text Properties
          </div>
          <div style="font-size: 12px; color: #ccc; line-height: 1.6;">
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Text:</span><br>
              <span style="color: #fff; font-style: italic;">"${obj.text.substring(0, 50)}${obj.text.length > 50 ? '...' : ''}"</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Characters:</span><br>
              <span style="color: #fff;">${textLength}</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Font:</span><br>
              <span style="color: #fff;">${fontFamily} ${fontSize}px</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Rotation:</span><br>
              <span style="color: #fff;">${angle}¬∞</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Position:</span><br>
              <span style="color: #fff;">X: ${left}px, Y: ${top}px</span>
            </div>
            <div style="margin-bottom: 8px;">
              <span style="color: #999;">Layer:</span><br>
              <span style="color: #fff;">${layer.name}</span>
            </div>
          </div>
        `;
      } else {
        propertiesHTML = `
          <div style="color: #ccc; font-size: 12px; font-style: italic;">
            Unknown object type
          </div>
        `;
      }

      propertiesPanel.innerHTML = propertiesHTML;
    }

    // Update properties panel from canvas selection
    function updatePropertiesPanelFromSelection(selectedObject) {
      if (!selectedObject) {
        // No object selected, show default message
        const propertiesPanel = document.getElementById('properties-panel');
        if (propertiesPanel) {
          propertiesPanel.innerHTML = `
            <div style="color: #ccc; font-size: 12px; font-style: italic;">
              Select an object to view its properties
            </div>
          `;
        }
        return;
      }

      // Find the layer that contains this object
      const layer = layers.find(l => l.object === selectedObject);
      if (layer) {
        updatePropertiesPanel(layer);
      } else {
        // Object not found in layers, create a temporary layer object
        const tempLayer = {
          id: 'temp',
          name: 'Selected Object',
          type: selectedObject.type === 'image' ? 'Image' : 'Text',
          object: selectedObject
        };
        updatePropertiesPanel(tempLayer);
      }
    }

    // Toggle layer visibility
    function toggleLayerVisibility(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer) {
        layer.visible = !layer.visible;
        
        // Update canvas object visibility
        if (layer.object && deskPadModalCanvas) {
          layer.object.visible = layer.visible;
          deskPadModalCanvas.renderAll();
        }
        
        updateLayersList();
      }
    }

    // Toggle layer lock
    function toggleLayerLock(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer) {
        layer.locked = !layer.locked;
        
        // Update canvas object lock
        if (layer.object && deskPadModalCanvas) {
          layer.object.selectable = !layer.locked;
          layer.object.evented = !layer.locked;
          deskPadModalCanvas.renderAll();
        }
        
        updateLayersList();
      }
    }

    // Delete layer
    function deleteLayer(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer && layer.type !== 'Canvas') {
        // Remove from canvas
        if (layer.object && deskPadModalCanvas) {
          deskPadModalCanvas.remove(layer.object);
          deskPadModalCanvas.renderAll();
        }
        
        // Remove from layers array
        layers = layers.filter(l => l.id !== layerId);
        
        // Update active layer
        if (activeLayerId === layerId) {
          activeLayerId = layers.length > 0 ? layers[0].id : null;
        }
        
        updateLayersList();
      }
    }

    // Select layer
    function selectLayer(layerId) {
      activeLayerId = layerId;
      
      // Select object on canvas
      const layer = layers.find(l => l.id === layerId);
      if (layer && layer.object && deskPadModalCanvas) {
        deskPadModalCanvas.setActiveObject(layer.object);
        deskPadModalCanvas.renderAll();
      }
      
      updateLayersList();
      updatePropertiesPanel(layer);
    }

    // Setup drag and drop functionality - DISABLED
    function setupLayerDragAndDrop() {
      // Drag and drop functionality temporarily disabled
    }

    // Start dragging
    function startDrag(layerItem, startY, startX) {
      const layerId = layerItem.dataset.layerId;
      const layer = layers.find(l => l.id === layerId);
      
      if (!layer || layer.locked) {
        return;
      }

      draggedLayer = layerItem;
      dragStartY = startY;
      dragStartX = startX;
      
      // Get original position
      const rect = layerItem.getBoundingClientRect();
      
      layerItem.classList.add('dragging');
      layerItem.style.position = 'fixed';
      layerItem.style.zIndex = '10000';
      layerItem.style.pointerEvents = 'none';
      layerItem.style.width = rect.width + 'px';
      layerItem.style.left = rect.left + 'px';
      layerItem.style.top = rect.top + 'px';
      
      // Create drop indicators
      createDropIndicators();
    }

    // Handle drag movement
    function handleDrag(e) {
      if (!draggedLayer) {
        return;
      }

      const rect = draggedLayer.getBoundingClientRect();
      const newX = e.clientX - rect.width / 2;
      const newY = e.clientY - rect.height / 2;
      
      // Simple movement - just follow the cursor
      draggedLayer.style.left = newX + 'px';
      draggedLayer.style.top = newY + 'px';

      // Update drop indicators
      updateDropIndicators(e.clientY);
    }

    // Stop dragging
    function stopDrag() {
      if (!draggedLayer) {
        return;
      }

      const layerId = draggedLayer.dataset.layerId;
      const newOrder = getDropPosition();

      // Clean up the dragged element first
      const draggedElement = draggedLayer;
      draggedLayer = null;
      removeDropIndicators();

      // Update layer order if needed
      if (newOrder !== null) {
        const layer = layers.find(l => l.id === layerId);
        if (layer) {
          layer.order = newOrder;
          // Update the layers list to reflect the new order
          updateLayersList();
        }
      } else {
        // If no reordering, just clean up the dragged element
        if (draggedElement) {
          draggedElement.classList.remove('dragging');
          draggedElement.style.position = '';
          draggedElement.style.zIndex = '';
          draggedElement.style.left = '';
          draggedElement.style.top = '';
          draggedElement.style.pointerEvents = '';
          draggedElement.style.width = '';
          draggedElement.style.height = '';
          draggedElement.style.transform = '';
        }
      }
    }

    // Create drop indicators
    function createDropIndicators() {
      const layersList = document.getElementById('layers-list');
      const layerItems = layersList.querySelectorAll('.layer-item');
      
      layerItems.forEach((item, index) => {
        if (item !== draggedLayer) {
          const indicator = document.createElement('div');
          indicator.className = 'drop-indicator';
          indicator.dataset.index = index;
          item.parentNode.insertBefore(indicator, item);
        }
      });
    }

    // Update drop indicators
    function updateDropIndicators(mouseY) {
      const indicators = document.querySelectorAll('.drop-indicator');
      const layersList = document.getElementById('layers-list');
      const layerItems = layersList.querySelectorAll('.layer-item:not(.dragging)');
      
      indicators.forEach((indicator, index) => {
        const item = layerItems[index];
        if (item) {
          const rect = item.getBoundingClientRect();
          const isAbove = mouseY < rect.top + rect.height / 2;
          
          if (isAbove) {
            indicator.classList.add('active');
            indicator.style.opacity = '1';
          } else {
            indicator.classList.remove('active');
            indicator.style.opacity = '0.4';
          }
        }
      });
    }

    // Remove drop indicators
    function removeDropIndicators() {
      const indicators = document.querySelectorAll('.drop-indicator');
      indicators.forEach(indicator => indicator.remove());
    }

    // Get drop position
    function getDropPosition() {
      const indicators = document.querySelectorAll('.drop-indicator');
      const layersList = document.getElementById('layers-list');
      const layerItems = layersList.querySelectorAll('.layer-item:not(.dragging)');
      
      for (let i = 0; i < indicators.length; i++) {
        const indicator = indicators[i];
        const item = layerItems[i];
        
        if (indicator.classList.contains('active') && item) {
          const layerId = item.dataset.layerId;
          const layer = layers.find(l => l.id === layerId);
          return layer ? layer.order : null;
        }
      }
      
      return null;
    }

    // Initialize layer management when layers menu is opened
    if (layersMenu) {
      const originalShow = layersMenu.classList.add;
      layersMenu.classList.add = function(...args) {
        originalShow.apply(this, args);
        if (args.includes('show')) {
          initializeLayerManagement();
        }
      };
    }

    // Function to update alignment toolbar based on selected object type
    function updateAlignmentToolbar() {
      if (!deskPadModalCanvas) return;
      
      const activeObject = deskPadModalCanvas.getActiveObject();
      const alignmentToolbar = document.getElementById('alignment-toolbar');
      
      if (!alignmentToolbar) return;
      
      // Get all alignment buttons
      const imageButtons = ['fill-canvas', 'fit-canvas', 'center-canvas', 'duplicate-image'];
      const textButtons = ['duplicate-text'];
      const commonButtons = ['align-top', 'align-center', 'align-bottom', 'align-left', 'align-right'];
      
      if (activeObject) {
        if (activeObject.type === 'i-text' || activeObject.type === 'text') {
          // Show text-appropriate buttons
          commonButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'flex';
          });
          
          // Hide image-specific buttons
          imageButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'none';
          });
          
          // Show text-specific buttons
          textButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'flex';
          });
          

        } else if (activeObject.type === 'image') {
          // Show image-appropriate buttons
          commonButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'flex';
          });
          
          // Show image-specific buttons
          imageButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'flex';
          });
          
          // Hide text-specific buttons
          textButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'none';
          });
          

        }
      } else {
        // No selection - show all buttons
        [...commonButtons, ...imageButtons, ...textButtons].forEach(btnId => {
          const btn = document.getElementById(btnId);
          if (btn) btn.style.display = 'flex';
        });
      }
    }

    // Alignment button event listeners
    const alignmentButtons = [
      'align-top', 'align-center', 'align-bottom',
      'align-left', 'align-right', 'fill-canvas', 'fit-canvas', 'center-canvas',
      'duplicate-image', 'duplicate-text'
    ];

    alignmentButtons.forEach(btnId => {
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.addEventListener('click', () => {
          // Check if objects are selected
          if (!deskPadModalCanvas) {

            return;
          }
          
          const activeObjects = deskPadModalCanvas.getActiveObjects();
          if (activeObjects.length === 0) {

            // Show visual feedback
            btn.style.background = '#ff4444';
            btn.style.color = '#fff';
            setTimeout(() => {
              btn.style.background = '';
              btn.style.color = '';
            }, 500);
            return;
          }
          
          // Remove active class from all buttons
          alignmentButtons.forEach(id => {
            const button = document.getElementById(id);
            if (button) button.classList.remove('active');
          });
          
          // Add active class to clicked button
          btn.classList.add('active');
          
          // Handle alignment action
          handleAlignment(btnId);
          
          // Remove active class after a short delay
          setTimeout(() => {
            btn.classList.remove('active');
          }, 300);
        });
      }
    });

    // Alignment function
    function handleAlignment(alignmentType) {
      if (!deskPadModalCanvas) {

        return;
      }
      
      const activeObjects = deskPadModalCanvas.getActiveObjects();
      if (activeObjects.length === 0) {

        return;
      }
      
      const canvas = deskPadModalCanvas;
      
      // Get the actual canvas dimensions (these are the logical dimensions)
      const canvasWidth = canvas.getWidth();
      const canvasHeight = canvas.getHeight();
      
      // Get the visual canvas container dimensions
      const canvasContainer = document.getElementById('desk-pad-modal-canvas-container');
      const visualWidth = canvasContainer ? canvasContainer.clientWidth : canvasWidth;
      const visualHeight = canvasContainer ? canvasContainer.clientHeight : canvasHeight;
      

      
      // Handle alignment using logical canvas dimensions
      activeObjects.forEach((obj, index) => {
        const oldLeft = obj.left;
        const oldTop = obj.top;
        
        // Calculate the actual scaled dimensions
        const scaledWidth = obj.getScaledWidth();
        const scaledHeight = obj.getScaledHeight();
        
        let newLeft = oldLeft;
        let newTop = oldTop;
        
        // Account for origin point when calculating alignment
        const originX = obj.originX || 'left';
        const originY = obj.originY || 'top';
        
        switch(alignmentType) {
          case 'align-top':
            if (originY === 'center') {
              newTop = scaledHeight / 2;
            } else if (originY === 'bottom') {
              newTop = scaledHeight;
            } else {
              newTop = 0;
            }
            break;
          case 'align-center':
            // Center both horizontally and vertically
            // Horizontal centering
            if (originX === 'center') {
              newLeft = canvasWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth - scaledWidth / 2;
            } else {
              newLeft = (canvasWidth - scaledWidth) / 2;
            }
            
            // Vertical centering
            if (originY === 'center') {
              newTop = canvasHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight - scaledHeight / 2;
            } else {
              newTop = (canvasHeight - scaledHeight) / 2;
            }
            break;
          case 'align-bottom':
            if (originY === 'center') {
              newTop = canvasHeight - scaledHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight;
            } else {
              newTop = canvasHeight - scaledHeight;
            }
            break;
          case 'align-left':
            if (originX === 'center') {
              newLeft = scaledWidth / 2;
            } else if (originX === 'right') {
              newLeft = scaledWidth;
            } else {
              newLeft = 0;
            }
            break;
          case 'fill-canvas':
            // Scale image to fill canvas while maintaining aspect ratio
            const canvasAspect = canvasWidth / canvasHeight;
            const imageAspect = scaledWidth / scaledHeight;
            
            let newScaleX, newScaleY;
            if (imageAspect > canvasAspect) {
              // Image is wider than canvas - fit to width
              newScaleX = canvasWidth / (obj.width || scaledWidth);
              newScaleY = newScaleX;
            } else {
              // Image is taller than canvas - fit to height
              newScaleY = canvasHeight / (obj.height || scaledHeight);
              newScaleX = newScaleY;
            }
            
            // Center the image
            if (originX === 'center') {
              newLeft = canvasWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth;
            } else {
              newLeft = canvasWidth / 2;
            }
            
            if (originY === 'center') {
              newTop = canvasHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight;
            } else {
              newTop = canvasHeight / 2;
            }
            
            // Apply new scale and position
            obj.set({
              scaleX: newScaleX,
              scaleY: newScaleY,
              left: newLeft,
              top: newTop
            });
            

            
            // Force the object to update its coordinates
            obj.setCoords();
            break;
          case 'fit-canvas':
            // Scale image to fit canvas while maintaining aspect ratio (may have letterboxing)
            const fitCanvasAspect = canvasWidth / canvasHeight;
            const fitImageAspect = scaledWidth / scaledHeight;
            
            let fitScaleX, fitScaleY;
            if (fitImageAspect > fitCanvasAspect) {
              // Image is wider than canvas - fit to height
              fitScaleY = canvasHeight / (obj.height || scaledHeight);
              fitScaleX = fitScaleY;
            } else {
              // Image is taller than canvas - fit to width
              fitScaleX = canvasWidth / (obj.width || scaledWidth);
              fitScaleY = fitScaleX;
            }
            
            // Center the image
            if (originX === 'center') {
              newLeft = canvasWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth;
            } else {
              newLeft = canvasWidth / 2;
            }
            
            if (originY === 'center') {
              newTop = canvasHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight;
            } else {
              newTop = canvasHeight / 2;
            }
            
            // Apply new scale and position
            obj.set({
              scaleX: fitScaleX,
              scaleY: fitScaleY,
              left: newLeft,
              top: newTop
            });
            

            
            // Force the object to update its coordinates
            obj.setCoords();
            break;
          case 'center-canvas':
            // Just center the image without changing scale
            if (originX === 'center') {
              newLeft = canvasWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth;
            } else {
              newLeft = canvasWidth / 2;
            }
            
            if (originY === 'center') {
              newTop = canvasHeight / 2;
            } else if (originY === 'bottom') {
              newTop = canvasHeight;
            } else {
              newTop = canvasHeight / 2;
            }
            

            break;

          case 'align-right':
            if (originX === 'center') {
              newLeft = canvasWidth - scaledWidth / 2;
            } else if (originX === 'right') {
              newLeft = canvasWidth;
            } else {
              newLeft = canvasWidth - scaledWidth;
            }
            break;
          case 'duplicate-image':
            // Create a duplicate of the selected image
            if (obj.type === 'image') {
              // Create a new Fabric.js image from the original
              fabric.Image.fromURL(obj._originalDataUrl || obj._element.src, newImg => {
                // Copy all properties from the original
                newImg.set({
                  left: obj.left + 20, // Offset slightly from original
                  top: obj.top + 20,
                  scaleX: obj.scaleX,
                  scaleY: obj.scaleY,
                  angle: obj.angle,
                  flipX: obj.flipX,
                  flipY: obj.flipY,
                  originX: obj.originX,
                  originY: obj.originY,
                  selectable: true,
                  hasControls: true,
                  hasBorders: true,
                  stroke: 'transparent',
                  strokeWidth: 0
                });
                
                // Copy original data URL
                newImg._originalDataUrl = obj._originalDataUrl;
                
                // Add to canvas
                canvas.add(newImg);
                canvas.setActiveObject(newImg);
                canvas.requestRenderAll();
                

              });
            }
            break;
          case 'duplicate-text':
            // Create a duplicate of the selected text
            if (obj.type === 'i-text' || obj.type === 'text') {
              // Create a new Fabric.js text object
              const newText = new fabric.IText(obj.text, {
                left: obj.left + 20, // Offset slightly from original
                top: obj.top + 20,
                fontSize: obj.fontSize,
                fontFamily: obj.fontFamily,
                fill: obj.fill,
                angle: obj.angle,
                scaleX: obj.scaleX,
                scaleY: obj.scaleY,
                flipX: obj.flipX,
                flipY: obj.flipY,
                originX: obj.originX,
                originY: obj.originY,
                selectable: true,
                hasControls: true,
                hasBorders: true,
                textBaseline: 'alphabetic'
              });
              
              // Add to canvas
              canvas.add(newText);
              canvas.setActiveObject(newText);
              canvas.requestRenderAll();
              

            }
            break;

        }
        
        // Apply the new position
        obj.set({
          left: newLeft,
          top: newTop
        });
        

        
        // Force the object to update its coordinates
        obj.setCoords();
        

      });
      
      // Force canvas to update
      canvas.requestRenderAll();
      canvas.calcOffset();
      

      

      
      // Add visual feedback
      showAlignmentFeedback(alignmentType);
    }
    
    // Helper function to ensure canvas is in a known state for alignment
    function ensureCanvasAlignmentState() {
      if (!deskPadModalCanvas) return;
      
      const canvas = deskPadModalCanvas;
      
      // Reset viewport transform to identity (no zoom/pan)
      canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
      
      // Ensure canvas is at 100% zoom
      canvas.setZoom(1);
      
      // Recalculate everything
      canvas.requestRenderAll();
      canvas.calcOffset();
      
      console.log('Canvas reset to alignment state:', {
        zoom: canvas.getZoom(),
        viewportTransform: canvas.viewportTransform,
        width: canvas.getWidth(),
        height: canvas.getHeight()
      });
    }
    

    
    // Visual feedback for alignment
    function showAlignmentFeedback(alignmentType) {
      // Create a temporary visual indicator
      const feedback = document.createElement('div');
      feedback.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(244, 160, 18, 0.9);
        color: #222;
        padding: 8px 16px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
        z-index: 20000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      // Create appropriate feedback text based on action type
      let feedbackText = '';
      if (alignmentType.startsWith('align-')) {
        feedbackText = `Aligned: ${alignmentType.replace('align-', '').toUpperCase()}`;
      } else if (alignmentType === 'duplicate-image') {
        feedbackText = 'Image Duplicated';
      } else if (alignmentType === 'pattern-mode') {
        feedbackText = 'Pattern Mode Toggled';
      } else {
        feedbackText = alignmentType.replace('-', ' ').toUpperCase();
      }
      feedback.textContent = feedbackText;
      
      document.body.appendChild(feedback);
      
      // Show feedback
      setTimeout(() => feedback.style.opacity = '1', 10);
      
      // Hide feedback after 1 second
      setTimeout(() => {
        feedback.style.opacity = '0';
        setTimeout(() => document.body.removeChild(feedback), 300);
      }, 1000);
    }

  </script>
</body>
</html> 
